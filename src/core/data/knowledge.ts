/**
 * @file System Knowledge Base
 * Auto-generated by scripts/bundle-docs.cjs
 * Contains the full content of the docs/ directory for AI context.
 */

export const SYSTEM_KNOWLEDGE: Record<string, string> = {
    "REFACTOR-V10.adoc": "= ARGUS v10 Refactor Specification: Host/Guest Contract Formation\n:author: ARGUS Collaborative Development\n:revdate: 2026-02-20\n:revnumber: 10.3.0\n:toc: macro\n:toclevels: 3\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThis specification records the v10 refactor as an architectural separation event\nrather than a feature increment. The pre-v10 system still contained\nworkflow-specific assumptions inside core orchestration paths, which created\ncoupling between persona evolution and kernel stability. The v10 program resolves\nthat coupling by establishing a formal Host/Guest boundary: Calypso operates as a\ndeterministic integrity kernel, while domain compute is executed as unprivileged\nplugins selected by manifest contracts.\n\nThe same transition also redefined intent handling as protocol compilation and\nverification, replacing legacy waterfall dispatch with a constrained\ninterpretation-first pipeline. The key result is that natural language remains a\ncontrol surface, but state mutation authority remains in deterministic,\nverifiable runtime layers.\n\n== Historical Pressure\n\nBefore v10, introducing or modifying workflow behavior required touching core\ndispatch logic. That made correctness fragile because unrelated stage changes could\nalter global execution behavior. Verification effort also drifted toward\nconversation matching because protocol semantics were mixed with narrative output.\nAs workflows became more branched and provenance-sensitive, this model could no\nlonger defend reproducibility claims.\n\nThe refactor objective was therefore to align architecture with scientific\nrequirements: command interpretation may be probabilistic, but command execution\nand state transitions must be deterministic and materialized.\n\n== Refactor Shift Figure\n\n[source,text]\n----\nv9 monolithic dispatch:\n\n┌────────────────────────────────────────────────────┐\n│ CORE ORCHESTRATOR                                  │\n│ intent + workflow logic + compute + state writes   │\n└────────────────────────────────────────────────────┘\n\nv10 host/guest contract:\n\n┌────────────────┐   ┌────────────────┐   ┌────────────────┐   ┌────────────────┐\n│ INTENT PARSE   │──▶│ DAG VALIDATE   │──▶│ PLUGIN EXECUTE │──▶│ MERKLE WRITE   │\n└────────────────┘   └────────────────┘   └────────────────┘   └────────────────┘\n      (HOST)               (HOST)                (GUEST)              (HOST)\n----\n\n== Refactor Resolution\n\nThe v10 line introduced a five-layer runtime sequence that remains active in the\ncurrent codebase. User language is compiled into a canonical intent, validated\nagainst active workflow topology, dispatched to a plugin selected by manifest\nhandler, and materialized by host-controlled Merkle anchoring. Graceful\ndegradation remains available when no model provider is configured, but that path\nstill uses the same deterministic execution contract for workflow commands.\n\nThe resulting protocol contract replaced binary success signaling with categorical\nstatus outcomes, allowing machine-verifiable assertion against blocked, stale,\nconversational, and successful branches.\n\n== Runtime Contract Surface\n\nThe plugin boundary is now enforced through a typed context/result interface.\nPlugins receive only project-scoped capabilities and return evidence payloads.\nThey do not own provenance writes, and they do not mutate kernel configuration.\nThe host captures plugin output, computes Merkle lineage, and materializes session\nartifacts as the sole witness of completion.\n\n[source,typescript]\n----\ninterface PluginContext {\n    vfs: VirtualFileSystem;\n    shell: Shell;\n    store: CalypsoStoreActions;\n    parameters: Record<string, unknown>;\n}\n\ninterface PluginResult {\n    message: string;\n    statusCode: CalypsoStatusCode;\n    artifactData?: unknown;\n}\n----\n\nThis contract made it possible to externalize domain logic without sacrificing\nexecution rigor. It also established the basis for later hardening work in which\nfederation phases were materialized as individual plugins and backend simulation\npaths were deleted.\n\n== Verification Consequence: Oracle v2\n\nRefactor completion required verification strategy change. Oracle scenarios moved\nfrom conversational assertions to contractual walks that validate status outcomes\nand artifact existence. That shift closed a major blind spot from pre-v10 tests:\na fluent response can no longer mask missing materialization.\n\n== Architectural Outcome\n\nThe v10 refactor created the foundation for the subsequent hardening and deletion\nreleases. By relocating workflow compute into manifest-selected plugins and\nrestricting kernel responsibility to validation and provenance, ARGUS moved from a\nmonolithic orchestrator to a composable execution kernel. Later releases in the\n10.2 and 10.3 line should be understood as contract purification of this same\ndesign, not as a separate architectural direction.\n\n---\n_Last updated: 2026-02-20 (v10.3.0)_",
    "agentic-safety.adoc": "= ARGUS Safety Foundations: The Math of Agentic Integrity\n:author: ATLAS Project Team\n:revdate: 2026-02-17\n:revnumber: 10.0.0\n:toc: macro\n:toclevels: 3\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThis document provides the formal mathematical and architectural foundations for the ARGUS safety model. It analyzes the \"Irreducible Hallucination\" problem inherent in probabilistic AI systems and provides a proof for the necessity of the **Intent-Action Service (IAS)** separation in high-integrity research workflows. By grounding the system in deterministic data-states, ARGUS creates a structural safety framework that ensures scientific validity independently of AI model quality.\n\n== Introduction: The Historical Context\n\nThe safety model of ARGUS was developed in response to the \"Control-Flow Drift\" observed in early legacy iterations of the project. Versions 1.0 through 9.0 relied on the Large Language Model (LLM) to maintain the authoritative state of the user session within its own context window. This approach consistently failed as research sessions became longer and more complex; the model's internal probability distribution would eventually shift away from the project's physical reality, leading to confident but incorrect procedural guidance.\n\nWe learned that safety in AI-mediated systems is not a property of \"better prompting\" or \"RLHF alignment,\" but a property of **better architecture**. The resolution was the formalization of **Data-State Grounding**. By ensuring that every state transition is a verifiable mutation of a deterministic filesystem (the VFS), ARGUS creates a \"structural safety\" where the system's \"Truth\" is a physical property of the environment rather than a linguistic claim.\n\n== The Irreducible Hallucination Problem: Probabilities vs. States\n\nThe core of the safety challenge lies in the fundamental difference between probabilistic token prediction and deterministic state transformation.\n\n*   **The Multiplication of Error:** Let $P(s)$ be the probability that an AI correctly executes a single step in a workflow. For a sequence of $n$ autonomous steps, the total reliability is $P(s)^n$. As $n$ increases, the probability of a \"Session Drift\" approach 1.0, regardless of how high $P(s)$ is.\n*   **The Truth Gap:** An AI can \"believe\" it has performed an action (e.g., \"I have harmonized the data\") because it generated the text describing the success. However, without a deterministic feedback loop from the environment, there is no mechanism to verify the claim.\n\nARGUS addresses this by enforcing an **asymmetric loop**: the AI proposes the *Intent*, but only the deterministic *Action* (the Plugin) can produce the *State* (the Artifact). The system's integrity is thus governed by the deterministic layer, not the probabilistic layer.\n\n== The IAS Formalism: Intents, Actions, States\n\nThe ARGUS safety model is formally defined by the separation of the interaction into three discrete phases:\n\n1.  **Intents ($\\mathcal{I}$):** The high-entropy, noisy linguistic input from the human user.\n2.  **Actions ($\\mathcal{A}$):** The low-entropy, deterministic protocol commands dispatched to the Host.\n3.  **States ($\\mathcal{S}$):** The persistent, materialized artifacts in the project and session trees.\n\nSafety is achieved by ensuring that $\\mathcal{I} \\rightarrow \\mathcal{A}$ is the *only* role of the AI. The transformation $\\mathcal{A} \\rightarrow \\mathcal{S}$ is handled by the `PluginHost` and `MerkleEngine`, which are entirely external to the AI's influence. This prevents \"state-injection\" attacks where an AI might attempt to claim a state transition without performing the corresponding action.\n\n== Merkle Provenance as a Safety Proof\n\nTo ensure the integrity of the scientific process over time, ARGUS utilizes a Merkle Provenance Chain.\n\n*   **Proof of Work:** Every artifact materialized by the `MerkleEngine` is a \"Proof of Execution.\" The SHA-256 fingerprint anchors the artifact to its specific logic and its specific parentage in the workflow DAG.\n*   **Drift Detection:** If any upstream state is modified, the downstream fingerprints become invalid ($[STALE]$). This cryptographic grounding provides a mathematical guarantee that no model can be trained on inconsistent or outdated data, creating a hard safety gate that is immune to AI hallucination.\n\n== Conclusion\n\nThe ARGUS safety model provides a mathematically rigorous framework for embedding AI within high-stakes medical research environments. By grounding the conversational interface in a deterministic host virtual machine, we transform the AI from a decision-making authority into a high-fidelity mediator. This architecture ensures that scientific integrity is maintained through physical evidence and cryptographic proofs, rather than trusting the transient memory of a probabilistic model.\n\n---\n_Last updated: 2026-02-17 (v10.0.0)_",
    "agentic.adoc": "= ARGUS and Agentic Design Patterns\n:author: ATLAS Project Team\n:revdate: 2026-02-11\n:toc:\n:sectnums:\n\n== Introduction\n\nThe word \"agentic\" has become overloaded. In its broadest sense it describes any system where an AI model takes actions in the world rather than merely generating text. In practice, the term covers architectures as different as autonomous coding agents, chatbot sidebars, and tool-calling orchestration frameworks. ARGUS sits in this landscape but does not fit neatly into any existing category.\n\nThis document compares and contrasts the ARGUS design with established agentic patterns. The goal is not to claim superiority over other approaches — many solve different problems well — but to make explicit where ARGUS diverges, why it diverges, and what trade-offs result.\n\n== The Agentic Landscape\n\n=== Reasoning-Action Loops (ReAct)\n\nThe ReAct pattern (Yao et al., 2022) interleaves reasoning traces with environment actions. The model thinks about what to do, takes an action, observes the result, and reasons again. This produces interpretable chains of thought tied to concrete steps.\n\nARGUS borrows the structure of this loop — CALYPSO interprets intent, dispatches an action, and reports the result — but differs in a critical way: the reasoning step does not determine what action to take in an open-ended sense. CALYPSO's routing chain uses deterministic pattern matching and intent resolution before the LLM is consulted. The LLM provides natural language interpretation, not action selection.\n\n=== Tool-Using Agents (Toolformer, Function Calling)\n\nToolformer (Schick et al., 2023) and structured function calling (OpenAI, Anthropic) give models the ability to invoke typed tools during generation. The model decides when and which tool to call, and the tool's output is folded back into the generation context.\n\nARGUS uses a similar dispatch mechanism — CALYPSO maps user intent to deterministic functions like `project_gather()`, `project_harmonize()`, and `workflow_dispatch()` — but the routing is inverted. In tool-using agents, the model selects the tool. In ARGUS, deterministic code resolves the intent first (`workflowPatterns`, `actionIntent_resolve`, `workflow_dispatch`), and the LLM is the fallback path, not the primary dispatcher. This inversion is deliberate: in a medical imaging workflow, the cost of the model selecting the wrong tool is higher than the cost of slightly less flexible intent handling.\n\n=== Autonomous Agents (Auto-GPT, SWE-agent, OpenHands)\n\nAutonomous agent systems give the AI full control of a task loop. The human provides a goal, and the agent plans, executes, and iterates until the goal is met or the budget is exhausted. SWE-agent (2024) and OpenHands apply this pattern to software engineering with terminal and file access.\n\nARGUS explicitly rejects this model. The human remains in the interaction loop at every stage. CALYPSO guides, warns, and dispatches, but the user decides when to proceed, when to skip a stage, and when to override a recommendation. The soft enforcement model (warn → warn-with-reason → allow) encodes this philosophy: the system educates rather than blocks, and never takes irreversible action without the user's participation.\n\n=== Orchestration Frameworks (LangGraph, CrewAI)\n\nOrchestration frameworks provide infrastructure for building multi-step, multi-agent workflows. LangGraph models workflows as state machines with conditional edges. CrewAI assigns roles to multiple agents that collaborate on a shared task.\n\nARGUS shares the state machine structure — the `WorkflowEngine` manages a DAG of stages with dependencies, validation conditions, and transition rules — but does not use multiple collaborating agents. There is one AI layer (CALYPSO) and one user. The complexity is in the workflow, not in agent coordination. This keeps the trust model simple: the user trusts one system, and that system's claims are verifiable against materialized artifacts.\n\n=== Model Context Protocol (MCP)\n\nMCP standardizes how models access external tools and context sources through a uniform protocol. It addresses the integration problem: how to connect models to arbitrary services without bespoke plumbing for each.\n\nARGUS does not currently use MCP, but its architecture is compatible with it. The VFS layer and store already provide structured context that `workflowContext_forLLM()` assembles for the model. Exposing these as MCP resources would be a natural extension, making CALYPSO's grounding context available to external models and tools.\n\n=== Intent-Action Services (ChRIS Intent-Server)\n\nThe Intent-Action Service (IAS) proposal (https://github.com/FNNDSC/intent-server[FNNDSC/intent-server]) addresses a structural problem in the ChRIS ecosystem: CUBE exposes a declarative, HATEOAS-compliant hypermedia API, but clients need procedural workflows that orchestrate multiple resource operations into coherent sequences. Rather than polluting CUBE with procedural logic, the IAS sits as an external service that accepts high-level intents, resolves them into concrete action sequences, dispatches those actions against CUBE, and manages credentials through authCore.\n\nThis is the closest formal ancestor to what CALYPSO does inside ARGUS. The IAS proposal articulates the separation clearly: the declarative API stays pure, the procedural orchestration lives in a distinct layer, and clients speak in intent rather than in raw API calls. ARGUS inherits this separation in spirit — CALYPSO is an intent-action layer that sits between the user and the deterministic execution substrate (VFS, workflow engine, store) — but instantiates it differently. Where the IAS is proposed as a network service mediating between HTTP clients and CUBE's REST API, CALYPSO is embedded in the application itself, mediating between natural language and local deterministic functions. The architectural principle is identical: intents in, actions out, with the orchestration logic isolated from both the user-facing surface and the state substrate.\n\nThe IAS proposal also identifies a key insight that ARGUS validates empirically: intent-level APIs are naturally agentic-ready. When the interface contract is \"describe what you want\" rather than \"compose the exact API calls,\" an LLM can participate in the resolution chain without requiring bespoke integration for every operation. CALYPSO's routing chain — from NL input through deterministic pattern matching to LLM fallback — is a concrete implementation of that principle.\n\n=== AI-as-Sidebar (Copilot Chat, Notion AI, Slack AI)\n\nThe most common production pattern places the AI in a chat panel alongside the real interface. The AI can answer questions, summarize content, and sometimes trigger actions, but it does not own the interaction flow. The user's primary surface is the traditional UI.\n\nThis is the pattern ARGUS most directly challenges. In ARGUS, the terminal and conversational layer _is_ the primary surface. The AI does not hover at the edge of a traditional interface; it mediates all workflow interaction. This is possible because the AI layer routes to deterministic execution rather than generating open-ended actions — the risk profile that makes sidebar placement attractive (constraining the AI's blast radius) is addressed through architectural grounding instead.\n\n== Where ARGUS Diverges\n\nThe patterns above each solve parts of the agentic interaction problem. ARGUS's contribution is a specific combination that, as far as we can determine, no existing system enforces together:\n\n=== AI as Primary Interaction Surface\n\nThe conversational layer is not supplementary. Users interact with ARGUS primarily through CALYPSO, whether in the browser terminal or the headless CLI. The graphical elements (LCARS panels, workflow tracker, file browser) are visualization and state display; the terminal is where work happens.\n\nThis is different from both the sidebar model (where AI is secondary) and the autonomous model (where humans are secondary). ARGUS treats the AI-mediated terminal as the primary control surface while keeping the human firmly in the decision loop.\n\n=== Intent Interpretation, Not Action Selection\n\nCALYPSO interprets what the user wants and maps it to a known operation. It does not select from an open-ended action space. The routing chain is:\n\n1. Shell command parsing (exact match)\n2. Workflow dispatch (known workflow commands)\n3. Workflow pattern matching (interrogative forms)\n4. NL action intent resolution (imperative forms stripped to keywords)\n5. LLM fallback (open-ended queries, explanations, guidance)\n\nSteps 1–4 are deterministic. The LLM in step 5 provides guidance and explanation but does not execute state-changing operations directly. When the LLM detects an action intent (e.g., `[ACTION: HARMONIZE]`), it signals back to deterministic code that performs the actual execution.\n\nThis routing chain is a concrete instantiation of the Intent-Action Service pattern proposed for ChRIS (see <<Intent-Action Services (ChRIS Intent-Server)>>). The IAS formalizes the principle that clients should speak in intent and a distinct orchestration layer should resolve those intents into action sequences. CALYPSO applies that principle at the UI layer: the user speaks in natural language, the routing chain resolves intent deterministically where possible, and the LLM participates only when deterministic resolution is insufficient. The separation between intent acceptance and action execution is the same architectural move, whether the intent arrives as a structured API call or a conversational utterance.\n\n=== Data-State Grounded Truth\n\nThis is the deepest divergence. In most agentic systems, the model asserts what has happened: \"I've completed the task,\" \"the file has been created,\" \"training is done.\" The user trusts (or doesn't trust) these assertions.\n\nIn ARGUS, progress is proven by materialized artifacts. A cohort is gathered when `.cohort` exists in VFS. Data is harmonized when `.harmonized` exists. Training is complete when `train.py` is present and `.local_pass` confirms validation. Federation is done when `.federated` appears. The `WorkflowEngine` evaluates these conditions fresh on every query — it never caches or asserts completion from memory.\n\nThis model is inherited from ChRIS, where filesystem state _is_ computation state. It eliminates the class of bug where the AI's context drifts from reality in long-running workflows.\n\n=== Shared Core Across Surfaces\n\nThe same `CalypsoCore` instance runs in the browser and in the headless CLI server. There is no \"web version\" and \"CLI version\" with separate logic. This means:\n\n- Behavior is identical regardless of surface\n- Tests written against one surface validate both\n- ORACLE integration tests exercise the same code path that users interact with\n\nThis architectural decision makes the agentic layer testable in a way that surface-specific implementations are not.\n\n=== Soft Enforcement Over Hard Gates\n\nARGUS uses educational warnings rather than hard blocks when users try to skip workflow stages. The first attempt produces a short warning. The second adds a detailed reason. The third allows the skip. This encodes a specific philosophy: the system should teach the workflow rather than enforce it rigidly, and expert users who understand the consequences should not be blocked.\n\nThis contrasts with both permissive systems (where the AI will do whatever the user asks) and restrictive systems (where unauthorized actions are refused outright).\n\n== The Three-Layer Grounding Model\n\nPure agentic systems suffer from context drift: the model's internal state diverges from reality over long interactions, leading to confabulation, stale recommendations, and whack-a-mole bug regressions. ARGUS addresses this with three layers of grounding:\n\n=== Layer 1: Deterministic Routing\n\n`workflowPatterns[]` and `actionIntent_resolve()` intercept workflow-relevant queries before they reach the LLM. Pattern-matched requests execute deterministically. The LLM never sees them and cannot misinterpret them.\n\n=== Layer 2: Context Injection\n\n`workflowContext_forLLM()` builds the LLM's context from live VFS queries at call time. The model receives ground truth about current workflow state — which stages are complete, what the next stage is, what artifacts exist — rather than relying on its memory of previous turns.\n\n=== Layer 3: Stage Directives\n\nHard-coded rules in the system prompt prevent the LLM from advising users to skip required steps or from asserting that steps are complete when the corresponding artifacts do not exist. These directives act as guardrails even when the LLM's own reasoning might lead to incorrect guidance.\n\nThe three layers are defense-in-depth. Layer 1 prevents most workflow queries from reaching the LLM. Layer 2 ensures the LLM has accurate context when it is consulted. Layer 3 constrains the LLM's output even if its reasoning is flawed.\n\n== What ARGUS Is Not\n\nExplicit anti-patterns help clarify boundaries:\n\n**Not autonomous.** ARGUS does not take actions without user participation. CALYPSO guides and dispatches, but the user decides. There is no background agent loop running unsupervised.\n\n**Not a chatbot wrapper.** The AI is not bolted onto an existing interface as an afterthought. The terminal and conversational layer is the primary interaction surface, architecturally integrated with the workflow engine, VFS, and state management.\n\n**Not framework-agnostic.** ARGUS is purpose-built for federated medical imaging workflows on the ATLAS platform. The SeaGaP-MP stage model, the specific VFS artifacts, and the workflow definitions are domain-specific. The _patterns_ may generalize, but the implementation does not pretend to be a general-purpose agentic framework.\n\n**Not a finished product.** ARGUS is a thought experiment made concrete — a live design and architectural blueprint. It is meant to be used and studied, not deployed as production infrastructure in its current form.\n\n== Open Questions\n\nHonest architecture documentation acknowledges what remains unresolved:\n\n**Multi-user concurrency.** The current model assumes a single user interacting with a single CALYPSO instance. How the data-state grounding model extends to concurrent users modifying shared workflow state is an open design problem.\n\n**Generalization beyond medical imaging.** The data-state approach works well for workflows with clear artifact boundaries (files, markers, trained models). Whether it generalizes to domains with less tangible state transitions — collaborative document editing, interactive data exploration, creative workflows — is untested.\n\n**Deterministic dispatch vs. flexible intent.** The routing chain prioritizes determinism over flexibility. As the set of supported operations grows, maintaining the pattern-matching layers becomes increasingly complex. At some point, the balance between deterministic safety and model-driven flexibility will need to be revisited.\n\n**LLM model dependency.** CALYPSO's guidance quality depends on the underlying model's capabilities. The grounding layers mitigate hallucination risk, but they do not eliminate the dependency on model quality for explanation, context synthesis, and conversational flow.\n\n**Offline and degraded-mode operation.** If the LLM backend is unavailable, CALYPSO's deterministic layers (shell commands, workflow dispatch, intent resolution) continue to work, but guidance and explanation degrade. The current architecture does not have a formal degraded-mode specification.\n\n== Further Reading\n\nFor the mathematical proof that agentic orchestration carries irreducible hallucination risk and why ARGUS's architecture is the necessary consequence, see `docs/agentic-safety.adoc`.",
    "architecture.adoc": "= ARGUS System Architecture: A Formal Specification for State-Grounded Orchestration\n:author: ARGUS Collaborative Development\n:revdate: 2026-02-21\n:revnumber: 10.3.1\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe ARGUS (Advanced Resource Guided User System) architecture is a specialized, high-integrity execution environment designed to facilitate complex federated imaging workflows. ARGUS mediates between the inherent ambiguity of natural language intent and the absolute deterministic requirements of scientific data processing. To achieve this, the system implements a \"State-First\" architecture, wherein every cognitive operation is strictly decoupled from its physical execution. This specification details the v10.2 architecture, which defines the system as a Streaming Unified Kernel (SUK) providing a standardized substrate for Guest Logic (Plugins). By grounding all workflow transitions in Merkle-proven artifact materialization and projecting live execution telemetry across a unified WebSocket protocol, ARGUS effectively resolves the \"Irreducible Hallucination\" problem found in probabilistic agentic systems.\n\n== Introduction: Concept and Context\n\nThe ARGUS architecture emerges from a fundamental critique of the modern autonomous agent paradigm. In traditional agentic systems—such as AutoGPT or SWE-agent—the AI model is given direct agency over system calls, operating in an open-ended loop where it plans, executes, and observes. While this model is effective for low-stakes general-purpose assistance, it is mathematically brittle for scientific research. In an ungrounded loop, the cumulative probability of failure increases exponentially with every step ($P_{total} = P_{step}^n$), leading to \"Instructional Decay\" where the agent eventually loses track of the physical state of the environment. In medical imaging, where provenance and reproducibility are non-negotiable, a probabilistic approach to workflow management is functionally identical to a system failure.\n\nTo address these risks, ARGUS is positioned as a **State-Grounded Orchestrator**, a category of system that utilizes AI as a linguistic interface (a \"Compiler\") but relies on a deterministic kernel (the \"Operating System\") for all state mutations. Unlike \"AI-as-a-Sidebar\" implementations found in generic IDEs or chat platforms, where the AI is a supplementary tool, ARGUS treats the conversational terminal as the primary control surface. However, this surface is backed by a Virtual Computer System (VCS) that enforces POSIX-compliant rules and Merkle-proven state verification. This ensures that the AI cannot \"hallucinate\" progress; it can only report on the physical materialization of artifacts within the filesystem.\n\nThe core differentiator of the ARGUS model is the **Intent-Action-State (IAS)** separation. In this framework, the AI is restricted to the \"Intent\" phase, translating noisy human language into a strictly-typed protocol. The \"Action\" phase is owned by unprivileged Guest plugins, and the \"State\" phase is managed by the high-integrity Host kernel. By isolating the probabilistic \"Intelligence\" of the AI from the deterministic \"Integrity\" of the execution substrate, ARGUS provides a high-fidelity environment where researchers can drive complex multi-site protocols through natural language without compromising the scientific truth of the results.\n\nThis architecture is critically needed in federated environments where researchers must coordinate data-intensive tasks across distributed sites. Traditional UIs for these tasks are often rigid and complex, while raw CLI interfaces are opaque to non-technical users. ARGUS bridges this gap by providing a \"Human-Friendly but Machine-Strict\" environment. It provides the fluid user experience of a conversational agent with the rigorous auditability of a blockchain-anchored ledger. By grounding every interaction in a topological session tree, ARGUS transforms the \"Hallucinating Agent\" into a high-fidelity instrument of scientific discovery, ensuring that every decision is backed by cryptographically-anchored evidence.\n\n== The Streaming Unified Kernel (SUK) Architecture\n\nThe following figure illustrates the relationship between the user, the distributed computation hub (Calypso Server), and the specialized observation surfaces (TUI and WUI), highlighting the bidirectional flow of the SUK protocol and the final rendering update path.\n\n[source,text]\n----\n                                  [ USER ]\n                                     │\n             ┌───────────────────────┴───────────────────────┐\n             │                                               │\n             ▼ (CLI / SSH)                                   ▼ (Browser / HTTP)\n    ┌───────────────────────────┐               ┌───────────────────────────┐\n    │       TUI TERMINAL        │               │       WEB TERMINAL        │\n    │  ┌─────────────────────┐  │               │  ┌─────────────────────┐  │\n    │  │ [ ASCII RENDERER ]  │◀─┼──────┐ ┌──────┼─▶│ [ DOM/CSS ENGINE ]  │  │\n    │  └─────────────────────┘  │      │ │      │  └─────────────────────┘  │\n    │             │             │      │ │      │             │             │\n    │      (Dumb Client)        │      │ │      │    (Intelligent Surface)  │\n    └──────┬──────┴─────────────┘      │ │      └──────┬──────┴─────────────┘\n           │      ▲                    │ │             │      ▲\n           ▼      │            [ UI WEBSOCKET PIPE ]   ▼      │\n           │      │         (Commands ▼ | Telemetry ▲) │      │\n           └──────┼───────────────────┬─┴─┬────────────┘      │\n                  └───────────────────┼───┼───────────────────┘\n                                      │   │\n    ┌─────────────────────────────────┴───┴─────────────────────────────────┐\n    │ CALYPSO SERVER (The System CNS / WebSocket Orchestrator)              │\n    │                                                                       │\n    │  ┌─────────────────────────────────────────────────────────────────┐  │\n    │  │ CALYPSO HOST (The System Kernel)                                │  │\n    │  │                                                                 │  │\n    │  │  ┌───────────────────────────────────────────────────────────┐  │  │\n    │  │  │ PLUGIN VM (The Guest Execution Sandbox)                   │  │  │\n    │  │  │  ┌─────────────────────────────────────────────────────┐  │  │  │\n    │  │  │  │ GUEST PLUGIN (Compute Logic & Narrative Source)     │  │  │  │\n    │  │  │  │                                                     │  │  │  │\n    │  │  │  │  ● Compute Loop  ──▶ [ TELEMETRY BUS ]  ────────────┼──┼──┐│  │\n    │  │  │  │  ● Lore Source   ──▶ (Internal Pipe)                │  │  ││  │\n    │  │  │  └────────▲────────────────────────────────────────────┘  │  ││  │\n    │  │  └───────────┼───────────────────────────────────────────────┘  ││  │\n    │  └──────────────┼──────────────────────────────────────────────────┘│  │\n    │                 │ (Commands)        │ (Telemetry Stream)            │  │\n    │          [ COMMAND ROUTER ] ◄───────┘                               │  │\n    │                 │                                                   │  │\n    └─────────────────┼───────────────────────────────────────────────────┘\n                      │\n                      ▼\n            [ FEDERATION NETWORK ]\n            (Secure Multi-Site Transport)\n----\n\nArgus v10.2 establishes the **Streaming Unified Kernel (SUK)** model, marking the final transition of ARGUS from a monolithic application into a **Distributed Orchestration System**. In this paradigm, the core logic—housed in atomic Guest plugins—is strictly isolated within a high-integrity Host (Calypso), which functions as a headless computation engine. This engine exposes its entire operational state, including live execution telemetry, through a **Unified Protocol Surface**. This ensures that the \"Truth\" of the scientific process is never trapped within a single UI component or local memory stack, but is instead a global broadcast available to any authorized observer, whether that observer is a human researcher or an automated validation suite.\n\nThe interaction is governed by a tiered **Dual-Socket Topology** that clearly separates human-centric telemetry from machine-centric data movement. The first layer, the **UI WebSocket Pipe**, handles the bidirectional flow of commands (from client to server) and live telemetry frames (from server to client). The second layer, the **Federation WebSocket**, connects the Calypso Server to the actual web—the external site-local network. These are distinct sockets with specialized security profiles: the UI pipe optimizes for low-latency streaming of \"Lore,\" while the Federation pipe manages high-integrity clinical data handshakes between distributed sites. This ensures that the internal telemetry broadcast is never throttled by heavy data transfers, maintaining a responsive user experience during complex federated jobs.\n\nWithin this system, the **Calypso Host** acts as the Hardware Abstraction Layer for the **Plugin Virtual Machine**. When a Guest plugin executes a compute loop (e.g., cohort scanning or local validation), it emits raw primitives—such as logs, progress updates, or animation requests—onto an internal **Telemetry Bus**. This bus functions as a local, high-integrity interface for the plugin (comparable to the `tqdm` pattern in Python), shielding the Guest from the technical complexities of network transport and serialization. The Host kernel intercepts these local events and serializes them into protocol-compliant frames for broadcast via the WebSocket Orchestrator. This design ensures that the plugin logic remains 100% portable and surface-agnostic; the Guest never \"talks to the web\" or the DOM directly, but simply reports its progress to the Host.\n\nThe rationale for this move is the enforcement of absolute **Visual and Logical Parity** across all ARGUS surfaces. Because both the TUI and the WUI consume the exact same telemetry stream from the server, they are guaranteed to present a synchronized view of the workflow. When a plugin signals a progress update, the TUI terminal triggers its ASCII renderer to draw a box, while the Web Terminal performs a real-time update of its DOM/CSS state to reflect the same progress. This eliminates \"Telepathic Coupling,\" a failure mode where the UI previously attempted to guess the backend's state by eavesdropping on strings. Argus v10.2 ensures that every researcher, regardless of their preferred interface, is making decisions based on the same Merkle-proven evidence, grounded in the real-time state of the virtual machine.\n\nIn current CLI rendering, progress updates are stateful and in-place. Each stream\nrewrites a single active progress row (glyph bar format) instead of printing a new\nline for every increment. This keeps long loops readable and prevents terminal-log\nexplosion while preserving full telemetry fidelity.\n\n== The Interpretation-First Pipeline: The Logic of Intent\n\nThe following figure illustrates the sequence of natural language resolution into deterministic execution.\n\n[source,text]\n----\n┌─────────┐   ┌─────────────┐   ┌──────────────┐   ┌────────────┐   ┌────────────┐\n│ Surface │──▶│ CalypsoHost │──▶│ IntentParser │──▶│ Workflow   │──▶│ PluginHost │\n└─────────┘   └─────────────┘   └──────────────┘   │ Adapter    │   └────────────┘\n                                                   └────────────┘          │\n                                                          │                │\n                                                          ▼                ▼\n                                                    ┌──────────┐      ┌────────────┐\n                                                    │ Gatekeep │─────▶│ Plugin     │\n                                                    └──────────┘      │ (execute)  │\n                                                                      └────────────┘\n                                                                              │\n                                                                              ▼\n                                                                       ┌───────────────┐\n                                                                       │ MerkleEngine  │\n                                                                       └───────┬───────┘\n                                                                               │\n                                                                               ▼\n                                                                       ┌───────────────┐\n                                                                       │ VFS Session   │\n                                                                       │ Tree Artifact │\n                                                                       └───────────────┘\n----\n\nThe ARGUS pipeline treats natural language as a noisy input source that must be compiled into a deterministic protocol before execution. This \"Interpretation-First\" strategy ensures that the probabilistic nature of LLMs is never allowed to leak into the system's state-management layer. The sequence begins at the Surface Adapter, where user utterances are captured and forwarded to the Calypso Host. This approach acknowledges that while human communication is fluid and conversational, scientific computation must remain absolute and verifiable.\n\nOnce an intent is received, the `IntentParser` performs a two-pass resolution. First, it checks for exact matches against workflow verbs derived from the active manifest command set. If no deterministic match is found, the LLM is invoked as a semantic compiler, tasked with mapping the user's natural language to a strictly-typed JSON protocol constrained to those same active workflow commands. This process isolates the \"Intelligence\" of the AI to the translation layer only, ensuring that the AI has no direct power to mutate system state without a corresponding protocol definition.\n\nFollowing successful compilation, the resolved protocol is subjected to a rigorous Gatekeeping phase by the `WorkflowAdapter`. The system performs a topological walk of the active manifest to verify that all prerequisites for the target stage have been materialized in the session tree. If a parent artifact is missing or stale, the execution is blocked, preventing the agent from proceeding based on invalid premises. This gatekeeping is the primary mechanism for preventing \"Instructional Decay\" during complex multi-step protocols.\n\nThe final stage is the dispatch to the `PluginHost`, which executes the logic and returns a result payload. This payload is then cryptographically anchored by the `MerkleEngine` and materialized as a physical artifact in the VFS. This closed-loop design ensures that \"Truth\" is measured in files on disk, not words in a chat window, providing the absolute integrity required for scientific workflows. By the time the result returns to the user, it is no longer an assertion but a materialized fact, proven by the presence of a Merkle-hashed artifact in the session tree.\n\n== The SeaGaP State Machine\n\nThe following figure illustrates the procedural spine of the ARGUS research lifecycle.\n\n[source,text]\n----\n┌────────┐     ┌────────┐     ┌─────────┐     ┌─────────┐     ┌──────┐\n│ SEARCH │────▶│ GATHER │────▶│ PROCESS │────▶│ MONITOR │────▶│ POST │\n└────────┘     └────────┘     └─────────┘     └─────────┘     └──────┘\n     │              │              │               │              │\n     └──────────────┴──────────────┴───────────────┴──────────────┘\n----\n\nThe SeaGaP-MP framework defines the foundational structural spine of the ARGUS system, imposing a strict temporal order on the research process. It was designed to manage the inherent complexity of distributed imaging by organizing diverse tasks into a coherent, repeatable sequence of Search, Gather, Process, Monitor, and Post. Without this standard lifecycle, research goals remain ill-defined, making it impossible to coordinate complex operations across multiple sites. The framework provides a common procedural language that bridges the gap between diverse research personas.\n\nEach stage in the SeaGaP sequence functions as a logical gate that must be satisfied before the next can commence. The **Search** stage focuses on discovery, while the **Gather** stage commits selected datasets into a project workspace. This distinction is critical for provenance; search records the criteria used to find data, while gather records the explicit intent to include that data in a specific scientific study. By separating discovery from commitment, ARGUS ensures that the provenance of the final model can be traced back to the initial search parameters.\n\nThe **Process** stage is where domain-specific compute occurs, governed by the Plugin VM and the DAG engine. Transitions between these high-level phases are monitored by the `WorkflowAdapter`, which enforces the \"State-First\" mandate. If a user attempts to skip a required stage, the system issues educational warnings, requiring explicit confirmation before allowing the workflow to deviate from the standard protocol. This \"Soft Enforcement\" model acknowledges the expertise of the human researcher while ensuring that deviations are intentional and documented.\n\nUltimately, the SeaGaP state machine ensures that progress is a matter of evidence rather than opinion. By grounding each stage in the materialization of physical VFS artifacts, ARGUS provides a transparent and auditable trail of the scientific process. This framework ensures that every result—from initial search to final model publication—is backed by a verifiable chain of custody, ensuring compliance with clinical research standards. The state machine serves as the \"Guardian of Process,\" preventing the accidental omission of critical steps in the research lifecycle.\n\n== Plugin Isolation and Boundaries\n\nThe following figure illustrates the sandboxed environment provided to Guest logic.\n\n[source,text]\n----\n                  allowed via PluginContext\n         ┌──────────────────────────────────────┐\n         │ vfs │ shell │ store │ ui telemetry   │\n         └──────────────────┬───────────────────┘\n                            │\n                            ▼\n                     ┌─────────────┐\n                     │ Plugin Code │\n                     └─────────────┘\n                            │\n        ┌───────────────────┴───────────────────┐\n        │                                       │\n        ▼                                       ▼\n  ┌─────────────┐                        ┌───────────────┐\n  │ allowed:    │                        │ forbidden:    │\n  │ src/plugins │                        │ src/core/*    │\n  │ returns     │                        │ orchestration │\n  │ PluginResult│                        │ stage modules │\n  └─────────────┘                        └───────────────┘\n----\n\nThe ARGUS architecture enforces strict isolation of Guest logic to ensure that idiosyncratic changes to a specific workflow cannot compromise the stability of the system kernel. This is implemented through a \"Plugin VM\" model, where every plugin is a stateless transformation that executes within a restricted sandbox. Plugins are dynamically loaded on-demand, minimizing the system's memory footprint and allowing for the hot-swapping of research protocols. This design ensures that the core security and integrity mechanisms of the system are never exposed to unprivileged code.\n\nAccess to the system is mediated through the `PluginContext`, a strictly-defined \"Standard Library\" that represents the totality of a plugin's agency. Guest code is provided with project-scoped VFS access, environment management via the Shell, and restricted read/write access to the application Store. This context-based approach ensures that plugins remain modular and decoupled from the Host's internal state-management mechanisms. A plugin can mutate the project tree, but it has no power to touch the underlying system configuration or the session ledger.\n\nA fundamental rule of the ARGUS architecture is the **Plugin Boundary**, which forbids any Guest code from importing modules from the core orchestration layer. This ensures that the system's \"Intelligence\" (the plugins) and its \"Integrity\" (the host) remain non-overlapping. By preventing these dependencies, Argus ensures that runtime logic remains UI-surface agnostic, allowing the same plugin to execute identically in a web browser or a headless CLI. This isolation is strictly enforced via automated boundary checks during the build process.\n\nThe result of a plugin execution is always a `PluginResult` payload, which contains the evidence required for the Host to advance the workflow. This contract ensures that plugins do not \"mark\" stages as complete; they simply return the data that the high-integrity Kernel will then anchor into the provenance chain. This separation of \"Doing the Work\" from \"Recording the Result\" is the key to maintaining a mathematically verifiable audit trail. The Host acts as the authoritative witness to the Guest's execution, cryptographically signing the outcome before it is recorded in the session tree.\n\n== Backend Purity and Latency Boundaries\n\nARGUS v10.2.1 enforces a strict runtime boundary: backend layers (`CalypsoCore`,\n`PluginHost`, `SessionStore`, `MerkleEngine`) do not inject synthetic compute latency.\nAny realism delay belongs inside the stage plugin itself, where it can be turned off\ndeterministically with `CALYPSO_FAST=true` for testing.\n\nThe same purity rule now applies to execution watchdog behavior. Backend workflow\ndispatch no longer enforces a fixed hard timeout (legacy `10s` kill path removed).\nStage lifetime is determined by plugin completion/failure semantics, not hidden host\ntimers.\n\nThis policy keeps backend behavior production-pure and prevents \"technical simulacrum\ndebt\" in core runtime paths as Host storage evolves from in-memory VFS to real FS backends.\n\n== Merkle Provenance Topology\n\nThe following figure illustrates the physical mapping of the DAG into the project's data directory.\n\n[source,text]\n----\n/projects/fedml-study-01/data/\n│\n├── search/\n│   ├── data/search.json\n│   └── meta/fingerprint.json\n│\n├── search/gather/\n│   ├── data/gather.json\n│   └── meta/fingerprint.json\n│\n├── search/gather/harmonize/\n│   ├── data/harmonize.json\n│   └── meta/fingerprint.json\n│\n└── search/gather/harmonize/code/\n    ├── data/code.json\n    └── meta/fingerprint.json\n----\n\nThe architectural \"Conscience\" of ARGUS is the project-relative Merkle provenance tree, which provides a physical ledger of the scientific process. The tree is structured as a direct mirror of the DAG manifest's topology, with each stage owning a specific directory in the project's `data/` root. This organization ensures that the provenance of every result is encoded in its filesystem path, making the lineage of any artifact immediately human-interpretable. This topological mapping transforms the abstract graph of the research protocol into a concrete physical reality on the virtual disk.\n\nEvery artifact materialized within this tree is wrapped in a Merkle envelope containing a SHA-256 fingerprint. This fingerprint is a recursive hash that incorporates both the artifact's own data and the fingerprints of its parent nodes in the DAG. This cryptographic anchoring ensures that the integrity of an artifact is inextricably linked to its entire historical context, providing a mathematical guarantee of consistency across long-running sessions. If any upstream data is tampered with, the fingerprints of all subsequent descendants will immediately fail verification.\n\nThe Merkle Engine utilizes this topological structure to perform real-time staleness detection. By comparing the parent fingerprints recorded in an artifact's metadata with the current state of the parent nodes, the system can instantly identify if upstream data has been modified. If a researcher re-runs an early stage, the system automatically flags all downstream descendants as `[STALE]`, forcing a re-verification of the scientific results. This ensures that the system's \"Ground Truth\" is always current and that no decisions are made based on outdated evidence.\n\nFurthermore, the session tree supports historical branching through timestamped re-execution paths. This ensures that while the system maintains a \"Main\" branch of current truth, previous experimental attempts are preserved for forensic audit. This combination of topological nesting and cryptographic fingerprinting transforms the filesystem into a high-integrity ledger, providing the absolute provenance required for regulated research. The session tree is not just a storage location; it is the immutable record of the entire scientific journey performed within the ARGUS environment.\n\n== Conclusion\n\nThe ARGUS v10.2 architecture represents a fundamental departure from conversational AI interfaces. By refactoring the system into a high-integrity Streaming Unified Kernel and a deterministic Plugin Virtual Machine, ARGUS effectively grounds the probabilistic \"Intelligence\" of the LLM in the \"Ground Truth\" of a persistent filesystem and a live telemetry ledger. The resulting system is not merely an assistant, but a robust Operating System for federated medical research. The architecture's commitment to state-first verification ensures that every scientific result produced by ARGUS is backed by a verifiable chain of evidence, providing the trust and security required for high-stakes scientific investigation.\n\n---\n_Last updated: 2026-02-21 (v10.3.1)_",
    "calypso.adoc": "= CALYPSO: Intelligence Kernel and Dispatch Integrity\n:author: ATLAS Project Team\n:revnumber: 10.3.1\n:revdate: 2026-02-21\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nCALYPSO is the execution kernel that mediates between human language and\ndeterministic workflow mutation in ARGUS. The kernel does not own domain compute.\nIt owns interpretation constraints, topological validation, plugin dispatch, and\nartifact anchoring through Merkle materialization. This separation is the\nmechanism that prevents conversational fluency from masquerading as scientific\ncompletion.\n\nThe current version reflects post-hardening policy: backend layers remain\nproduction-pure, federation behavior is plugin materialized, and workflow commands\nare constrained to manifest-derived vocabulary.\n\n== Historical Context\n\nEarlier generations treated Calypso as a general assistant that both interpreted\nintent and made action decisions. That model failed under multi-step protocols\nbecause language confidence could drift away from state evidence. The v10 refactor\nconverted Calypso into a host kernel, and the 10.2 to 10.3 line hardened that\nconversion by deleting residual internalized behavior.\n\nThe core lesson was structural: if intent compilation, execution permission, and\nstate materialization are not separated, provenance cannot be trusted in long\nrunning scientific flows.\n\n== Kernel Flow\n\n[source,text]\n----\n                            ┌──────────────────────────┐\n                            │        USER INPUT        │\n                            └────────────┬─────────────┘\n                                         │\n                                         ▼\n                            ┌──────────────────────────┐\n                            │       CALYPSO CORE       │\n                            └────────────┬─────────────┘\n                                         │\n                  ┌──────────────────────┴──────────────────────┐\n                  │                                             │\n                  ▼                                             ▼\n       ┌──────────────────────────┐                ┌──────────────────────────┐\n       │ FAST-PATH DISPATCH       │                │ INTENT COMPILATION       │\n       │ (/cmd + shell builtins)  │                │ (deterministic + model)  │\n       └────────────┬─────────────┘                └────────────┬─────────────┘\n                    │                                           │\n                    └──────────────────────┬────────────────────┘\n                                           │\n                                           ▼\n                            ┌──────────────────────────┐\n                            │ WORKFLOW GATEKEEPER      │\n                            │ topology + policy checks │\n                            └────────────┬─────────────┘\n                                         │\n                                         ▼\n                            ┌──────────────────────────┐\n                            │ PLUGINHOST DISPATCH      │\n                            └────────────┬─────────────┘\n                                         │\n                                         ▼\n                            ┌──────────────────────────┐\n                            │ MERKLE MATERIALIZER      │\n                            └────────────┬─────────────┘\n                                         │\n                                         ▼\n                            ┌──────────────────────────┐\n                            │ PROTOCOL RESPONSE        │\n                            │ status + actions + msg   │\n                            └──────────────────────────┘\n----\n\nThe fast path handles explicit kernel verbs and shell operations without involving\nlanguage synthesis. Non-fast-path input is compiled into typed intent. If\ndeterministic resolution is unavailable, model synthesis remains constrained by the\nactive manifest command set. Execution permission is decided only after topology\nchecks. Completion claims become valid only when artifact evidence is written.\n\nIf no model provider is available, conversational fallbacks are reported as offline\nwithout backend simulation surrogates. Deterministic workflow and shell paths remain\noperational.\n\n== Response Contract\n\nCalypso communicates through a categorical status protocol rather than boolean\nsuccess signaling.\n\n[cols=\"1,3\",options=\"header\"]\n|===\n|Code |Meaning\n|`OK` |Intent valid, prerequisites satisfied, and plugin execution anchored.\n|`BLOCKED` |Intent recognized but blocked by workflow policy.\n|`BLOCKED_MISSING` |Required parent evidence absent.\n|`BLOCKED_STALE` |Parent lineage changed and descendant evidence is stale.\n|`CONVERSATIONAL` |Input handled as non-mutating guidance.\n|===\n\nThis contract allows adapters and verification runners to assert behavior\nindependently of narrative phrasing.\n\n== Integrity Boundary\n\nPlugins produce domain output; Calypso witnesses and records completion. The host\ntherefore owns Merkle anchoring and session-tree writes, while plugin code remains\nunprivileged compute. This prevents guest logic from self-certifying completion and\npreserves one authoritative provenance path.\n\nLatency policy follows the same boundary. Backend components do not inject\nsynthetic compute sleep. Optional realism delay is plugin-local and can be\ndisabled for oracle throughput with `CALYPSO_FAST=true`.\n\nExecution policy now follows the same doctrine: host runtime no longer applies a\nfixed-duration plugin kill watchdog during workflow execution. A stage runs until\nplugin completion or plugin failure, and any future cancellation semantics must be\nexplicitly modeled rather than encoded as hidden time limits inside kernel dispatch.\n\n== Telemetry Rendering Contract\n\nTelemetry event ownership is split by layer:\n\n1. Plugins emit primitive events (`log`, `progress`, `phase_start`, `frame_open`,\n   `frame_close`, `status`).\n2. Host/server transport events without reinterpreting narrative content.\n3. Surface adapters own rendering geometry.\n\nFor the CLI/TUI adapter, progress semantics are now stateful by design: one active\nprogress row is rewritten in place instead of appending one line per event. This\nprevents the historical \"progress triangle\" artifact during long compute loops.\nProgress bars render with glyph blocks (`█` and `░`) for fast visual scanning in\ndense terminal sessions.\n\n== Architectural Outcome\n\nCalypso now operates as a deterministic integrity kernel with constrained language\ncompilation at the boundary and artifact proof at the core. This keeps interaction\nnatural for operators while maintaining strict scientific state semantics for every\nmutation-bearing step in the workflow lifecycle.\n\n---\n_Last updated: 2026-02-21 (v10.3.1)_",
    "dag-engine.adoc": "= Manifest-Driven DAG Engine: Topology as Execution Truth\n:author: ATLAS Project Team\n:revdate: 2026-02-20\n:revnumber: 10.3.0\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe DAG engine is the workflow conscience of ARGUS. It transforms declarative\nmanifest topology into deterministic execution constraints and resolves current\nposition from materialized evidence rather than conversational state. In this\nmodel, progression is granted only when prerequisite artifacts exist and lineage\nintegrity remains valid under Merkle parentage.\n\nThis specification reflects the post-hardening state in which optional-parent JOIN\nresolution is materialized as data evidence and command vocabulary is bound to\nactive manifest declarations.\n\n== Historical Context\n\nEarly workflow logic used linear state progression and implicit controller rules.\nThat approach failed once workflows required branching, re-execution, and\nmulti-parent convergence. The immediate symptom was state drift, where runtime\nposition and filesystem evidence diverged. The deeper issue was representational:\ncontrol decisions were not encoded as artifacts.\n\nThe DAG transition corrected topology representation, and later hardening work\nclosed remaining semantic gaps by converting JOIN control into materialized\nresolution evidence.\n\n== Topology Figure\n\n[source,text]\n----\nMain topology with optional JOIN:\n\n┌────────────┐     ┌────────────┐\n│ SEARCH     │───▶│ GATHER     │──────────────┐\n└────────────┘     └────────────┘              │\n                                               ▼\n                                        ┌────────────┐\n                                        │ JOIN GATE  │───▶┌────────────┐───▶┌────────────┐\n                                        │ parents ok │    │ HARMONIZE  │    │ PROCEED    │\n                                        └─────┬──────┘    └────────────┘    └────────────┘\n                                              │\n                             optional path    │\n                                              ▼\n                                        ┌────────────┐\n                                        │ RENAME opt │\n                                        └────────────┘\n\nRe-execution pressure:\n\n┌────────────┐\n│ SEARCH     │ (new fingerprint)\n└─────┬──────┘\n      │\n      └──────────────▶ downstream descendants marked [STALE]\n----\n\n== Manifest as Runtime Contract\n\nWorkflows are declared in YAML manifests under `src/dag/manifests/`. Stage\ndeclarations define parentage, command vocabulary, and produced artifacts. At\nruntime, the adapter compiles manifest data into graph nodes and treats that graph\nas the only valid orchestration surface for command dispatch and position\nresolution.\n\nBecause command ownership is now manifest-derived, parser acceptance and dispatch\nrouting are constrained to active workflow verbs. This prevents backend vocabulary\ndrift from introducing persona-specific hidden behavior.\n\n== Position Resolution\n\nCurrent stage is resolved through artifact inventory and topological readiness\nevaluation. The engine inspects materialized stage evidence, verifies parent\navailability and lineage validity, and identifies the first unresolved stage in\ntopological order that is eligible for execution.\n\nThis method keeps runtime position reconstructible from filesystem state at any\ntime. No controller-local pointer can claim advancement without corresponding\nartifact evidence.\n\n== Merkle-Coupled Staleness\n\nStage artifacts are fingerprinted with parent lineage context, which means upstream\nre-materialization changes descendant validity even when descendant files still\nexist. The DAG engine therefore marks downstream stages stale when parent\nfingerprints diverge from recorded lineage. Staleness is not a user-interface\nwarning; it is a topological validity condition that blocks unsafe continuation.\n\n== JOIN Semantics: Control Materialized as Data\n\nMulti-parent stages represent convergence points where control choices must be\nresolved before execution. Prior implementations used alias-style completion\nsemantics that treated optional parents as implicitly satisfied. This removed\nexplicit evidence of the decision and created dispatch ambiguity under later\ncommands.\n\nThe corrected model treats JOIN resolution as data-state. Required parents must\nmaterialize standard evidence. Optional parents must also resolve, either through\nexecuted artifacts or explicit decline artifacts. Only after all parent statuses are\nmaterialized does execution enter the target stage.\n\nThe current runtime writes optional-decline evidence as skip artifacts in normal\nstage paths. This keeps resolver behavior uniform because completion checks consume\nthe same artifact contract regardless of whether the parent was executed or\ndeclined.\n\n[source,text]\n----\nAdvance while optional parent is unresolved:\n\n┌────────────────────────────────────┐\n│ command(\"harmonize\")               │\n└───────────────┬────────────────────┘\n                ▼\n┌────────────────────────────────────┐\n│ transition check: pending rename   │\n└───────────────┬────────────────────┘\n                ▼\n┌────────────────────────────────────┐\n│ auto-decline policy resolves true  │\n└───────────────┬────────────────────┘\n                ▼\n┌────────────────────────────────────┐\n│ materialize skip evidence: rename  │\n└───────────────┬────────────────────┘\n                ▼\n┌────────────────────────────────────┐\n│ re-sync topological position       │\n└───────────────┬────────────────────┘\n                ▼\n┌────────────────────────────────────┐\n│ dispatch harmonize                 │\n└────────────────────────────────────┘\n----\n\n== Auto-Decline and Phase Progression\n\nWhen a user advances to a downstream stage while optional parents remain unresolved,\ntransition logic evaluates whether the unresolved set is auto-declinable under\nmanifest policy. If so, decline artifacts are materialized and the resolver\nre-synchronizes position before dispatching the requested stage. Mandatory-parent\ngaps remain blocking and cannot be auto-declined.\n\nThis behavior removed recursive loop surfaces previously triggered by strict-lock\nrejection followed by conversational fallthrough, because workflow intents now\nremain inside workflow dispatch semantics even when the command targets a different\nstage than the current pointer.\n\n== Pointer Integrity and Session Realignment\n\nHardening also addressed stale-pointer behavior by ensuring fast verification paths\ndetect self-completed stages and force slow-path advancement. Session-path updates\nafter project renames are propagated through all consumers so status providers and\nresolver scans continue to inspect the active lineage root.\n\nThese corrections preserve a single invariant: stage position is always derived from\ncurrent artifact truth in the active session context.\n\n== Architectural Outcome\n\nThe DAG engine now expresses orchestration as a fully materialized graph contract.\nManifests declare topology and verbs, adapter logic enforces parent-state validity,\nand Merkle lineage anchors temporal consistency. JOIN decisions are no longer\ncontroller folklore. They are filesystem evidence subject to the same verification\ndiscipline as compute outputs.\n\n---\n_Last updated: 2026-02-20 (v10.3.0)_",
    "devexperience.adoc": "= The ARGUS Developer Experience: Physical Provenance as Daily Practice\n:author: ATLAS Project Team\n:revdate: 2026-02-20\n:revnumber: 1.1.0\n:toc: macro\n:icons: font\n\ntoc::[]\n\n== Abstract\n\nThis document specifies the developer-experience contract used by ARGUS after the\nv10 hardening line. The contract resolves a long-standing tension in scientific\nsoftware between mutable engineering workspaces and immutable provenance\nrequirements. Conventional platforms usually force a binary choice: either strict,\nplatform-managed pipelines with limited intervention, or unconstrained shell work\nwith weak lineage guarantees. ARGUS rejects that tradeoff and encodes both demands\ninside one filesystem-native model.\n\nThe result is a two-zone operating structure in which active development remains\nfast and local while every computational milestone remains materially preserved as a\nMerkle-addressable path lineage under `data/`. This specification explains why that\nmodel was necessary, how copy-on-write refinement preserves history without blocking\nmanual intervention, and how the resulting directory graph functions as executable\nproof rather than passive storage.\n\n== Introduction: Historical Context and Pressure\n\nEarlier iterations of the stack treated developer convenience and scientific\nintegrity as neighboring concerns rather than a single design problem. During\nhigh-velocity workflow execution this separation failed in predictable ways. Manual\nedits to generated artifacts improved practical progress but blurred lineage,\nbecause ad hoc edits could overwrite machine outputs in place. At the same time,\nfully locking generated paths prevented real-world adaptation and pushed developers\noutside the platform, where provenance disappeared entirely.\n\nThe hardening-era objective was therefore not interface polish but structural\nunification. The filesystem itself had to become the shared language between human\nintervention and machine execution. Once that requirement was accepted, the project\nmodel converged on a simple but strict doctrine: mutable work occurs in a workshop\nzone, immutable history accumulates in a vault zone, and transitions between the\ntwo are mediated by deterministic copy-on-write semantics.\n\n== The Two-Zone Filesystem Contract\n\nARGUS projects encode this contract directly in path layout.\n\n[source,text]\n----\n/home/user/projects/my-model/\n|-- src/                         <-- workshop code and scripts\n|-- input                        <-- active portal to current data context\n`-- data/                        <-- immutable provenance graph\n    `-- search/\n        |-- data/search.json\n        `-- gather/\n            |-- data/gather.json\n            `-- harmonize/\n                |-- data/harmonize.json\n                `-- refine_human/\n                    `-- Dockerfile\n----\n\nThe `src/` and `input` surfaces provide the mutable room where developers inspect\nartifacts, iterate on implementations, and run local tooling without ceremony. The\n`data/` tree is the immutable room in which each directory boundary records a\ncausal execution step with its own control metadata and payload artifacts. This\npartition is not metaphorical decoration. It is the core mechanism that lets ARGUS\nbehave like both an engineering workstation and a scientific instrument.\n\n== Copy-on-Write Refinement Through `input/`\n\nThe `input/` symlink is the operational boundary object between mutable and\nimmutable zones. It always resolves to the active leaf context that downstream\ncommands should consume. If a user opens a generated file through `input/` and\nsaves a modification, ARGUS does not reject the write and does not mutate the\nsealed source node. Instead, the runtime performs deterministic copy-on-write\nrefinement by materializing a sibling refinement node, cloning prior contents,\nrepointing `input/` to the new node, and committing the new bytes there.\n\nThis sequence preserves two properties that were historically in conflict. Human\nintervention remains immediate and tool-compatible because editors can write through\nnormal filesystem operations. Provenance integrity remains intact because machine\ngenerated output is never rewritten in place. The intervention itself becomes a\nfirst-class lineage event that can be audited, reproduced, and reasoned about\nlater.\n\n== Path-as-Proof Semantics\n\nIn ARGUS, lineage is encoded in physical path structure rather than external\ndatabase joins. A path such as `data/search/gather/harmonize/` states directly that\n`harmonize` consumed artifacts produced by `gather`, which in turn consumed\nartifacts from `search`. A convergent path such as\n`data/.../rename/_join_gather_rename/harmonize/` states multi-parent consumption in\nthe same way. The path graph is therefore not only storage topology; it is the\nexecutable causal record.\n\nThis model removes a significant class of synchronization failures where metadata\nclaims diverge from payload reality. Because control envelopes and data artifacts\nco-reside at each node, any project archive contains code, outputs, and the proof\nstructure that explains how those outputs came to exist.\n\n== Architectural Outcome\n\nThe developer experience contract now aligns directly with the v10 hardening\nmission. Mutable workflows remain practical for daily engineering, while scientific\nhistory remains cryptographically and structurally inspectable without hidden\nside-channels. The legacy session-tree distinction is no longer needed as a\nseparate conceptual store; operational memory is reconstructed from the active\nproject graph itself.\n\nThis outcome closes a core integrity gap before v11 contract lock. ARGUS no longer\nasks operators to choose between speed and proof. It encodes both as native\nfilesystem behavior under one deterministic runtime model.",
    "federation.adoc": "= Federation Workflow: Plugin-Materialized Phase Execution\n:author: ATLAS Project Team\n:revdate: 2026-02-20\n:revnumber: 10.3.0\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThis document specifies federation behavior after the backend purification passes\nin the late v10 line. Federation is no longer represented by a backend\norchestrator, hidden handshake controller, or dedicated in-memory federation state.\nIt is represented by manifest topology plus stage-local plugin compute, with\nprogress derived from artifacts and DAG position resolution.\n\nThe practical consequence is a stronger Host/Guest contract. Federation sequencing\nremains explicit and auditable, while backend layers remain workflow-agnostic and\nready for storage substrate changes.\n\n== Historical Catalyst\n\nEarlier implementations retained internalized federation coordination in runtime\ncode. That transitional design was useful during migration, but it violated the\ndeclared v10 architecture because orchestration semantics existed in two places:\npartly in manifests/plugins and partly in backend logic. The duplication created\ndrift risk and made it difficult to claim that plugin boundaries were fully real.\n\nThe hardening objective was to remove this duality before v11 contract lock. If a\nfederation phase existed, it needed to exist as a plugin module selected by a\nmanifest handler, not as a backend branch.\n\n== Federation Spine Figure\n\n[source,text]\n----\n┌──────────────────────────┐\n│ FEDERATE BRIEF           │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ FEDERATE TRANSCOMPILE    │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ FEDERATE CONTAINERIZE    │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ FEDERATE PUBLISH CONFIG  │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ FEDERATE PUBLISH EXEC    │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ FEDERATE DISPATCH        │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ FEDERATE EXECUTE         │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ FEDERATE MODEL PUBLISH   │\n└──────────────────────────┘\n----\n\n== Stage Pipeline as Declared Compute\n\nThe active FedML lineage now materializes federation as eight stage handlers:\n`federate-brief`, `federate-transcompile`, `federate-containerize`,\n`federate-publish-config`, `federate-publish-execute`, `federate-dispatch`,\n`federate-execute`, and `federate-model-publish`. Each stage is implemented as a\nsingle plugin file in `src/plugins/` and loaded through standard host handler\nresolution. Shared helper logic exists in `src/plugins/federationShared.ts`,\nwithout reintroducing backend orchestration ownership.\n\nBecause each phase is now regular stage compute, federation behavior is governed by\nthe same contracts used by all other workflow stages: typed context input,\nstatus-coded plugin result, and host-controlled Merkle materialization.\n\n== Persistence and State Semantics\n\nFederation progress is reconstructed from artifacts and workflow position.\nDedicated store-level `federationState` has been removed. Publication configuration\npersists in project scope via `.federation-config.json`, making it portable with\nthe project and inspectable under normal filesystem tooling.\n\nThis model avoids controller-side shadow state and ensures compatibility with\nfuture host backends where project data may live on real filesystems instead of\nin-memory simulation.\n\n== Command Contract\n\nLegacy shortcut surfaces that encoded implicit approvals, such as\n`federate --yes`, are no longer part of the federation contract. Advancement is\nexpressed through explicit stage commands declared in manifest context and resolved\nthrough normal workflow dispatch. Structured scripts follow the same policy:\nfederation automation uses explicit command steps, not backend translation tables.\n\n== Architectural Outcome\n\nFederation is now an instance of the general ARGUS runtime model, not an exception\nto it. Manifests declare the sequence, plugins execute compute, and the host\nanchors results. This closes a key transitional debt surface and aligns federation\nexecution with the production-pure backend doctrine established in v10.2 and v10.3.\n\n---\n_Last updated: 2026-02-20 (v10.3.0)_",
    "framework.adoc": "= ARGUS Framework Patterns: The Architecture of Deterministic UI\n:author: ATLAS Project Team\n:revdate: 2026-02-18\n:revnumber: 10.0.0\n:toc: macro\n:toclevels: 3\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe ARGUS Framework is a specialized UI architecture built on Vanilla TypeScript, designed to manage the high complexity of federated medical imaging workflows without the overhead of third-party frontend frameworks. By enforcing strict patterns for reactivity, component lifecycle, and DOM ownership, ARGUS ensures a consistent, high-fidelity user experience across both web and CLI surfaces. This document codifies the core framework patterns—specifically the \"Slot Pattern\" and \"RPN Naming\"—that maintain architectural integrity within the decoupled Host/Guest system of v10.0.\n\n== Introduction: The Historical Context\n\nThe decision to build ARGUS without a traditional frontend framework (e.g., React, Vue, or Svelte) was a deliberate engineering choice to ensure architectural purity and environment-agnosticism. Early development efforts encountered significant challenges with \"DOM Pollution\" and \"State Drift,\" where different UI components would interfere with each other's DOM subtrees, leading to fragile and non-deterministic behavior. We learned that for a system grounded in data-state truth, the UI must be a deterministic projection of that state, not a source of truth itself.\n\nThe resolution was the development of a suite of project-specific patterns designed to provide the same benefits as modern frameworks—isolation, reactivity, and modularity—but without the runtime overhead. Most notably, the **Slot Pattern** was introduced to solve visual isolation, and **RPN Naming** was mandated to provide functional clarity. These patterns ensure that the ARGUS LCARS interface remains scalable and verifiable through the ORACLE methodology, providing a robust interface for both human and AI operators.\n\n== Framework Pattern Figure\n\n[source,text]\n----\n┌──────────────┐     ┌──────────────┐     ┌────────────────┐\n│ RPN naming   │────▶│ Stage hooks  │────▶│ predictable UI │\n└──────────────┘     │ enter/exit   │     │ transitions    │\n                     └──────┬───────┘     └────────────────┘\n                            │\n                            ▼\n                     ┌──────────────┐\n                     │ Slot pattern │────▶ DOM isolation\n                     └──────┬───────┘\n                            │\n                            ▼\n                     ┌──────────────┐\n                     │ Providers    │────▶ VFS materialization bridge\n                     └──────────────┘\n----\n\n== RPN Naming Convention: Functional Clarity\n\nAll functions and methods in the ARGUS codebase must follow **Reverse Polish Notation (RPN)**: `<subject>_<verb>`.\n\n*   **Engineering Rationale:** Traditional imperative naming (e.g., `expandWorkspace`) often obscures the primary target of the action. By leading with the subject (e.g., `workspace_expand`), ARGUS ensures that related functions group naturally in alphabetical listings and that the intent of the code is immediately apparent.\n*   **Implementation:** This convention applies to all layers of the system, from low-level VFS mutations (`node_write`) to high-level UI orchestrators (`projectStrip_render`). It is the \"Grammar\" of the ARGUS project, enabling both human and AI developers to navigate the codebase with high precision.\n\n== The Slot Pattern: Visual Isolation\n\nTo handle the complexity of the LCARS multi-mode interface, ARGUS utilizes the **Slot Pattern**. This solves the problem of multiple consumers (e.g., Marketplace, Project Detail, Dataset Detail) needing to occupy the same physical DOM container.\n\n=== The Problem: DOM Corruption\nNaively overwriting `innerHTML` on component open and attempting to \"restore\" it on close is a known failure mode. If any component fails to perfectly restore the DOM, the subsequent component inherits a corrupted environment.\n\n=== The Resolution: Logical Slots\nInstead of mutating shared DOM, the container holds the **default consumer** as static HTML and provides empty **slot containers** for additional modes. Visibility is managed strictly through CSS attribute selectors (e.g., `[data-mode=\"project\"]`).\n*   **Host Responsibility:** The UI orchestrator sets the `data-mode` and writes the Guest content into the designated slots.\n*   **Verification:** This pattern ensures that the default state is never lost and that UI bugs are physically contained within their own slots, preventing the \"cascading DOM failure\" common in legacy web applications.\n\n== Stage Lifecycle Hooks: Predictable Transitions\n\nWorkflow progression in ARGUS is managed through **Stage Lifecycle Hooks**. Each SeaGaP stage (Search, Gather, Process, etc.) is a self-contained module that exports `stage_enter()` and `stage_exit()` functions.\n\n*   **Decoupled Orchestration:** The main entry point (`argus.ts`) does not contain stage-specific logic. It simply dispatches to the appropriate hooks when the application state changes.\n*   **Automated Cleanup:** The `stage_exit` hook is responsible for tearing down environment-specific state, such as active FileBrowser instances or terminal resize handles. This ensures that the system always starts from a clean slate when entering a new phase of the scientific process.\n\n=== Search/Gather Adapter Boundary\n\nSearch and Gather share adjacent UI surfaces, but they remain distinct stage responsibilities:\n\n*   **Search-stage adapters** (`src/core/stages/search.ts`) own discovery interactions and search-result projection.\n*   **Gather-stage adapters** (`src/core/stages/gather/*`) own project selection, dataset detail workflows, and gather workspace interactions.\n*   **Shared render helpers** are allowed when they are presentation-only and stage-agnostic.\n\nIf logic mutates cohort membership, project gather-target state, or gather workspace context, it belongs under Gather modules. If logic resolves or filters catalog discovery, it belongs under Search modules.\n\nThis boundary keeps UI adapters aligned with SeaGaP semantics and avoids accidental cross-stage coupling.\n\n== The Provider Pattern: Domain-to-VFS Translation\n\nProviders are the \"Translators\" of the ARGUS system. They are pure functions located in `src/vfs/providers/` that transform high-level domain objects (e.g., a `Project` model) into low-level VCS filesystem trees.\n\n*   **Materialization Bridge:** This pattern is the primary mechanism for Data-State Grounding. When a project is loaded, the `ProjectProvider` generates the `src/`, `input/`, and `output/` skeleton and mounts it into the VFS.\n*   **Lazy Content:** Providers use `contentGenerator` strings to enable lazy materialization. File content is only synthesized when a read operation occurs, allowing the VCS to support massive datasets without excessive memory usage.\n\n== Conclusion\n\nThe ARGUS Framework patterns provide the structural discipline required to build a sophisticated, agent-mediated interface without the fragility of traditional state-heavy UI models. By grounding the UI in deterministic projections and isolating component state through slots and providers, we ensure that the ARGUS console remains a robust and reliable tool for federated medical research. These conventions are the foundation upon which the v10.0 architecture stands, enabling perfect synchronization between the visual interface and the materialized ground truth.\n\n---\n_Last updated: 2026-02-18 (v10.0.0)_",
    "history.adoc": "= ARGUS Project History: The Forensic Chronicle of a State-Grounded Kernel\n:author: ATLAS Project Team\n:revdate: 2026-02-20\n:revnumber: 10.3.1\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe ARGUS (ATLAS Resource Guided User System) project represents a relentless, single-developer engineering investigation into the \"Truth Gap\" of AI-mediated scientific research. Since its inception on January 23, 2026, the system has evolved through multiple architectural phases, transitioning from a monolithic UI-centric prototype into a high-integrity system kernel grounded in Merkle-proven materialization. This document provides an exhaustive, forensic narrative of that evolution, providing a dedicated technical analysis for every significant version bump in the project's history.\n\nEach section details the specific technical pressures—such as monolithic drift, instructional decay, and the irreducible hallucination of agency—that necessitated the continuous refactoring of the system's core during this high-velocity solo sprint. The architectural decisions documented here are not the result of user studies, but the expression of over two decades of practitioner expertise in scientific computing systems. By documenting the \"Historical Drama\" of every milestone, this specification provides the necessary context for understanding why the v10.0 architecture is the only mathematically viable solution for high-stakes federated research.\n\n== Phase Timeline Figure\n\n[source,text]\n----\n2026-01-23                                                            2026-02-20\n    │                                                                      │\n    ├── Phase I   v1.0  .. v1.4      SeaGaP codification\n    ├── Phase II  v1.4.1.. v3.4      Intelligence console + agentic pivot\n    ├── Phase III v4.0  .. v4.7      VCS substrate + slot refactor\n    ├── Phase IV  v5.0  .. v8.0      Headless Calypso + ORACLE + scripts\n    └── Phase V   v9.0  .. v10.3.1   DAG + Merkle + plugin runtime hardening\n\narc: monolithic UI prototype  ─────────────────────────▶  state-grounded kernel\n----\n\n== Phase I: Genesis and the Codification of \"SeaGaP\" (v1.0 - v1.4)\n_Period: January 23 – January 25, 2026_\n\n=== Status Quo: The Initial Prototype\nThe project commenced on January 23, 2026, with the goal of proving that a unified interface could manage the complexities of federated data discovery for the ATLAS platform. At this stage, the codebase was a monolithic \"Developer Vertical\" where the UI was the primary driver of the logic. The system could demonstrate interaction, but it lacked the structural constraints required to ensure scientific correctness. The immediate challenge was organizing diverse research tasks into a coherent, repeatable sequence.\n\n=== Version 1.0: The SeaGaP Baseline\nReleased on January 24, 2026, Version 1.0 established the foundational structural spine of the system: the **SeaGaP-MP** framework. Drawing from deep experience in medical imaging workflows, it was clear that research required a consistent procedural language to bridge the gap between diverse personas. Without a standard lifecycle, system goals remain ill-defined and idiosyncratic, making it impossible to coordinate complex multi-site operations.\n\nThe resolution was a five-stage linear pipeline—Search, Gather, Process, Monitor, and Post—that imposed a strict temporal order on research operations. This version also introduced the \"Tactical Header\" and role-based login, proving that a unified interface could manage the complexities of federated data discovery. The SeaGaP framework ensured that progress was no longer a matter of opinion, but a sequence of logical transitions that could be visually tracked and verified.\n_See also: link:philosophy.adoc[ARGUS Philosophy] for the full SeaGaP-MP conceptual framework._\n\n=== Version 1.1: State-Aware Navigation\nThe v1.1 update addressed the \"Statelessness Problem\" identified immediately after the initial baseline. While v1.0 displayed the workflow tracker, it was merely a visual ornament; clicking its stations did nothing, and it had no knowledge of whether a user was searching or gathering. This lack of state awareness made the system feel like a collection of static pages rather than a coherent application, creating a significant barrier to effective operation.\n\nTo resolve this, v1.1 refactored the tracker to drive stage transitions, marking the first move toward a state-aware UI. This release introduced the concept of \"visited\" and \"active\" states for workflow stations, ensuring that the user's progress was visually synchronized with the application's internal state machine. It proved that the UI could be used as a mirror of the underlying logical state, a principle that would later be hardened into the \"State-First\" mandate of v10.0.\n\n=== Version 1.3: The RPN Mandate and Layout Integrity\nVersion 1.3 was a critical \"Architectural Pause\" necessitated by the rapid increase in code complexity during the solo sprint. Traditional imperative naming conventions (e.g., `expandWorkspace`) were obscuring the primary targets of functions, leading to \"spaghetti-logic\" where it was difficult to locate relevant code. Furthermore, layout regressions in the top panel were causing text to truncate on modern FHD laptop displays, undermining the project's professional aesthetic.\n\nThe resolution was the mandatory implementation of **RPN (Reverse Polish Notation)** naming (`subject_verb`). This shifted the focus of the codebase toward objects and their actions (e.g., `workspace_expand`), making the system infinitely more navigable. This release also fixed the top-panel overflows and implemented the first formal \"Logout\" protocol, ensuring that session state could be cleared reliably before a new research persona took control of the console.\n_See also: link:framework.adoc[Framework Patterns] for the RPN naming specification._\n\n=== Version 1.4: Multi-Window Telemetry and the Subway Layout\nThe final release of Phase I, v1.4, introduced the \"Hanging Subway\" layout—a specialized LCARS geometry designed to maximize screen real estate for telemetry. From a systems perspective, it was evident that monitoring a federated network through a single log window is insufficient; simultaneous visibility into loss curves, node status, and participant metadata is required to detect anomalies in real-time.\n\nThis version implemented multi-window rendering for the **Monitor** stage, allowing these diverse data streams to be displayed in parallel using a \"provider-renderer\" pattern. It also included the first automated test harness for data models, establishing the \"Zero-DOM Policy\" by proving that the system's core logic could be verified independently of the browser's document model. This release transformed ARGUS from a simple viewer into a professional scientific dashboard.\n\n== Phase II: The Intelligence Console and the \"Agentic Pivot\" (v1.4.1 - v3.4)\n_Period: January 26 – January 28, 2026_\n\n=== Version 1.4.1 - 1.4.3: Terminal Hardening\nThese rapid-fire versions addressed the \"Interaction Gap\" identified after the launch of the Monitor stage. While the GUI was functional, it was too slow for technical directory manipulations. v1.4.1 through v1.4.3 focused on anchoring the top panel elements and expanding the terminal with common Linux filesystem commands (`ls`, `cat`, `mkdir`). This was the beginning of the shift toward a CLI-first developer experience.\n\nThe pressure driving these releases was the need for high-fidelity file inspection. Without a robust terminal, the content of the simulated project tree could not be verified. By integrating these builtins, ARGUS moved closer to becoming a true \"Virtual Computer System,\" providing the tools necessary for researchers to inspect their data artifacts directly within the LCARS interface.\n\n=== Version 1.4.4 - 1.4.5: The \"MU/TH/UR\" Streaming Refinement\nVersion 1.4.4 and 1.4.5 refined the terminal's visual experience, introducing the \"MU/TH/UR\" streaming style. Named after the computer in the *Alien* franchise, this protocol defined a utilitarian, non-human AI personality that communicated through character-by-character blue text. This was a deliberate design choice to move away from \"friendly chatbots\" toward an observational AI that felt like an integral part of the ship's computer.\n\nThe refinement of the streaming logic was driven by the need for better visual feedback during long-running operations. By using the `Typewriter` animation, ARGUS provided a sense of \"system thought,\" reducing the perceived latency of AI queries. These versions established the \"Observational Personality\" that would eventually be formalized in the v10.0 Calypso Host.\n\n=== Version 2.0.0: The Agentic Pivot and Intelligence Console\nReleased on January 26, 2026, v2.0.0 was the most significant conceptual shift in the project's history. It launched the **Unified Intelligence Console**, a retractable terminal that became the system's primary interaction surface. This was not a cosmetic update; it was a fundamental \"Pivot to Agency.\" The goal was to allow the operator to drive the entire system through natural language, rather than searching through nested menus.\n\nBy repositioning the AI assistant, Calypso, as the central mediator of the scientific process, v2.0.0 transformed ARGUS into an agentic system. However, this pivot immediately exposed the \"Irreducible Hallucination\" problem: without a deterministic kernel to back it up, the AI would often claim success for actions it had no power to execute. This version established the **Interpretation-First Pipeline**, but the \"Action\" layer remained fuzzy and ungrounded.\n_See also: link:calypso.adoc[CALYPSO Intelligence Host] for the kernel specification._\n\n=== Version 3.0.0: The Reactive Update and Mock VFS\nVersion 3.0.0 addressed the \"Context-Window Collapse\" failure mode that plagued the early agentic pivot. Because the system's state was managed through disjointed variables, Calypso would frequently lose track of session progress. For instance, after a user renamed a project, the AI would continue to refer to the old name, causing confusion and procedural errors that compromised the integrity of the research.\n\nThe resolution was the migration to a **Pub/Sub (Observer) pattern** using a central `Store` and a global `EventBus`. This release also implemented the first \"Mock VFS\" and the IDE-style **Process** stage. By forcing every mutation to emit a typed event, the system ensured that all UI components (Terminal, Grid, Tracker) remained synchronized. This version established the \"State-First\" principle, proving that the UI must be a deterministic projection of an underlying state store.\n_See also: link:framework.adoc[Framework Patterns] for the Pub/Sub and Store implementation details._\n\n=== Version 3.1.0: Professionalized Marketplace and Frame Generation\nThis update focused on the scalability of the asset catalog. As the ATLAS ecosystem grew, it became clear that static HTML layouts were too rigid to accommodate the diverse range of pre-trained models and processing applications. The manual addition of new assets was becoming a bottleneck, preventing the rapid deployment of new scientific tools.\n\nv3.1.0 introduced **Procedural Frame Generation**, allowing the LCARS UI to dynamically render high-density tiles and detail views based on JSON metadata. This release professionalized the marketplace, making it an extensible platform for MERIDIAN-compliant software. It proved that even the most complex LCARS geometries could be generated deterministically from data, further decoupling the system's \"Appearance\" from its \"Logic.\"\n\n=== Version 3.4.0: Visual Dialect Maturity and the Frame Slot\nVersion 3.4.0 introduced the **Frame Slot** system and **Beckon Pulse** visual language. These were engineered to solve the problem of \"Interactive Overload,\" where users were overwhelmed by the number of clickable elements on the high-density console. The Beckon Pulse signaled interactivity through subtle brightness oscillations, reducing cognitive noise by removing the need for high-contrast \"Click Me\" buttons.\n\nThe Frame Slot system provided a standardized mechanism for animating panel transitions, ensuring that the UI felt like a cohesive \"Living System\" rather than a set of disjointed screens. This release ensured that the interface remained intuitive even as the system's technical capabilities ballooned, aligning the visual dialect with the rigorous requirements of clinical research environments where focus is paramount.\n\n== Phase III: The VCS Substrate and the \"Slot\" Refactor (v4.0 - v4.7)\n_Period: January 29 – February 1, 2026_\n\n=== Version 4.0.0: The VCS Foundation\nReleased on January 29, 2026, v4.0.0 addressed the \"Truth Gap\" by introducing the **Virtual Computer System (VCS)**. It was recognized that for an AI agent to be truly safe, it must be embedded within a deterministic environment that behaves according to immutable rules. Legacy versions that managed state through JavaScript objects were inherently unverifiable and prone to silent corruption.\n\nThe VCS provided a simulated POSIX-compliant filesystem (**VFS**) and a process-aware **Shell**. This move shifted the system's \"Ground Truth\" from \"Assertions in Memory\" to \"Artifacts on Disk.\" If the AI claimed to have harmonized a cohort, the system could now perform a physical check of the VFS for the `.harmonized` marker. If the file was absent, the AI's claim was rejected, creating the first hard safety gate against hallucination.\n_See also: link:vcs.adoc[VCS Substrate], link:vfs.adoc[Virtual File System], and link:shell.adoc[VCS Shell] for exhaustive hardware-level specifications._\n\n=== Version 4.5.0: The Multi-Mode Slot Architecture\nVersion 4.5.0 resolved a critical crisis of \"DOM Pollution\" in the overlay system. Multiple components (Marketplace, Project Detail, Dataset Detail) were competing for control of the same DOM containers. This led to \"Cascading Failures\" where closing one detail view would accidentally delete the buttons or state of the underlying Marketplace, requiring a full page refresh to recover.\n\nThe resolution was the **Slot Pattern**, which replaced destructive `innerHTML` mutation with a CSS-driven visibility model. By providing empty `overlay-slot` containers for each mode, the system ensured that visual states were isolated. This pattern enforced a strict \"Host/Guest\" relationship at the UI layer, proving that architectural isolation was the only way to maintain deterministic visual integrity in a complex multi-mode interface.\n_See also: link:framework.adoc[Framework Patterns] for the Slot Pattern specification._\n\n=== Version 4.7.0: MU/TH/UR Protocol and Idle Detection\nThe final release of Phase III, v4.7.0, implemented advanced idle detection and a persistent workspace. It was observed that complex analysis tasks often involve long periods of contemplation without console interaction. During these pauses, a reactive AI assistant remains dormant, missing critical opportunities to provide contextual guidance or status updates.\n\nThe \"MU/TH/UR\" protocol allowed Calypso to monitor activity and trigger proactive conversational thoughts (e.g., suggesting a project rename if a draft was unnamed). This version solidified the \"Intelligence Host\" metaphor, ensuring the AI was a participant in the workflow rather than a reactive chatbot. It prepared the system's core for the transition to headless, service-oriented execution.\n\n== Phase IV: Headless Calypso, Scripts, and ORACLE (v5.0 - v8.0)\n_Period: February 2 – February 13, 2026_\n\n=== Version 5.0.0: The Headless Kernel and ORACLE v1.0\nReleased on February 3, 2026, v5.0.0 was a breakout milestone that bifurcated the \"Calypso Core\" from the browser runtime. It was clear that for ARGUS to be a professional research tool, it had to be verifiable in a headless server environment. Testing by manually clicking through a UI was slow, unscalable, and inherently non-deterministic, masking deep-seated logic bugs.\n\nThis separation enabled the development of the **ORACLE** methodology—a State-First Verification strategy. This version launched the Calypso CLI and the first in-process test runner, allowing the system to be verified in a CI/CD pipeline. By asserting on protocol codes and VFS artifacts instead of English text, v5.0.0 provided the first mathematical proof of system integrity, ensuring that \"Truth\" was measured in data, not words.\n_See also: link:oracle.adoc[ORACLE Specification] for the reflexive verification methodology._\n\n=== Version 5.1.6 - 5.1.9: CLI Hardening and Banner Normalization\nThese versions focused on the professionalization of the headless environment. Early versions of the CLI were difficult to read and lacked the \"personality\" of the LCARS interface. Furthermore, inconsistencies in username and home-path mapping between the browser and the terminal were causing VFS path-resolution errors that made testing unreliable.\n\nv5.1.6 through v5.1.9 implemented robust dynamic padding for CLI banners and synchronized the headless server with the global Store singletons. This ensured that the researcher persona, project context, and version strings remained consistent across both graphical and terminal sessions. This era proved that \"Lore\" and \"Logic\" could be unified into a single systems specification.\n\n=== Version 6.0.0: Persona-Driven Workflows and Manifests\nVersion 6.0.0 introduced **Persona-Driven Workflows**, addressing the \"Persona Fragmentation\" problem at the logic layer. It became evident that different researchers (e.g., Federated ML Developers vs. ChRIS Developers) required different stages, different commands, and different security permissions. Hardcoding a single SeaGaP sequence was no longer viable for a national-scale platform.\n\nThis release implemented the \"Three-Tier Execution Model,\" where logic was categorized into Kernel (Core), Shell (Builtins), and Workflow (Manifests). It introduced the first YAML-based manifests to define these stages, providing the initial blueprint for the later Plugin refactor. v6.0.0 proved that the system's \"operating model\" could be swapped dynamically without changing the kernel code, making ARGUS a generic orchestrator for any scientific protocol.\n\n=== Version 6.2.0: Data-State Alignment and NL Routing\nReleased on February 6, v6.2.0 completed the total migration of workflow progress to physical VFS markers (`.cohort`, `.harmonized`). Experience showed that as long as the system maintained any internal \"completion flags,\" there was a risk of drift. The resolution was to eliminate all flags: progress was now determined solely by performing a topological walk of the disk.\n\nThis version also introduced the first iteration of the **Interpretation-First Pipeline**. By using deterministic regex matching to route common natural language verbs (e.g., \"harmonize it\") to system commands, the system reduced latency and prevented LLM misinterpretation. This phase established the \"AI-as-a-Compiler\" metaphor that would define the v10.0 architecture.\n\n=== Version 7.0.0: Federation Orchestrator and Automation Scripts\nVersion 7.0.0 was a major release that introduced the first **Automation Scripts**. It was recognized that power users needed to execute complex, multi-step flows—such as site-local harmonization—through a single, repeatable command. The hardcoded \"Simulate\" button was replaced by a scriptable CLI layer, marking the first time domain logic was externalized from the core orchestrator.\n\nThis release also launched the **Federation Orchestrator** to manage the 4-phase \"Federalization Handshake\" (Briefing, Transcompile, Containerize, Dispatch). This service ensured that no model reached the network without formal human approval at every gate. v7.0.0 transformed federalization from a \"black box\" into a transparent, auditable process grounded in Merkle materialization and explicit security receipts.\n_See also: link:federation.adoc[Federation Orchestrator] for the handshake protocol._\n_See also: link:shell.adoc[VCS Shell] for the script execution specification._\n\n=== Version 7.0.1 - 7.0.5: Narrative Expansion and Lore\nThese updates addressed the \"Documentation Gap.\" It was found that understanding the deep engineering rationale behind concepts like the VCS and SeaGaP was critical for maintaining the codebase during the high-velocity sprint. Without context, the codebase felt like a collection of arbitrary choices.\n\nv7.0.1 through v7.0.5 enriched the markdown storytelling and expanded the project's backstory (`story.md`). By weaving the engineering history into the \"Scientific Lore\" of the project, we ensured that the project's intent was preserved. This era established the \"Historical Voice\" standard that would later be formalized in the project's writing guide.\n\n=== Version 7.1.0 - 7.1.10: Triad Clarification and Positioning\nThis sequence reframed ARGUS within the broader ARPA-H national federated learning initiative. The project's positioning was ambiguous; it was often confused with the underlying ATLAS platform itself. This lack of clarity was a barrier to clinical partnership and onboarding.\n\nVersions 7.1.0 through 7.1.10 clarified the \"Triad\" relationship between ATLAS (The Network), Calypso (The Kernel), and ARGUS (The Interface). This era focused on \"Developer Grounding,\" providing the reading order and setup documentation required for national-scale deployment. It transformed the project from a \"mockup\" into a \"conceptual idea\" for the national ATLAS user layer.\n\n=== Version 7.2.0 - 7.2.1: WebSocket Service Decomposition\nVersion 7.2.0 refactored the core into a layered WebSocket architecture. This decomposition was driven by the requirement for remote research sessions. In a clinical environment, the researcher's interface (the browser) and the research data (the server) are often physically separated by secure hospital firewalls.\n\nThe WebSocket layer allowed the headless kernel to reside on a secure server while the LCARS interface ran in a local browser. This move finalized the \"Service-Oriented\" vision of the Calypso Host, ensuring that the system's integrity model was independent of the transport layer. It was the final prerequisite for the v10.0 \"Plugin Revolution.\"\n\n=== Version 7.3.0 - 7.3.1: Command Protocol Alignment\nThese releases aligned the Federation Orchestrator's internal command protocol with the workflow manifest stage commands. It was discovered that the orchestrator was still using \"custom logic\" to handle its phases, which bypassed the DAG Engine's standard verification gates. This was a source of subtle \"State Drift\" during federation handshakes.\n\nv7.3.0 eliminated these custom paths, forcing all orchestrator commands through the standard manifest-driven pipeline. This made the federalization handshake as verifiable and auditable as any other SeaGaP stage. It was the final \"Cleanup\" before the move to the v9.0 DAG revolution.\n\n== Phase V: The v10.x Plugin Revolution and Hardening Line (v9.0 - v10.3.1)\n_Period: February 14 – February 20, 2026_\n\n=== Version 9.0.0: Manifest-Driven DAG Engine\nReleased on February 16, 2026, the v9.0.x series replaced the legacy linear state machine with a **Manifest-Driven DAG Engine**. Scientific workflows are rarely linear; they involve complex branching, re-execution of upstream stages, and parallel parentage that linear models cannot represent. This \"Graph-Gap\" was a primary source of state-drift in legacy versions.\n\nThe DAG Engine resolved this by modeling processes as Directed Acyclic Graphs defined in external YAML manifests. It introduced the **Topological Position Resolution** algorithm, which determined the current stage by walking the VFS and checking for artifact evidence. This ensured that the system's \"conscience\" was always grounded in the physical disk, making it immune to the \"Instructional Decay\" that plagued earlier versions.\n_See also: link:dag-engine.adoc[DAG Engine Specification] for the manifest schema and topological resolution logic._\n\n=== Version 9.6.0: The Merkle Revolution\nVersion 9.6.0 introduced **Merkle Fingerprinting**, addressing the problem of \"Silent Data Modification.\" While the VFS tracked the existence of files, it could not detect if an upstream file (e.g., the search query results) had been tampered with after a downstream stage (e.g., the gathered cohort) had been completed. This lack of cryptographic anchoring was a significant risk for clinical reproducibility.\n\nThe Merkle Engine solved this by cryptographically anchoring every artifact to its specific parentage using recursive SHA-256 hashes. If a researcher re-executed an early stage, the system would instantly flag all downstream stages as `[STALE]`, providing a mathematical guarantee against scientific inconsistency. This release transformed the filesystem into a \"Proven Ledger,\" providing the absolute integrity required for regulated medical research.\n_See also: link:merkle-engine.adoc[Merkle Engine Specification] for the recursive hashing math and staleness algorithms._\n\n=== Version 10.0.0: The Plugin Runtime Revolution\nThe project reached its current v10.0 state on February 17, 2026. This was the final \"Revolution\"—the definitive separation of the **Host (Kernel)** from the **Guest (Logic)**. It was realized that as long as domain logic lived in the kernel, the system could never be truly generic, secure, or developer-friendly. Every new research persona required a deep refactor of the core `CalypsoCore` class.\n\nThe move to v10.0 purged all domain logic from the kernel and moved it to atomic **Guest Plugins**. The system is now a formal Host VM, providing a strictly-typed **PluginContext** (Standard Library) to unprivileged logic. This bifurcation ensures that the \"Integrity\" of the system is managed by the high-integrity Host, while the \"Intelligence\" remains a flexible AI interface. It resolves the \"Irreducible Hallucination\" problem by forcing all work into plugins and all progress into Merkle-proven artifacts, transforming ARGUS into a verifiable scientific operating system.\n_See also: link:architecture.adoc[System Architecture] for the Host/Guest VM model specification._\n_See also: link:plugins.adoc[Plugin System Specification] for the VM and context details._\n\n=== Version 10.2.1 - 10.2.2: The Hardening Release Line\nBy February 20, 2026, it was clear that early v10.x represented a partial but incomplete pivot: plugin boundaries existed, but some federation behavior and simulation assumptions still leaked into backend pathways. The engineering pressure in this period was not feature expansion; it was architectural purification.\n\nThe v10.2.1 to v10.2.2 line hardens that boundary through a coordinated\ndeletion-and-rebinding pass.\nFederation compute was fully materialized as explicit `federate-*` stage plugins,\nwhich removed remaining backend orchestrator pathways and erased legacy\n`federationState` coupling. In parallel, synthetic compute latency was deleted from\nbackend execution paths so runtime realism became strictly plugin-local behavior\nthat can be disabled deterministically with `CALYPSO_FAST=true` during oracle and CI\nexecution. The verification baseline was then restored against current store and\nMerkle semantics, confirming that hardening did not trade boundary purity for test\ninstability.\n\nThis release line is intentionally framed as a hardening checkpoint rather than a\nterminal destination. `v10.2.2` marks the stabilization baseline before `v10.3`\ndeletion work removes compatibility scaffolding and before `v11.0` enforces formal\ncontract lock across Host kernel, plugin compute, and adapter rendering boundaries.\n\n=== Version 10.3.0: The Deletion Pass\nAfter hardening, the next engineering step is subtraction. The objective is to remove\ntransitional runtime scaffolding so only one architecture path remains active.\n\nThe first v10.3 wave targeted three migration-era seams that preserved dual-path\nbehavior. Legacy materialization mode branching and join-toggle wiring were removed\nso runtime materialization now follows one canonical store/join path. Calypso\nconfiguration was reduced by deleting runtime materialization and join toggles from\n`CalypsoCore`, preventing dual-mode boot semantics. SessionStore flat-root\ncompatibility (`rootStageInOwnDirectory`) and its companion compatibility tests were\nalso deleted so one deterministic stage-path contract remains.\n\nThis release completes the architectural cleanup phase between hardening and\ncontract lock by converting optional legacy behavior into enforced invariants.\n\n=== Version 10.3.1: Contract Hardening Sweep and Stabilization Patch\nThe next hardening sweep focused on removing remaining backend-internalized behavior\nthat could reintroduce hidden workflow coupling before v11 contract lock.\n\nThe status quo at the start of this sweep was a partially purified kernel: major\nfederation orchestration had already moved into stage plugins, yet residual\ninternalizations still persisted in boundary layers. The catalyst was not a single\ncrash, but the recognition that pre-v11 contract lock could fail silently if command\nvocabulary, handler ownership, and bootstrap identity remained encoded as backend\nassumptions rather than runtime declarations.\n\nThe investigation centered on three pressure fronts. First, plugin loading still\ncarried migration-era traces of static backend ownership semantics. Second, routing\nand intent compilation still permitted hidden command-policy drift whenever parser\nvocabularies diverged from manifest command sets. Third, bootstrap literals\n(`fedml`, `DRAFT`) preserved a legacy identity model incompatible with explicit,\nportable runtime context.\n\nThe resolution was a coordinated deletion-and-rebinding pass. Plugin dispatch moved\nfully to convention-based dynamic resolution with runtime export validation and\nmanifest-load-time handler resolvability checks. Workflow command ownership was\nre-grounded in manifest declarations by removing stage-specific routing overrides and\nbinding intent acceptance to active-manifest command verbs. ScriptRuntime federation\ntranslation branches were deleted and replaced with declarative command steps, so\nautomation semantics now remain script-visible rather than runtime-hidden. Bootstrap\nidentity resolution in core and store paths was converted from literal defaults to an\nexplicit chain spanning config, environment, active project state, persisted session\ncontext, and workflow registry fallback.\n\nThe architectural outcome is a materially stricter Host/Guest boundary. Manifests now\ndefine orchestration vocabulary and handler intent, plugins own compute semantics, and\nbackend runtime no longer carries latent persona pipelines or project-name surrogates\nthat can accumulate untracked debt.\n\nLate in the cut process, an additional stabilization patch inside `10.3.1` repaired\nsession continuity across first-project activation and corrected oracle `${session}`\ninterpolation to bind to runtime session state. That patch closed a false-negative\nverification seam and restored full oracle green status without reintroducing backend\nsimulation behavior.\n\nA follow-on stabilization addendum on February 21 removed the remaining fixed host\nexecution watchdog (`10s` timeout in workflow dispatch) and corrected CLI telemetry\nrendering semantics so progress updates rewrite one active row with glyph bars\ninstead of printing one line per tick. This closed a user-visible observability bug\nwithout relaxing Host/Guest boundaries or provenance guarantees.\n\n== Persistence and Integrity Matrix\n\nThe following matrix summarizes the evolution of the system's grounding mechanisms across the major developmental phases of this sprint.\n\n[cols=\"1,2,2,2\",options=\"header\"]\n|===\n|Mechanism |Introduced |Primary Role |Scientific Benefit\n\n|**SeaGaP-MP**\n|v1.0\n|Procedural Spine\n|Ensures consistent research lifecycle across all personas.\n\n|**RPN Naming**\n|v1.3\n|Functional Clarity\n|Enables high-precision code navigation and AI-driven development.\n\n|**Slot Pattern**\n|v4.5\n|Visual Isolation\n|Prevents DOM pollution and ensures deterministic UI state rendering.\n\n|**VCS (VFS + Shell)**\n|v4.0\n|Hardware Grounding\n|Transforms AI assertions into verifiable filesystem artifacts.\n\n|**ORACLE**\n|v5.0\n|Reflexive Verification\n|Provides mathematical proof of system integrity via automated walks.\n\n|**DAG Engine**\n|v9.0\n|Orchestration Conscience\n|Supports non-linear branching and topological state resolution.\n\n|**Merkle Engine**\n|v9.6\n|Provenance Chain\n|Guarantees scientific consistency through recursive cryptographic hashing.\n\n|**Plugin Runtime**\n|v10.0\n|Host/Guest Bifurcation\n|Isolates idiosyncratic logic, ensuring a stable and generic system kernel.\n\n|**Plugin-Only Federation Hardening**\n|v10.2.2\n|Backend Purity Enforcement\n|Removes legacy federation/simulation debt from Host paths and restores deterministic release confidence.\n\n|**Session Continuity Stabilization**\n|v10.3.1\n|Runtime Path Correctness\n|Preserves upstream artifact lineage during project-switch and aligns oracle assertions with active session roots.\n|===\n\n== Conclusion: The Arc of Integrity\n\nThe evolution of ARGUS from January to February 2026 is a chronicle of the \"Scientific Hardening\" of AI. Each major version was a response to a specific failure mode where human trust in the system was compromised by AI-mediated ambiguity. From the early \"Gutter Flash\" regressions to the final \"Merkle Staleness\" proofs, the project has consistently prioritized \"Evidence over Assertion.\"\n\nBy grounding the entire system in a virtualized hardware substrate (VCS), a graph-based conscience (DAG Engine), and a Merkle provenance chain, ARGUS `v10.3.1` now represents the stabilized hardening baseline at the end of the v10 deletion line. The project stands as a successful proof-of-concept for how agentic systems can be made structurally safe, transforming the \"Hallucinating Agent\" into a high-fidelity instrument of scientific discovery. The next arc is explicit: complete residual debt removal and lock Host/Guest contracts in `v11.0`.\n\n---\n_Last updated: 2026-02-20 (v10.3.1)_",
    "lcars.adoc": "= ARGUS LCARS Interface Design\n:toc:\n:icons: font\n\nThis document captures the specific interaction and visual metaphors used in the ARGUS (ATLAS Resource Guided User System) LCARS interface.\n\n== The Intelligence Console (Terminal)\n\nThe terminal is the primary command and control hub for ARGUS. It functions as a \"Unified Intelligence Console\" where standard system commands (bash-like), natural language queries (LCARSLM), and agentic UI manipulations are integrated into a single stream.\n\n=== Visual Metaphor: The Tactical Drawer\n\nThe terminal is conceptually positioned **between** the Status Header (top panel) and the Operational Workspace (bottom panel). It is designed as a \"retractable drawer\" that unfurls from behind the main workspace.\n\n.Key Design Principles:\n* **Framework Integration**: The terminal is powered by the `LCARSTerminal` component from the `lcars-framework`. It is decoupled from application logic, using a command-registration API.\n* **Frameless Integration**: To avoid visual clutter, the terminal does not have its own left-side LCARS framing. Instead, it sits flush against the primary `left-frame` (sidebar), which acts as a \"rail\" for the drawer.\n* **The Workspace Lid**: The horizontal `bar-panel` (containing bars 6-10) functions as the physical \"lid\" of the bottom panel.\n* **Retraction Logic**:\n  - **Closed**: The lid sits at the top of the right-frame; the terminal is hidden (height: 0).\n  - **Open**: The lid slides downward, revealing the terminal screen above it.\n* **Dynamic Elbows**: The LCARS corner elbows are attached to the sliding \"lid\" rather than the frame, ensuring a flush join at any deployment height. These elbows have a high z-index (300) to sit above overlays like the Marketplace.\n\n=== Interaction Metaphor: The Pullable Access Strip\n\nThe primary method for adjusting the terminal's height is the **Access Strip**.\n\n* **The Handle**: A horizontal orange bar (`october-sunset`) floating 5px above the workspace lid.\n* **Draggable Workspace**: By \"grabbing\" this handle, the user physically pulls the entire workspace down, increasing the terminal's visibility. The height limit has been removed to allow full-screen console expansion.\n* **Visual Feedback**: The handle glows when active, providing tactile confirmation.\n* **Integrated Toggles**:\n  - **Tactical Close**: A glowing `mars` red pill at the top-right of the terminal header for quick retraction. Pulses with `lcars-beckon-mars` to signal interactivity.\n  - **Primary Toggle**: The rightmost bar segment (`bar-10`) of the workstation lid acts as the toggle switch. Pulses with `lcars-beckon-orange` when the terminal is closed; stops pulsing when open.\n  - **Resize Handle**: The Access Strip pulses with `lcars-beckon-orange` when the terminal is open, indicating drag-to-resize capability.\n\n== The Workspace Split-Pane\n\nWhen a project is OPENed from the Search stage, the right-frame transforms into a **workspace layout** — a vertical stack of two independently-sized panels separated by resize handles.\n\n=== Layout Structure\n\nThe workspace activates by adding `workspace-active` to `.right-frame`, switching it to a flex column. The DOM order becomes:\n\n----\n.right-frame.workspace-active\n├── #intelligence-console .terminal-drawer     (terminal panel)\n├── .workspace-resize-handle[data-target=terminal]  (terminal resize grip)\n├── #asset-detail-overlay.workspace-expanded   (file browser panel)\n├── .workspace-resize-handle[data-target=browser]   (browser resize grip)\n├── .bar-panel.main-bar-panel                  (hidden in workspace)\n└── #main-content                              (hidden in workspace)\n----\n\n=== Independent Panel Sizing\n\nThe two panels are **fully decoupled** — resizing one does not affect the other. This is achieved by giving each panel its own bottom-edge resize handle, rather than using a traditional split-pane divider that redistributes a fixed pool of height.\n\n* **Terminal panel**: Height set explicitly by drag (default: 30% of frame). `flex: none`. Min-height: 80px. No upper bound — making the terminal taller makes the page taller.\n* **File browser panel**: `flex: none; height: 70vh; min-height: 400px`. Independently resizable via its own handle.\n* **Page scrolling**: `.right-frame.workspace-active` has `min-height: 100vh` and `overflow: visible`, so the page scrolls to accommodate the total height of both panels. Users can scroll the top LCARS header off-screen for maximum workspace area.\n\n=== Resize Handles\n\nBoth handles share the `.workspace-resize-handle` CSS class:\n\n* **Visual**: 6px horizontal bar in `october-sunset` (orange). On hover/active: `canary` (yellow) with a subtle box-shadow glow.\n* **Interaction**: `cursor: row-resize`. Standard mousedown → mousemove → mouseup drag pattern.\n* **Cleanup**: Both handles and their event listeners are created by `workspace_expand()` and torn down by `workspace_collapse()`.\n\n=== Bidirectional Tab ↔ Terminal Sync\n\nThe file browser sidebar (SOURCE/DATA tabs) and the terminal working directory stay in sync:\n\n* **Tab → Terminal**: Clicking a sidebar tab calls `shell.cd()` to change the terminal's working directory to the corresponding project subdirectory (`/src` or `/data`).\n* **Terminal → Tab**: The Shell's `onCwdChange_set()` callback fires whenever `cd` succeeds. The workspace handler resolves the new cwd to a tab ID via `cwdToTab_resolve()` and switches the visual tab accordingly.\n\n== The Dataset Detail Overlay (Gather Mode)\n\nWhen a dataset tile is clicked from the search results, the asset detail overlay opens in **gather mode** — a selectable FileBrowser showing the dataset's data tree.\n\n=== Visual Identity\n\nThe dataset detail uses LCARS hue 200 (sky blue) to distinguish it from project detail (hue 30, orange/honey). The sidebar shows a single \"DATA\" tab and a \"GATHER\" label at the bottom corner.\n\n=== Selectable FileBrowser\n\nThe FileBrowser component operates in `selectable: true` mode. Short clicks still preview files. Long-pressing (500ms+) toggles selection:\n\n* **File long-press**: Toggles the individual file. Selected files show `.selected-for-gather` — a canary left-border, background tint, and checkmark prefix.\n* **Folder long-press**: Toggles all descendant files. If all are selected, deselects all; otherwise selects all.\n\n=== Command Column\n\nThe standard INSTALL/CLOSE pills are replaced with:\n\n* **DONE** (canary/gold): Commits gathered selection, closes overlay, marks dataset tile as `.gathered`.\n* **ADDITIONAL DATA** (october-sunset/orange): Commits selection, closes overlay, returns to grid for more dataset browsing.\n* **CANCEL** (mars/red): Closes without committing.\n\n=== Cost Strip\n\nA real-time cost summary bar at the bottom of the content area:\n\n----\nSELECTED: 45 / 293 FILES  |  ESTIMATED COST: $6.92\n----\n\nPer-file cost = dataset total cost / total file count. Updates live via `onSelectionChange` callback.\n\n== The Persistent Project Strip\n\nA horizontal strip of compact project chips persists at the top of the Search stage across all search operations. Projects never disappear when dataset results are displayed.\n\n* **Default chip**: honey border on dark background.\n* **Active chip** (gather target): solid honey background, black text, glow. Gathered data merges into this project.\n* **\"+ NEW\" chip**: dashed harvestgold border. Clears the active target for new project creation.\n\nFirst click on a chip sets it as the gather target. Second click (already active) opens the project detail overlay.\n\n== The Multi-Mode Overlay Architecture\n\nThe `#asset-detail-overlay` is shared by three consumers — marketplace assets, project detail, and dataset detail — each requiring different sidebar panels, content areas, and command pills. Rather than rewriting the overlay's innerHTML on each open and restoring it on close (a fragile pattern that caused regressions), the overlay uses a **slot-based multi-mode** approach.\n\n=== DOM Structure\n\nThe overlay contains both the marketplace's original static DOM and three empty **slot containers**:\n\n----\n#asset-detail-overlay[data-mode=\"marketplace|project|dataset\"]\n├── .detail-layout\n│   ├── .detail-panel\n│   │   ├── .lcars-frame\n│   │   │   ├── .lcars-sidebar            ← marketplace original (never mutated)\n│   │   │   ├── #overlay-sidebar-slot     ← project/dataset sidebar\n│   │   │   ├── .lcars-content            ← marketplace original (never mutated)\n│   │   │   ├── #overlay-content-slot     ← project/dataset content\n│   ├── .detail-command-column            ← marketplace original (CLOSE/INSTALL)\n│   ├── #overlay-command-slot             ← project/dataset commands (DONE/ADD/CANCEL or CLOSE/OPEN)\n----\n\n=== Mode Switching\n\nThe `data-mode` attribute on the overlay root controls visibility via CSS attribute selectors:\n\n* **`marketplace`** (default): Original sidebar, content, and command column are visible. All `.overlay-slot` containers are `display: none`.\n* **`project`** / **`dataset`**: Original elements are hidden via `:not(.overlay-slot)` selectors. Slot containers are visible and populated by `projectDetail_populate()` or `datasetDetail_populate()`.\n\nWhen a project or dataset detail is closed, the close handler:\n\n1. Clears slot innerHTML (via `overlaySlots_clear()`)\n2. Sets `data-mode=\"marketplace\"`\n\nThe marketplace's original DOM is **never touched**. No restore logic is needed.\n\n=== Workspace Teardown\n\nWhen the user triggers FEDERALIZE AND LAUNCH from within an expanded workspace, the system must fully tear down the workspace before transitioning to the Monitor stage. The `workspace_teardown()` function handles this:\n\n1. Calls `workspace_collapse()` — removes resize handles, restores `rightFrame` layout, shows stage content\n2. Hides the `asset-detail-overlay` and resets `data-mode` to `marketplace`\n3. Clears all slot contents\n4. Closes the terminal (monitor has its own telemetry)\n\nThis ensures the Monitor stage content renders unobstructed.\n\n== Operational Modes\n\nThe terminal dynamically adapts its persona and capabilities based on the active SeaGaP stage.\n\n=== Search Mode (AI Core)\nDuring the Search stage, the terminal acts as an AI-driven discovery engine.\n* **Prompt**: `ARGUS: SEARCH >`\n* **Agentic Logic**: The AI can automatically select datasets in the visual grid using the `[SELECT: ID]` intent parser.\n* **Telematic Readout**: The visual grid below the terminal serves as a secondary evidence display, updating in real-time as the AI identifies relevant cohorts.\n\n=== Developer Mode (Technical Shell)\nUpon entering the Process stage, the console transitions into a technical coding environment.\n* **Prompt**: `dev@argus:~/src/project $`\n* **Styling**: The UI automatically switches to a monospaced font (**Inconsolata**), clears history, and enables mixed-case input/output for technical accuracy.\n* **Commands**: Supports standard linux-style commands (`ls`, `cd`, `pwd`, `mkdir`, `rm`, `python`).\n\n== Typography: The Dual-Voice System\n\nARGUS uses the **Antonio** font family with a selective casing strategy:\n\n* **The System Voice (Uppercase)**: All structural elements, headers, prompts, and button labels are strictly uppercase.\n* **The Data Voice (Mixed Case)**: Terminal output (AI responses, file contents) and user input allow mixed case to preserve technical precision and improve readability.\n* **Visual Polish**: Terminal readouts feature a soft text-shadow glow, simulating a high-density CRT display.\n\n== LCARS Component System\n\nARGUS is built on a reusable **LCARS Framework** (`src/lcars-framework/`) that decouples data simulation from UI rendering.\n\n=== Telemetry Service\nThe telemetry system uses a provider-renderer pattern:\n* **Generators**: Pure logic classes (e.g., `ProcessGenerator`, `NetworkGenerator`) that produce data objects.\n* **Renderers**: Visual components (e.g., `ListRenderer`, `LogRenderer`) that take data and update the DOM.\n* **Service**: A central orchestrator that manages registration and the 800ms \"flicker\" update loop.\n\n=== Workflow Tracker\nThe `WorkflowTracker` procedurally generates linear pipelines (like SeaGaP) with:\n* **Stations**: Circular \"stops\" with associated labels and status classes (`active`, `visited`).\n* **Connectors**: Dynamic line segments between stops.\n* **Integrated Telemetry**: Each station includes a \"hanging\" telemetry window that populates via the `TelemetryService`.\n\n=== Asset Card Component\nThe `AssetCard` (`src/ui/components/AssetCard.ts`) is a shared UI primitive used to represent both Marketplace assets and User Projects. It unifies the visual language between external resources and internal workspaces.\n\n.Features:\n* **Polymorphic Rendering**: Adapts metadata display (stars/version for assets vs. dataset counts/modification date for projects).\n* **Integrated Actions**: Supports an optional primary action pill (INSTALL, SELECT, OPEN).\n* **Identity States**: Visually flags \"Installed\" or \"Active\" items via CSS class toggles.\n\n=== Architecture\n\nThe system consists of two parts:\n\n1. **TypeScript Generator** (`src/ui/components/LCARSFrame.ts`)\n   - Creates DOM structures for LCARS frames\n   - Handles panel configuration and layout\n   - Exposes utility functions to window for HTML event handlers\n\n2. **CSS Design System** (`dist/css/lcars-components.css`)\n   - Defines base styles using CSS custom properties\n   - Computes color shades via HSL\n   - Handles responsive breakpoints\n\n=== The Hue-Based Color System\n\nAll LCARS component colors derive from a single `--lcars-hue` value (0-360). The CSS automatically computes four shade variants:\n\n[source,css]\n----\n.lcars-frame {\n    --lcars-hue: 200;           /* Blue family */\n    --lcars-sat: 70%;\n    --lcars-light-1: 75%;       /* Lightest */\n    --lcars-light-2: 65%;\n    --lcars-light-3: 55%;\n    --lcars-light-4: 45%;       /* Darkest */\n\n    /* Computed shades */\n    --lcars-shade-1: hsl(var(--lcars-hue), var(--lcars-sat), var(--lcars-light-1));\n    --lcars-shade-2: hsl(var(--lcars-hue), var(--lcars-sat), var(--lcars-light-2));\n    /* ... */\n}\n----\n\n.Predefined Hue Values\n[cols=\"1,1,2\"]\n|===\n|Name |Hue |Usage\n\n|BLUE/SKY |200 |Default marketplace assets\n|ORANGE |30 |Main application frame\n|GREEN/FDA |140 |FDA regulatory tools\n|PURPLE/NEBULA |270 |Special categories\n|RED/MARS |0 |Alerts, warnings\n|GOLD |45 |Highlights\n|===\n\n=== LCARS Frame Structure\n\nA complete LCARS frame consists of four grid areas:\n\n----\n╭━━━━━━━━━━╮━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n┃  ELBOW   ┃  TOP BAR (title + actions)\n┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n┃ PANEL 1  ┃\n┃──────────┃  CONTENT AREA\n┃ PANEL 2  ┃  (scrollable)\n┃──────────┃\n┃ PANEL 3  ┃\n┃ [spacer] ┃\n┃ PANEL N  ┃  ← corner radius\n╰━━━━━━━━━━╯─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─\n----\n\n* **Elbow**: Curved corner piece connecting top bar to sidebar\n* **Top Bar**: Horizontal header with title, metadata, and action buttons\n* **Sidebar**: Vertical stack of navigation panels (same width, varying heights/shades)\n* **Content**: Main scrollable content area\n\n=== Panel Design Principles\n\nLCARS panels follow strict design rules:\n\n1. **Uniform Width**: All sidebar panels are the same width. Visual variety comes from color and height, not width.\n2. **Shade Cycling**: Panels alternate through shade variants (1-4) for visual rhythm\n3. **Height Variants**: Panels can have different heights (`tall`, `medium`, `short`)\n4. **Corner Radii**: Only the elbow (top-left) and bottom panel (bottom-left) have rounded corners\n5. **Text Alignment**: Panel labels align right (LCARS convention for left sidebars)\n6. **Spacer Element**: A colored spacer fills remaining height between panels and the bottom corner\n\n=== Usage Example\n\n**HTML Structure:**\n[source,html]\n----\n<div class=\"lcars-frame\" style=\"--lcars-hue: 200;\">\n    <div class=\"lcars-elbow\"></div>\n    <div class=\"lcars-top-bar\">\n        <h1>Title</h1>\n        <button class=\"close-btn\">CLOSE</button>\n    </div>\n    <div class=\"lcars-sidebar\">\n        <a class=\"lcars-panel\" data-shade=\"1\" data-height=\"tall\">SECTION 1</a>\n        <a class=\"lcars-panel\" data-shade=\"2\">SECTION 2</a>\n        <a class=\"lcars-panel\" data-shade=\"3\">SECTION 3</a>\n        <div class=\"lcars-sidebar-spacer\" data-shade=\"4\"></div>\n        <a class=\"lcars-panel lcars-corner-bl\" data-shade=\"1\">SECTION N</a>\n    </div>\n    <div class=\"lcars-content\">\n        <!-- Scrollable content -->\n    </div>\n</div>\n----\n\n**Dynamic Theming (TypeScript):**\n[source,typescript]\n----\n// Change color scheme at runtime\nconst frame = document.getElementById('my-lcars-frame');\nframe.style.setProperty('--lcars-hue', '140');  // Switch to green\n----\n\n=== Marketplace Integration\n\nThe Asset Detail Overlay demonstrates the \"Floating Command Module\" pattern, where critical actions are decoupled from the information display to maximize screen real estate and mimic hardware controls.\n\n==== Visual Style: PADD Aesthetic\nThe asset tiles and detail frames use an asymmetrical \"PADD\" (Personal Access Display Device) geometry:\n* **Thick Top Bar:** 10px solid accent bar (Sky Blue or FDA Green).\n* **Rounded Corner:** Bottom-right corner has a 24px radius (`border-radius: 0 0 24px 0`), creating a distinct physical shape.\n* **No Borders:** Replaced thin outlines with deep contrast backgrounds and shadow glows.\n\n==== Floating Command Pills\nAction buttons are removed from the internal content area and placed in a dedicated **Command Column** to the right of the main panel.\n\n* **Structure:**\n  [source,html]\n  ----\n  <div class=\"detail-layout\">\n      <!-- Main Information Display -->\n      <div class=\"detail-panel\">...</div>\n\n      <!-- Floating Command Column -->\n      <div class=\"detail-command-column\">\n          <button class=\"pill-btn close-pill\">CLOSE</button>\n          <button class=\"pill-btn install-pill\">INSTALL</button>\n      </div>\n  </div>\n  ----\n* **Dynamic Coloring:** The INSTALL pill automatically inherits the asset's hue (Blue vs. FDA Green) via CSS variables.\n* **Status Feedback:** The INSTALL pill contains a progress bar overlay and status text (`READY` -> `INSTALLING` -> `INSTALLED`).\n\n==== Color Coding\n* **Standard Assets:** `--lcars-hue: 200` (Sky Blue)\n* **FDA Regulatory Tools:** `--lcars-hue: 140` (Green)\n* **Close Actions:** `var(--mars)` (Red)\n\n[source,typescript]\n----\n// In marketplace/view.ts\nconst hue = asset.type === 'fda' ? 140 : 200;\nlcarsFrame.style.setProperty('--lcars-hue', String(hue));\n----\n\n== Interactive Affordances: The Beckon Pulse\n\nIn Michael Okuda's original LCARS designs for The Next Generation, instrument panels were never entirely static. Panels flickered, shifted, and cycled through subtle brightness changes to suggest ongoing background system activity. This visual \"life\" served a dual purpose: it made the interface feel like a living system, and it drew attention to active controls without explicit labels or iconography.\n\nARGUS adopts this principle as a formal visual language pattern called the **Beckon Pulse**. Any interactive element that lacks an obvious affordance (no label, no icon, no conventional button shape) uses a slow brightness oscillation to signal \"interact with me.\"\n\n=== The Pattern\n\nThe Beckon Pulse is a `3-3.5s` CSS animation that oscillates `filter: brightness()` between `1.0` and `1.15-1.25`, with an optional `box-shadow` glow. The effect is subtle enough to register in peripheral vision without demanding attention. On hover, the animation stops and the element shows a static highlight, confirming interactivity.\n\n=== Variants\n\n[cols=\"1,2,2\"]\n|===\n| Variant | Animation | Usage\n\n| `lcars-beckon-orange`\n| brightness 1.0 → 1.15, soft orange glow\n| Open/activate controls (e.g., `bar-6` terminal opener)\n\n| `lcars-beckon-mars`\n| brightness 1.0 → 1.25, red glow intensifies\n| Close/dismiss controls (e.g., terminal close pill)\n\n| `.lcars-beckon` (utility class)\n| Applies `lcars-beckon-orange` by default\n| Any generic interactive element\n|===\n\n=== Contextual Activation\n\nBeckon animations are **context-sensitive**: they only pulse when the affordance is relevant. For example, `bar-6` (the terminal opener) beckons only when the terminal is closed. Once the terminal is open, bar-6 stops pulsing — the user's attention should shift to the terminal content and its close control, which now takes over the beckon duty.\n\nThis prevents **pulse fatigue**: the visual rhythm of the interface changes as the user navigates, with different elements beckoning at different moments rather than everything pulsing simultaneously.\n\n=== CSS Usage\n\n[source,css]\n----\n/* Apply via utility class */\n.my-interactive-element {\n    /* ... */\n}\n.my-interactive-element.lcars-beckon {\n    animation: lcars-beckon-orange 3.5s ease-in-out infinite;\n}\n.my-interactive-element.lcars-beckon:hover {\n    animation: none;\n}\n\n/* Or apply a specific variant directly */\n.my-close-button {\n    animation: lcars-beckon-mars 3s ease-in-out infinite;\n}\n----\n\n=== Toggling via JavaScript\n\n[source,typescript]\n----\n// Start beckoning\nelement.classList.add('lcars-beckon');\n\n// Stop beckoning (e.g., when the associated panel is open)\nelement.classList.remove('lcars-beckon');\n----\n\n== Implementation Details\n\n* **Global Component**: The `LCARSTerminal` is a global singleton.\n* **Intent Parsing**: The `terminalCommand_handle()` dispatcher in `argus.ts` routes commands to `workflowCommand_handle()` (search/add/review/mount/simulate) and `aiQuery_handle()` (LLM queries). AI responses are parsed by `aiResponse_process()` to trigger system actions (selecting data, transitioning stages).\n* **Contextual Awareness**: The AI engine receives the full dataset catalog and the user's current \"Selection Buffer\" with every query, ensuring high-fidelity RAG (Retrieval Augmented Generation) reasoning.\n* **LCARS Frame Generator**: The `lcarsFrame_create()` function and related utilities are exposed on the `window` object for use in HTML event handlers.",
    "marketplace.adoc": "= ATLAS Marketplace Specification (v3.5.0)\n:toc:\n:toclevels: 3\n\n== 1. Overview\nThe ATLAS Marketplace is a global asset registry providing ChRIS plugins (MERIDIAN apps), reference datasets, pre-trained models, annotation tools, and FDA regulatory tools. It serves as the primary distribution channel for extending the capabilities of an ARGUS instance.\n\n== 2. Asset Types\n\n[cols=\"1,2,2\"]\n|===\n| Type | Description | VCS Impact\n\n| `plugin`\n| Containerized MERIDIAN/ChRIS applications.\n| Installed to `/bin/<plugin-name>` with executable stub content.\n\n| `dataset`\n| Standalone reference cohorts for local validation.\n| Installed to `/data/sets/<dataset-name>/manifest.json`.\n\n| `model`\n| Pre-trained neural network weights (e.g., ResNet, UNet).\n| Installed to `~/models/<model-name>/README.md` with model card.\n\n| `annotation`\n| Annotation tools and label schemas.\n| Installed to `/data/annotations/<tool-name>/manifest.json`.\n\n| `fda`\n| FDA regulatory compliance tools.\n| Dual install: `/bin/<tool-name>` + `/data/annotations/<tool-name>/`.\n\n| `workflow`\n| Federated learning workflow templates.\n| Installed to `~/workflows/<workflow-name>/manifest.json`.\n|===\n\n== 3. Installation Lifecycle\n\nThe Marketplace is a **Public Service** (accessible without authentication) but requires an active session for VCS integration.\n\n1.  **Browse:** Users explore the high-density grid. Filter by type, search by name/description/author, sort by stars/name/size.\n2.  **Install:** Clicking \"INSTALL\" triggers a progress animation (1.5s).\n3.  **Store Action:** The button calls `store.asset_install(id)`, which adds the asset ID to `state.installedAssets`.\n4.  **Provider Dispatch:** The `MarketplaceProvider.asset_install()` translates the asset into VCS filesystem entries at the appropriate paths (see table above). Each entry includes content generators for manifest files, executable stubs, and model cards.\n5.  **Terminal Notification:** The Intelligence Console confirms availability and provides usage hints.\n\n== 4. Architectural Integration\nThe Marketplace is decoupled from the SeaGaP workflow. It operates as a modal overlay driven by the central `Store` and `EventBus`. The overlay slides in from the right (Slide-In Overlay animation pattern, see `docs/visual_language.adoc`).\n\n=== Key Files\n\n[cols=\"1,2\"]\n|===\n| File | Purpose\n\n| `src/marketplace/view.ts`\n| Marketplace UI: grid rendering, filtering, sorting, search, detail overlay, install handlers.\n\n| `src/core/data/marketplace.ts`\n| `MARKETPLACE_ASSETS` registry of 400+ assets with metadata.\n\n| `src/vfs/providers/MarketplaceProvider.ts`\n| Translates assets into VCS filesystem trees with content generators.\n|===\n\n=== Detail Overlay\nClicking an asset card opens a full detail overlay with:\n\n* LCARS frame with hue-based color coding (blue for standard, green for FDA)\n* Floating Command Column with INSTALL and CLOSE pills\n* Specifications, usage commands, dependencies, changelog, related assets\n\nSee `docs/lcars.adoc` for the Floating Command Module visual pattern.",
    "merkle-engine.adoc": "= Merkle Engine: The Cryptographic Conscience of State\n:author: ATLAS Project Team\n:revdate: 2026-02-20\n:revnumber: 10.3.0\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe Merkle Engine is the authoritative mechanism for data-state integrity within the ARGUS v10.0 architecture. It implements a recursive, Directed Acyclic Graph (DAG)-aware fingerprinting protocol that cryptographically anchors every workflow artifact to its specific logical provenance. This specification details the mathematical model of the Merkle provenance chain, the structural schema of the `ArtifactEnvelope`, and the deterministic algorithms for branch-aware staleness detection. By transforming the filesystem into a verifiable ledger, the Merkle Engine provides the \"Conscience\" required to ensure scientific reproducibility in AI-mediated research environments.\n\n== Introduction: The Problem of Assertion Drift\n\n=== The \"I Did It\" Fallacy\nIn early versions of ARGUS, stage completion was tracked via in-memory booleans. This led to the \"Assertion Drift\" failure mode, where an AI assistant or a monolithic service would claim that a task was finished based on a successful function return, even if the resulting data was inconsistent or the underlying filesystem had been manually tampered with. There was no physical link between the *process* and the *product*.\n\n=== The Resolution: Materialized Proof of Work\nThe v10.0 architecture resolves this by mandating that \"Truth is a Property of the Disk.\" The Merkle Engine ensures that no stage is considered \"Complete\" unless it possesses a cryptographically anchored artifact. This shift moves the system from trusting transient memory to verifying physical evidence. The engine functions as a continuous background auditor, ensuring that the system's logical position is always mathematically synchronized with the physical project tree.\n\n== The Mathematical Model: Recursive Fingerprinting\n\nThe core of the Merkle Engine is the SHA-256 fingerprinting protocol. Unlike standard file hashing, the Merkle Engine incorporates the **Topological Lineage** of the artifact.\n\n=== The Fingerprint Function\nFor any given stage $n$ in the workflow DAG, the fingerprint $H_n$ is calculated as:\n$$H_n = \\text{SHA-256}(Data_n + \\sum_{p \\in Parents} H_p)$$\nWhere:\n*   $Data_n$: The serialized JSON payload produced by the stage's Guest Plugin.\n*   $H_p$: The current fingerprints of all immediate parent nodes defined in the workflow manifest.\n\n=== The Chain of Integrity\nThis recursive definition ensures that if any upstream artifact is modified, deleted, or re-executed (creating a new branch), its hash changes. This change propagates through the formula, invalidating the fingerprints of every downstream stage. This \"Topological Invalidation\" is the primary defense against the use of inconsistent or outdated data in high-stakes training loops.\n\n== The Artifact Envelope Schema\n\nEvery piece of work produced by an ARGUS plugin is wrapped in an `ArtifactEnvelope` before being materialized to the VFS. This envelope (defined in `src/lcarslm/MerkleEngine.ts`) provides the metadata required for recursive verification.\n\n[source,json]\n----\n{\n  \"stage\": \"harmonize\",\n  \"timestamp\": \"2026-02-17T14:30:00Z\",\n  \"parameters_used\": {\n    \"resolution\": [1.0, 1.0, 1.0]\n  },\n  \"content\": {\n    \"modality\": \"histology\",\n    \"steps\": [\"scan\", \"standardize\"]\n  },\n  \"_fingerprint\": \"850daa6...\",\n  \"_parent_fingerprints\": {\n    \"gather\": \"2baca4d...\"\n  }\n}\n----\n\n== Branch-Aware Staleness Detection\n\nThe Merkle Engine enables the system to support non-linear \"Branching\" without losing provenance.\n\n=== The Detection Algorithm\nWhen the `WorkflowAdapter` (see `docs/dag-engine.adoc`) queries the state of a stage, it invokes the Merkle Engine to perform a **Staleness Check**:\n1.  **Load Local Envelope**: Read the artifact from the current VFS path.\n2.  **Verify Parentage**: Compare the values stored in `_parent_fingerprints` against the *current* latest fingerprints of parent stages in the session tree.\n3.  **Flag Drift**: If any parent fingerprint mismatch is detected, the stage is flagged as `[STALE]`.\n\n=== The User Experience of Staleness\nIn the LCARS UI, stale stages are marked with an asterisk (`*`). This provides the researcher with immediate visual confirmation that their current work is no longer grounded in the latest upstream data, preventing the \"Garbage In, Garbage Out\" failure mode.\n\n== v10.3 Runtime Notes\n\n*   **Single canonical materialization path:** Runtime writes are always routed\n    through `SessionStore` path semantics (store/join model).\n*   **Root-stage overwrite policy:** Root stages update in place on re-execution\n    instead of creating branch directories.\n*   **Optional-parent filtering:** Multi-parent JOIN materialization excludes optional\n    parents that are unresolved, preventing unnecessary join nesting.\n*   **Deletion pass cleanup:** Legacy runtime materialization mode toggles and join\n    materialization toggles were removed from active runtime configuration.\n\n== Conclusion\n\nThe Merkle Engine is the fundamental mechanism that transforms ARGUS from a conversational interface into a scientifically rigorous operating system. By grounding every state transition in a recursive cryptographic proof, the engine ensures that the provenance of every federated model is immutable and auditable. It provides the \"Substrate of Integrity\" that allows researchers to trust that their results are a direct and valid consequence of their documented scientific process.\n\n---\n_Last updated: 2026-02-20 (v10.3.0)_",
    "onboarding.adoc": "= ARGUS Developer Onboarding Guide\n:author: ATLAS Project Team\n:revdate: 2026-02-18\n:revnumber: 10.0.1\n:toc:\n:sectnums:\n\n== Welcome to ARGUS\n\nARGUS (ATLAS Resource Guided User System) is the UI layer for the ATLAS federated medical imaging platform. It is a **Vanilla TypeScript** application that implements the SeaGaP-MP workflow (Search, Gather, Process, Monitor, Post).\n\n**The Golden Rule:** There is no framework (React, Vue, Svelte). We use raw DOM manipulation, orchestrated by a custom Pub/Sub Store and strict architectural patterns.\n\n== The Mental Model\n\nTo work on ARGUS, you need to understand three core concepts:\n\n=== The Store is Truth\n\nEverything that changes (current stage, selected datasets, training status) lives in `src/core/state/store.ts`.\n\n*   **Don't** mutate state directly.\n*   **Do** call Store actions (e.g., `store.dataset_select(id)`).\n*   **Do** listen for events (e.g., `events.on(Events.STATE_CHANGED, ...)`).\n\n=== The Virtual Computer (VCS)\n\nARGUS isn't just a website; it simulates a computer.\n\n*   It has a filesystem (`src/vfs/`).\n*   It has a shell (`src/vfs/Shell.ts`) with environment variables (`$HOME`, `$PWD`).\n*   It has a terminal.\n\n**Key Concept:** \"Providers\" bridge the gap. When you select a dataset in the UI, the `DatasetProvider` effectively \"mounts\" that data into the virtual filesystem at `~/data/cohort/`.\n\n=== The Stage Lifecycle\n\nThe app moves through stages (Search -> Gather -> Process -> Monitor -> Post).\n\n*   **Entry Point:** `src/argus.ts` is the orchestrator.\n*   **Lifecycle:** Each stage module (e.g., `src/core/stages/process.ts`) exports `stage_enter()` and `stage_exit()` hooks.\n*   **Control Flow:** The orchestrator calls `currentStage.stage_exit()` -> `nextStage.stage_enter()`.\n\n=== SeaGaP Boundary Model (Search vs Gather)\n\nKeep these boundaries strict when implementing features:\n\n*   **Search (Discovery):** Query/filter catalog data and publish discovery results.\n*   **Gather (Assembly):** Select datasets, mount cohort inputs, and manage gather workspace/detail flows.\n*   **Rule of thumb:** Search finds candidates; Gather commits cohort intent.\n\nIf a change touches project/dataset detail overlays, gather workspace transitions, or cohort selection state, it is Gather work even if initiated from a Search-stage click.\n\n== Codebase Tour\n\n[cols=\"1,3\"]\n|===\n| Path | What's Inside\n\n| `src/argus.ts`\n| **The Orchestrator.** Initializes the app, sets up the VCS, and handles high-level events. Keep this file clean.\n\n| `src/lcars-framework/`\n| **The UI Library.** Reusable LCARS components (Terminal, WorkflowTracker) that know *nothing* about ARGUS business logic.\n\n| `src/core/state/`\n| **The Brain.** `store.ts` (state) and `events.ts` (pub/sub bus).\n\n| `src/core/logic/`\n| **The Logic Layer.** Specialized services like `commands.ts` (routing), `WindowBindings.ts` (DOM glue), and `Lifecycle.ts`.\n\n| `src/core/syntax/`\n| **Language Registry.** Canonical syntax-language detection/mapping shared by browser and TUI highlighting.\n\n| `src/core/stages/`\n| **The Scenes.** Stage entry modules (`search.ts`, `gather.ts`, `process.ts`, ...) plus stage-scoped subdirectories for controllers/actions/ui/runtime.\n\n| `src/vfs/`\n| **The Computer.** The virtual filesystem, shell, and content generators.\n\n| `src/lcarslm/`\n| **The AI.** Service for communicating with Gemini/OpenAI (RAG logic).\n|===\n\n== Rules of the Road\n\n=== Naming: RPN (Reverse Polish Notation)\n\nWe use `object_method` naming to group related functionality.\n\n*   ✅ `project_load()`, `dataset_select()`, `terminal_toggle()`\n*   ❌ `loadProject()`, `selectDataset()`, `toggleTerminal()`\n\n=== The Slot Pattern\n\nWe avoid rewriting `innerHTML` for complex overlays.\n\n*   The `#asset-detail-overlay` has empty \"slots\" (`#overlay-content-slot`).\n*   When you open a Project Detail, you simply **show** the slot and **render** into it.\n*   When you close it, you **clear** the slot.\n*   *Never* touch the original Marketplace DOM that shares the overlay.\n\n=== Window Bindings\n\nHTML `onclick=\"myFunc()\"` requires `myFunc` to be on `window`.\n\n*   **Don't** just say `(window as any).myFunc = ...`\n*   **Do** register it in `src/core/logic/WindowBindings.ts`.\n\n=== Plugin/Stage Boundary\n\nPlugins must remain surface-agnostic.\n\n*   **Do:** Return typed `PluginResult` payloads (`statusCode`, `message`, `actions`, `artifactData`).\n*   **Do:** Keep browser/TUI-specific rendering in stage/controller/view modules.\n*   **Don't:** Import `src/core/stages/*` or `src/core/logic/*` from `src/plugins/*`.\n*   **Enforcement:** Run `npm run check:boundaries` before merge.\n\nSee `docs/plugins.adoc` for the runtime contract and `docs/architecture.adoc` for ownership rationale.\n\n=== Shell/Rendering Boundary\n\nKeep this responsibility split explicit:\n\n*   **Shell owns execution** (`src/vfs/Shell.ts`): command semantics, stdout/stderr, exit codes.\n*   **Registry owns language mapping** (`src/core/syntax/languageRegistry.ts`): file/`cat` detection and alias normalization.\n*   **WUI owns HTML rendering** (`src/core/logic/commands.ts`, `src/ui/syntaxHighlight.ts`).\n*   **TUI owns ANSI rendering** (`src/calypso/ui/tui/TuiRenderer.ts`, `src/calypso/ui/tui/SyntaxHighlight.ts`).\n\nDo not add independent extension/language maps in renderer modules. Add mappings once in the registry and reuse everywhere.\n\n== \"Hello World\": Adding a Command\n\nWant to add a new command called `hello` to the terminal?\n\n1.  **Edit `src/core/logic/commands.ts`**:\n    Route commands through `CalypsoCore.command_execute(...)` (already wired by default).\n    New deterministic workflow behavior should be added in `src/lcarslm/CalypsoCore.ts`.\n\n[source,typescript]\n----\n// CalypsoCore.ts\nif (primaryCommand === 'hello') {\n    return {\n        success: true,\n        message: 'Hello, World!',\n        actions: []\n    };\n}\n----\n\nThe terminal router delegates to CalypsoCore first, then falls back to the LLM when no first-class intent matches.\n\n== \"Hello World\": Adding a Stage\n\n1.  **Create `src/core/stages/mystage.ts`**:\n    Implement `stage_enter()` and `stage_exit()`.\n\n2.  **Register in `src/argus.ts`**:\n    Import it and add it to `STAGE_HANDLERS`.\n\n3.  **Update Navigation**:\n    Add it to `STAGE_ORDER` in `src/core/logic/navigation.ts`.\n\n== Further Reading\n\n*   **`docs/framework.adoc`**: Detailed guide to the patterns mentioned above.\n*   **`docs/vcs.adoc`**: Deep dive into how the Virtual Filesystem works.\n*   **`docs/shell.adoc`**: Shell execution model and cross-surface syntax-rendering contract.\n*   **`docs/architecture.adoc`**: High-level system design.\n*   **`docs/plugins.adoc`**: Host/Guest plugin contract and boundary rules.\n*   **`docs/philosophy.adoc`**: SeaGaP conceptual model and stage semantics.",
    "oracle.adoc": "= ORACLE: Reflexive Verification by Materialized Evidence\n:author: ATLAS Project Team\n:revdate: 2026-02-20\n:revnumber: 2.2.0\n:toc: macro\n:toclevels: 4\n:sectnums:\n:icons: font\n\ntoc::[]\n\n== Abstract\n\nORACLE is the verification discipline used by ARGUS to test AI-mediated workflows\nwithout depending on conversational phrasing. The method drives the system through\nits normal command surface and asserts outcomes against protocol status and\nartifact materialization in the virtual filesystem. This converts verification from\nlanguage matching to state-proof validation.\n\nThe current specification reflects join-aware workflow semantics and fast-mode test\noperation under plugin-owned latency policy.\n\n== Historical Context\n\nPre-v10 testing emphasized English-response expectations. That model was brittle by\nconstruction because harmless narrative changes could fail tests while real\nregressions escaped when output phrasing happened to match. As ARGUS moved toward\nMerkle-grounded execution, testing had to move with it.\n\nORACLE emerged from that pressure as a reflexive method: the same conversational\nentry surface is used to trigger behavior, but correctness is judged by deterministic\nstate transitions and physical artifact evidence.\n\n== Oracle Walk Figure\n\n[source,text]\n----\n┌──────────────────────────┐\n│ SEND COMMAND             │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ RECEIVE RESPONSE         │\n│ statusCode + actions     │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ ASSERT STATUS CODE       │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ ASSERT ARTIFACT PATHS    │\n│ filesystem existence     │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ ADVANCE TO NEXT STEP     │\n└────────────┬─────────────┘\n             └──────────────▶ loop until scenario complete\n----\n\n== Contractual Walk Model\n\nA walk is a topological scenario that issues commands in sequence and validates\neach step against status protocol and materialization evidence. The runner sends a\ncommand, reads the structured response, checks the status contract, and then checks\nfilesystem evidence for the expected artifacts. The loop continues until scenario\ncompletion, ensuring end-to-end coherence across interpretation, dispatch, and\nmaterialization layers.\n\nVariable interpolation allows one scenario definition to remain portable across\nsessions and project renames. Session and project placeholders are re-resolved from\nruntime state after each step, so path assertions remain anchored to current\ncontext.\n\n== Runner Semantics\n\nThe oracle runner operates in fast mode by setting `CALYPSO_FAST=true`. This keeps\nplugin behavior logically equivalent while removing plugin-side delay for stable and\ndeterministic throughput. Backend runtime contains no synthetic sleep paths, so fast\nmode is applied exactly where simulation can exist.\n\nWhen workflow policy emits blocked states requiring confirmation, the runner handles\nthat handshake within the same scenario so policy enforcement and continuation logic\nare both tested. Conversational success states remain valid for steps explicitly\ndefined as non-mutating guidance interactions.\n\n== JOIN-Aware Verification\n\nWith join materialization semantics, optional-parent bypass is no longer an\ninvisible controller choice. When a walk advances past an optional stage, runtime\nmay materialize skip evidence and then continue execution. ORACLE validates the same\nartifact-grounded contract used by regular stage completion, which means optional\nresolution is now testable lineage behavior rather than implicit control flow.\n\nThis distinction is critical for rename-sensitive workflows. Linear walks and\nrename-explicit walks now diverge intentionally in artifact paths and ordering\nsemantics, and ORACLE captures that divergence as expected behavior rather than as\ntest fragility.\n\n== Scenario Coverage Posture\n\nThe suite is organized as pressure walks across canonical progression, branching,\nout-of-order safety, staleness propagation, and anaphora-sensitive command\nresolution. Coverage is designed to stress the exact surfaces where language,\ntopology, and provenance can diverge.\n\nBy asserting on status and physical artifacts together, ORACLE can detect both\nfalse-positive language success and silent data-state regressions.\n\n== Architectural Outcome\n\nORACLE turns conversational execution into scientifically auditable verification.\nIts value is not that it speaks to the system like a user; its value is that it\nrefuses to trust language without materialized proof. This makes it the primary\nintegrity backstop for ARGUS release hardening.\n\n---\n_Last updated: 2026-02-20 (v2.2.0)_",
    "philosophy.adoc": "= ARGUS Philosophy: The Doctrine of Data-State Grounding\n:author: ATLAS Project Team\n:revdate: 2026-02-18\n:revnumber: 10.0.0\n:toc: macro\n:toclevels: 3\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe design philosophy of ARGUS is centered on the principle of **Data-State Grounding**—the architectural mandate that the authoritative state of a scientific workflow must be a verifiable property of the filesystem. This document outlines the conceptual framework of ARGUS, detailing the SeaGaP-MP workflow model and the engineering rationale for grounding AI-mediated interactions in physical, Merkle-proven artifacts.\n\n== Introduction: The Historical Context\n\nThe development of ARGUS emerged from the unique challenge of building national-scale infrastructure for federated learning in healthcare. Early attempts at agentic interfaces in this domain often suffered from a lack of \"environmental grounding.\" In these legacy systems, AI assistants would frequently lose track of complex, multi-stage processes because the workflow state was maintained only in ephemeral memory or transient database rows. This led to \"contextual drift,\" where the AI would confidently recommend next steps based on incorrect premises about what work had actually been completed.\n\nWe learned that for high-stakes medical research, \"Truth\" cannot be an assertion; it must be evidence. The resolution was the adoption of the **SeaGaP-MP** framework (Search, Gather, Process, Monitor, Post) combined with a data-state-centric compute model inherited from the ChRIS platform. In ARGUS, progress is not tracked by internal counters, but by the physical materialization of artifacts within a Virtual File System (VFS). This philosophy ensures that the system's logic is always anchored to the physical reality of the project tree.\n\n== SeaGaP-MP Figure\n\n[source,text]\n----\n┌────────┐     ┌────────┐     ┌─────────┐     ┌─────────┐     ┌──────┐\n│ SEARCH │────▶│ GATHER │────▶│ PROCESS │────▶│ MONITOR │────▶│ POST │\n└────────┘     └────────┘     └─────────┘     └─────────┘     └──────┘\n     │              │              │               │              │\n     └──────────────┴──────────────┴───────────────┴──────────────┘\n          progress is recognized via materialized evidence, not assertions\n----\n\n== The SeaGaP-MP Workflow Framework: The Structural Spine\n\nTo manage the inherent complexity of federated medical imaging, ARGUS enforces a unifying interaction pattern called SeaGaP-MP. This framework provides a consistent \"spine\" across all user personas, from researchers to clinicians.\n\n1.  **Search:** The exploratory phase where users query the ATLAS catalog to discover relevant datasets.\n2.  **Gather:** The assembly phase where selected resources are mounted into a virtual workspace and cost estimates are generated.\n3.  **Process:** The execution phase where domain-specific work—such as code development, annotation, or inference—is performed.\n4.  **Monitor:** The observation phase where users track real-time telemetry from distributed sites.\n5.  **Post:** The finalization phase where results are validated and published back to the community.\n\nBy standardizing on this sequence, ARGUS makes diverse research tasks tractable and ensures that the provenance of every scientific result is captured through a predictable chain of custody.\n\n=== Search and Gather Are Not the Same Stage\n\nA recurring source of architectural drift is treating Search and Gather as a single \"discovery-and-commit\" step. ARGUS explicitly forbids that collapse.\n\n*   **Search answers:** \"What exists?\"\n*   **Gather answers:** \"What are we committing into this project?\"\n\nThe distinction matters because the first question is informational, while the second mutates project-scoped workflow state. Conflating them weakens provenance and obscures scientific intent.\n\nFor implementation boundaries, see link:architecture.adoc[System Architecture], link:plugins.adoc[Plugin System], and link:framework.adoc[Framework Patterns].\n\n== User Personas: Diverse Goals, Unified Pattern\n\nWhile the SeaGaP-MP sequence is universal, the content of each stage is adapted to specific personas.\n\n*   **Federated ML Developer:** Focuses on high-fidelity coding environments and the transformation of local training loops into federated \"Phantom\" simulations.\n*   **Annotator:** Prioritizes ergonomic image navigation and the consistent application of clinical labels.\n*   **Administrator:** Requires visibility into platform governance, audit logs, and resource allocation.\n\nThe architecture ensures that despite these varying needs, the underlying state transformations remain consistent. Every persona's progress is grounded in the same VFS-based materialization pipeline, making the system universally verifiable.\n\n== Data-State Computation: The ChRIS Lineage\n\nARGUS is the interface to a platform whose compute model is fundamentally data-state-centric. This model, inherited from the ChRIS platform, represents computation as a Directed Acyclic Graph (DAG) where each node is a mortal container that consumes `/input` and produces `/output`.\n\nIn ARGUS, we extend this principle to the UI layer. The system reasons about workflow progress by inspecting the physical state of the session tree—checking for the existence of Merkle-proven artifact envelopes for stages like harmonization, code scaffolding, and federation. This eliminates the \"whack-a-mole\" bug cycle associated with in-memory state tracking and provides the LLM with a \"Ground Truth\" context derived directly from the immutable session ledger.\n\n== Conclusion\n\nThe ARGUS philosophy ensures that the system remains a \"Guardian of Process.\" By grounding all interactions in a standardized workflow and a persistent filesystem substrate, we create a bridge between human intent and federated complexity that is both intuitive and scientifically rigorous. The move to v10.0 completes this vision, providing an environment where every claim made by the AI is backed by a cryptographically anchored artifact.\n\n---\n_Last updated: 2026-02-18 (v10.0.0)_",
    "plugins.adoc": "= ARGUS Plugin System: Guest Compute Under Host Integrity\n:author: ATLAS Project Team\n:revdate: 2026-02-21\n:revnumber: 10.3.1\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe plugin system is the compute layer of ARGUS. It isolates domain behavior from\nkernel orchestration by executing workflow logic as stateless guest modules loaded\nthrough manifest handlers. This architecture allows persona evolution without\nkernel rewrites and keeps provenance control centralized in host runtime.\n\nThis specification captures the post-hardening state in which federation phases are\nalso plugin materialized, backend latency simulation is removed, and handler\nownership is resolved through dynamic convention rather than static backend tables.\n\n== Historical Context\n\nBefore the plugin VM boundary stabilized, workflow logic lived in shared core\npaths. That coupling made behavior difficult to reason about because stage-specific\nchanges could affect unrelated flows. It also weakened verification boundaries by\nmixing compute decisions with orchestration control.\n\nThe v10 pivot moved logic into plugins, and the 10.2 to 10.3 hardening passes\nremoved remaining internalized surfaces so plugin ownership became real rather than\npartial.\n\n== Plugin Boundary Figure\n\n[source,text]\n----\n                    ┌────────────────────────────────────┐\n                    │           PLUGIN CONTEXT           │\n                    │ vfs | shell | store | ui telemetry│\n                    └─────────────────┬──────────────────┘\n                                      │\n                                      ▼\n                             ┌────────────────┐\n                             │ PLUGIN VM      │\n                             │ src/plugins/*  │\n                             └───────┬────────┘\n                                     │ PluginResult\n                                     ▼\n                             ┌────────────────┐\n                             │ CALYPSO HOST   │\n                             └───────┬────────┘\n                                     ▼\n                             ┌────────────────┐\n                             │ MERKLE ENGINE  │\n                             └────────────────┘\n\nforbidden import direction:\nsrc/plugins/*  ─X─▶  src/core/stages/*, src/core/logic/*\n----\n\n== Host and Guest Contract\n\n`PluginHost` loads handler modules dynamically according to manifest-declared\nhandler names and validates runtime exports before execution. The host constructs a\ntyped `PluginContext`, invokes `plugin_execute`, receives a typed `PluginResult`,\nand then performs host-owned materialization through Merkle layers.\n\nThis lifecycle keeps guest modules transient and stateless from the kernel\nperspective. Plugins do work. Hosts witness and record outcomes.\n\n== Capability Surface\n\nGuest code receives only bounded capabilities through `PluginContext`, including\nproject-scoped VFS and shell access, store interaction surfaces, and telemetry\nprimitives. Plugins do not import browser-stage modules or core orchestration\ninternals. Boundary enforcement is automated by dependency checks in the standard\nbuild and test gates.\n\nTelemetry follows the same separation doctrine. Plugins emit primitive progress and\nmessage events; host/server layers transport those events; adapters render them in\nsurface-specific form. Narrative ownership remains with plugins, while geometry and\npresentation remain adapter concerns.\n\n[source,text]\n----\n┌──────────────────┐   ┌──────────────────┐   ┌──────────────────┐   ┌──────────────────┐\n│ PLUGIN (guest)   │──▶│ TELEMETRY BUS    │──▶│ CALYPSO SERVER   │──▶│ SURFACE ADAPTERS │\n│ ui.progress(...) │   │ host-local pipe  │   │ websocket frames │   │ tui / web render │\n└──────────────────┘   └──────────────────┘   └──────────────────┘   └──────────────────┘\n----\n\nOperationally this means plugin code should emit monotonic progress percentages for\nlong loops and avoid UI-specific assumptions. The CLI adapter rewrites a single\nactive progress row using glyph bars (`█`/`░`) and the web adapter renders equivalent\nstate through its own view model. Plugins describe work; adapters choose geometry.\n\n== Materialization and Provenance\n\nPlugins return result payloads containing status and optional artifact data. They do\nnot self-certify completion by writing session ledger artifacts directly. Calypso\ncaptures result payloads, applies lineage hashing, and writes materialized evidence\nthrough the Merkle path. This preserves one authoritative provenance witness and\nprevents guest code from bypassing integrity rules.\n\n== Latency Ownership Policy\n\nCompute realism delay, when desired, belongs to plugin implementations. Backend\nruntime layers do not contain synthetic sleeps. Test and oracle runs enforce stable\nthroughput by setting `CALYPSO_FAST=true`, which disables plugin-local delay while\nleaving command semantics unchanged.\n\n== Architectural Outcome\n\nThe plugin system now expresses the intended Host/Guest architecture without major\nexceptions. Manifest declarations select behavior, plugins execute compute, and host\nlayers preserve deterministic orchestration and provenance integrity. This division\nis the foundation for v11 contract lock.\n\n---\n_Last updated: 2026-02-21 (v10.3.1)_",
    "shell.adoc": "= VCS Shell: The Contextual Execution Environment\n:author: ATLAS Project Team\n:revdate: 2026-02-18\n:revnumber: 10.0.1\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe VCS Shell is the process-level execution interface of the ARGUS environment. It provides a high-fidelity simulation of a POSIX-compliant command interpreter, mediating between the Calypso Host kernel and the Virtual File System (VFS). This specification details the architectural design of the Shell, its environment isolation protocols, and the mechanics of the builtin execution loop. By providing a familiar, deterministic command-line substrate, the Shell enables the execution of complex scientific simulations, such as the \"Phantom Federation\" Python loop, within the safety of a virtualized project tree.\n\n== Introduction: The Need for Process Isolation\n\n=== The Context-Drift Problem\nThe development of the VCS Shell was driven by the \"Context-Drift\" failure mode identified in early iterations of ARGUS. In legacy versions (v9.0 and below), command execution was performed through direct method calls on global singletons. This approach lacked the concept of \"Process Context\"—variables like the Current Working Directory (CWD) or the active User were maintained as shared global state. During concurrent operations or complex stage transitions, this state would often become corrupted, leading to situations where a plugin would attempt to write data into the wrong project directory.\n\n=== The Resolution: The Virtual Shell\nThe resolution was the implementation of the `Shell` class (located in `src/vfs/Shell.ts`). The Shell introduces a formal \"Process Environment\" to the ARGUS architecture. Every command execution is scoped to a specific instance of the Shell, which maintains its own environment variables and CWD. This isolation ensures that scientific plugins remain stateless; they do not need to \"know\" where they are, as they inherit their context from the active Shell. This shift from \"Global State\" to \"Process Environment\" is critical for the v10.0 mandate of procedural integrity.\n\n== Shell Execution Figure\n\n[source,text]\n----\n┌───────────────┐\n│ command input │\n└──────┬────────┘\n       ▼\n┌───────────────┐\n│ resolution    │\n│ 1) env assign │\n│ 2) builtin    │\n│ 3) external   │\n└──────┬────────┘\n       ▼\n┌───────────────┐\n│ ShellResult   │\n│ stdout/stderr │\n│ exitCode      │\n└──────┬────────┘\n       ▼\n┌──────────────────────────┐\n│ languageRegistry (shared)│\n└──────────┬───────────────┘\n           │\n     ┌─────┴─────┐\n     ▼           ▼\n┌──────────┐ ┌──────────┐\n│ WUI HTML │ │ TUI ANSI │\n└──────────┘ └──────────┘\n----\n\n== Environment Isolation and Variable Management\n\nThe Shell functions as the \"Guardian of Context,\" maintaining the variables that define the persona and location of the current session.\n\n=== The Persistent Environment Bag\nThe Shell maintains a persistent set of environment variables, including:\n*   **`$USER`**: Defines the active research persona (e.g., `oracle`, `clinician`).\n*   **`$HOME`**: Defines the root directory for the persona's session state.\n*   **`$PROJECT`**: Anchors all operations to a specific research workspace.\n*   **`$PS1`**: Defines the visual prompt, providing real-time feedback to the operator about their current CWD and project context.\n\n=== Recursive Interpolation\nThe Shell implements a sophisticated variable expansion engine. It recursively interpolates environment variables within command strings (e.g., `cd /home/$USER/projects/$PROJECT`). This ensures that complex scripts and plugin calls behave identically across different user sessions, as the absolute paths are resolved dynamically at execution time.\n\n== The Builtin Execution Loop\n\nCommand execution in the Shell follows a rigid, deterministic loop that ensures absolute control over the VFS substrate.\n\n=== Resolution Order\nWhen a command is received, the Shell resolves it through a strictly defined hierarchy:\n1.  **Environment Variables:** Checks if the command is a variable assignment (e.g., `export PROJECT=test`).\n2.  **Builtin Registry:** Searches the library of over 20 POSIX-simulating builtins (e.g., `cd`, `ls`, `mkdir`).\n3.  **External Handler:** If not a builtin, the Shell delegates to an optional external handler (typically the `CalypsoCore` fallback) for AI-mediated workflow commands.\n\n=== The ShellResult Protocol\nEvery command execution returns a `ShellResult` object. This protocol ensures that the Shell remains \"Dumb\" about UI rendering:\n*   **`stdout`**: The standard output stream.\n*   **`stderr`**: The error stream (rendered in red in the LCARS terminal).\n*   **`exitCode`**: A numeric code indicating success (`0`) or failure (e.g., `127` for command not found).\n\n== Shell Output and Syntax Rendering Boundary\n\n=== The Shell Is Render-Neutral\n\nThe Shell owns execution semantics, not presentation semantics. It returns plain command streams (`stdout`, `stderr`) and exit codes. It does not emit HTML spans, ANSI palette decisions, or UI-specific syntax classes.\n\nThis boundary is intentional: a single command must remain valid across browser, TUI, and headless ORACLE execution without changing Shell behavior.\n\n=== Single Source of Truth: Language Registry\n\nLanguage detection and language-to-filename mapping are centralized in `src/core/syntax/languageRegistry.ts`.\n\nThe registry is the canonical source for:\n\n*   Path-based language detection (`language_fromPath`).\n*   `cat <path>` command language detection (`language_fromCatCommand`).\n*   Alias normalization (`language_normalize`).\n*   Pseudo-filename mapping for highlighters (`filename_forLanguage`).\n\nAny new syntax mapping must be added here first. Browser and TUI rendering paths consume this registry; they do not maintain independent extension maps.\n\n=== WUI Syntax Highlighting Path\n\nThe browser pipeline is:\n\n1.  `src/core/logic/commands.ts` identifies fenced blocks and direct `cat` output.\n2.  It resolves language through `languageRegistry`.\n3.  `src/ui/syntaxHighlight.ts` applies HTML-token highlighting for the detected canonical language.\n\n=== TUI Syntax Highlighting Path\n\nThe terminal/CLI pipeline is:\n\n1.  `src/calypso/ui/tui/TuiRenderer.ts` decides when a response should be syntax-highlighted.\n2.  `src/calypso/ui/tui/SyntaxHighlight.ts` performs ANSI highlighting.\n3.  That module delegates language detection/normalization to `src/core/syntax/languageRegistry.ts`.\n\nThe result is a shared detection contract with surface-specific rendering (HTML in WUI, ANSI in TUI).\n\n== The Python Simulator: High-Fidelity Logic Emulation\n\nThe most critical component of the Shell is the `python` builtin. This simulator mimics the behavior of a real Python interpreter, enabling the \"Simulation Loop\" required by the SeaGaP-MP workflow.\n\n=== \"Phantom\" Logic Execution\nWhen a user runs `python train.py`, the Shell does not execute real Python code. Instead, it:\n1.  **Parses** the `train.py` file from the VFS.\n2.  **Analyzes** the script's intent based on the active workflow stage.\n3.  **Synthesizes** realistic training logs (epoch progress, loss curves) to `stdout`.\n4.  **Materializes** the expected side effects—such as the `.local_pass` marker or trained weight files—into the project's `/output/` directory.\n\n=== Scientific Validation\nThis simulator allows researchers to verify the *behavioral integrity* of their training protocols within the safety of the VCS. If a script fails to adhere to the platform's requirements, the simulator produces a detailed `stderr` traceback, allowing for a rapid local development loop without the latency or cost of a real federated dispatch.\n\n== Conclusion\n\nThe VCS Shell is the \"User Space\" of the ARGUS environment. By providing a formal, POSIX-compliant interface for process execution and environment management, it ensures that every user interaction is governed by the same deterministic rules. The Shell transforms the virtual filesystem from a static data structure into a dynamic, interactive research environment, providing the contextual grounding required for high-integrity scientific discovery.\n\n---\n_Last updated: 2026-02-18 (v10.0.1)_",
    "vcs.adoc": "= Virtual Computer System (VCS): The Substrate of Deterministic Truth\n:author: ATLAS Project Team\n:revdate: 2026-02-17\n:revnumber: 10.0.0\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe Virtual Computer System (VCS) is the foundational state substrate of the ARGUS environment. It provides a high-fidelity, in-memory simulation of a POSIX-compliant computer system within the web browser or a headless Node.js process. This document serves as the formal specification for the VCS, detailing the architectural design of the Virtual File System (VFS), the Shell execution environment, and the Content Registry. By providing a deterministic \"Ground Truth\" that is independent of AI-mediated assertions, the VCS functions as the primary mechanism for agentic safety and procedural verification in federated medical research.\n\n== Introduction: The Case for a virtualized Substrate\n\n=== The \"Truth Gap\" in Agentic Systems\nThe development of the VCS was a direct response to the \"Truth Gap\"—the structural disconnect between an AI's conversational claims and the actual state of the system it purports to control. In legacy iterations of ARGUS (v9.0 and below), project state was managed through high-level TypeScript objects. This approach proved fragile when subjected to the non-deterministic output of LLMs. An agent could \"believe\" it had successfully performed a complex data mutation simply because it generated the correct descriptive text, even if the underlying API call failed or the system state drifted.\n\n=== The Resolution: POSIX-Compliant Grounding\nWe learned that for an AI agent to operate safely in a high-stakes environment like medical imaging, it must be embedded in an environment that behaves according to known, immutable rules. The resolution was the implementation of a full-stack virtualized computer system. The VCS provides a \"Physical Grounding\" for every action. If a plugin claims to have harmonized a cohort, that success is only recognized if a physical Merkle-proven receipt is materialized in the topological session tree. This shift from \"Assertion-Based State\" to \"Materialized-Receipt State\" is the fundamental engineering move that enables ARGUS to achieve v10.0 integrity levels.\n\n== VCS Stack Figure\n\n[source,text]\n----\n┌─────────────────────────────────────────┐\n│ Calypso Host / Plugin Runtime           │\n└──────────────────────┬──────────────────┘\n                       ▼\n┌─────────────────────────────────────────┐\n│ VCS                                     │\n│ ┌─────────────────────────────────────┐ │\n│ │ VFS (nodes, metadata, mutations)    │ │\n│ ├─────────────────────────────────────┤ │\n│ │ Shell (context, builtins, process)  │ │\n│ ├─────────────────────────────────────┤ │\n│ │ ContentRegistry (lazy generators)   │ │\n│ └─────────────────────────────────────┘ │\n└──────────────────────┬──────────────────┘\n                       ▼\n┌─────────────────────────────────────────┐\n│ Materialized artifacts + deterministic  │\n│ state evidence in project/session trees │\n└─────────────────────────────────────────┘\n----\n\n== The Virtual File System (VFS): The Ledger of State\n\nThe `VirtualFileSystem` class is the primary ledger of the ARGUS system. It implements a tree-based node model that strictly enforces POSIX-like semantics for all data-state transformations.\n\n=== The Node Model and Metadata Integrity\nThe VFS is composed of a recursive tree of `FileNode` objects. Unlike a simple key-value store, each node in the VFS tracks metadata essential for procedural verification:\n*   **Node Identity:** Each node has a unique `name`, a `type` (file, folder, or link), and a parent reference.\n*   **POSIX Metadata:** Every node maintains `mode` (permissions), `mtime` (modification time), `atime` (access time), and `owner/group` identifiers. \n*   **Security Isolation:** The `mode` property is utilized to enforce access controls between different research personas. For example, a \"clinician\" persona may have read-only access to `/input/`, while the \"developer\" persona has full write access to `~/src/`.\n\n=== Advanced Path Resolution and Symlinking\nThe VFS implements a sophisticated path resolution engine that supports absolute, relative, and homedir (`~/`) paths.\n*   **CWD Mapping:** Each shell process maintains its own Current Working Directory (CWD). Path resolution is always performed relative to this CWD, ensuring that command execution (e.g., `ls ./data`) behaves identically to a physical Linux terminal.\n*   **Virtual Mounting:** The system supports the dynamic mounting of external subtrees into the VFS. This is a critical feature for the `Gather` stage, where data from disparate federated sites is \"mounted\" into a unified project-scoped view (`/input/training/site-a/`) without actual data duplication.\n\n=== Atomic VFS Operations\nThe `VirtualFileSystem` class exports over 30 atomic operations, including `node_write`, `node_read`, `node_move`, and `node_cloneDeep`. Every operation is a synchronous, deterministic mutation of the in-memory tree. Crucially, these operations emit `VFS_CHANGED` events, allowing UI components and the `MerkleEngine` to react in real-time to the system's evolving state.\n\n== The Shell: The Contextual Execution Environment\n\nThe `Shell` class provides the process-level context and command interpretation layer for the VCS. It is the primary interface through which the Calypso Host and human operators interact with the filesystem.\n\n=== Environment Variable Isolation\nThe Shell maintains a persistent environment bag ($USER, $HOME, $PWD, $PROJECT). This context is vital for multi-phase scientific workflows.\n*   **Project Context:** The `$PROJECT` variable anchors all commands to a specific research workspace. This allows the same \"Harmonize\" plugin to be run across different projects without the risk of cross-project data contamination.\n*   **Variable Interpolation:** The Shell supports recursive variable expansion (e.g., `cd /home/$USER/projects/$PROJECT`), providing a high-fidelity simulation of a developer's local environment.\n\n=== The Builtin Library and Script Execution\nThe Shell contains a robust library of over 20 POSIX-simulating builtins.\n*   **Standard Utilities:** Includes `cd`, `ls`, `mkdir`, `cp`, `mv`, `rm`, `cat`, and `echo`. Each builtin is implemented as a pure function that takes the current Shell context and returns a `ShellResult` (stdout, stderr, exitCode).\n*   **The Python Simulator:** A specialized builtin designed to mimic a Python interpreter. When the user runs `python train.py`, the Shell does not invoke a real Python process. Instead, it parses the `train.py` file from the VFS, simulates the training logic, and materializes the expected validation artifacts (e.g., `.local_pass`). This allows for the \"Phantom Federation\" verification cycle required by the SeaGaP-MP workflow.\n\n=== Redirection and Piping\nThe v10.0 Shell supports basic I/O redirection (e.g., `cat data.txt > log.txt`). This feature is utilized by plugins to capture execution logs into the project tree, ensuring that the \"Evidence of Work\" is preserved as a physical artifact for later audit.\n\n== The Content Registry: Lazy Materialization\n\nTo support national-scale catalogs containing millions of virtual files, the VCS utilizes a **Content Provider** model managed by the `ContentRegistry`.\n\n=== The Logic of Lazy Loading\nStoring the full content of every virtual file (scaffolds, participants lists, Dockerfiles) in memory would be prohibitively expensive. Instead, the VCS stores a `contentGenerator` string—a unique identifier for a generator function.\n*   **Materialization on Read:** When `node_read()` is invoked, the VFS checks if the file has a generator. If so, it invokes the registry to synthesize the content in real-time.\n*   **Context-Aware Templates:** Generators are not static. They are \"Smart Templates\" that receive the current system context as input. For example, the `participants.json` generator queries the `Store` for the currently selected datasets and builds the JSON list dynamically.\n\n=== Performance and Integrity\nThis approach ensures that the \"Disk\" always reflects the current application logic without consuming excessive RAM. Once a file is written to (mutated), the generator is detached, and the file becomes a static \"snapshot,\" preserving the integrity of that specific version for the Merkle provenance chain.\n\n== Conclusion\n\nThe VCS is the architectural bedrock of ARGUS. By virtualizing the entire execution environment—from the node-level file metadata to the process-level shell context—it provides the \"Substrate of Truth\" required for high-integrity federated research. The VCS ensures that \"Truth\" is never a conversational assertion, but a physical property of the virtualized environment. This grounding is what allows ARGUS to scale from a simple assistant to a verifiable, POSIX-compliant operating system for the ATLAS platform.\n\n---\n_Last updated: 2026-02-17 (v10.0.0)_",
    "vfs.adoc": "= Virtual File System: Deterministic Substrate for Provenance\n:author: ATLAS Project Team\n:revdate: 2026-02-20\n:revnumber: 10.3.0\n:toc: macro\n:toclevels: 4\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThe ARGUS Virtual File System is the substrate where workflow truth is\nmaterialized. It provides a POSIX-like node model, deterministic mutation\nsemantics, and event surfaces used by orchestration and rendering layers. In the\nstate-grounded model, workflow completion is not an in-memory assertion; it is a\nfilesystem fact anchored by Merkle lineage.\n\nThis document specifies the VFS as an integrity component rather than a utility\nlayer.\n\n== Historical Context\n\nLegacy workflow implementations tracked progress in process memory and UI state. As\nworkflow complexity increased, those representations drifted from actual side\neffects. The response was to move state authority onto a file-backed model where\nevery meaningful transition could be inspected, replayed, and cryptographically\nanchored.\n\nThe VFS was introduced to make this possible in headless and test environments\nwithout requiring immediate dependence on a specific host filesystem backend.\n\n== VFS Mutation Figure\n\n[source,text]\n----\n┌──────────────────────────┐\n│ PATH + OPERATION         │\n│ read/write/move/link     │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ PATH RESOLUTION          │\n│ abs / home / relative    │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ NODE MUTATION            │\n│ POSIX metadata update    │\n└────────────┬─────────────┘\n             ▼\n┌──────────────────────────┐\n│ VFS_CHANGED EVENT        │\n└───────┬──────────┬───────┘\n        │          │\n        ▼          ▼\n┌──────────────┐  ┌──────────────┐\n│ UI SYNC      │  │ MERKLE CHECK │\n└──────────────┘  └──────────────┘\n----\n\n== Node and Path Semantics\n\nThe VFS stores directories, files, and links as typed nodes with ownership,\npermission, and timestamp metadata. Path resolution follows POSIX semantics across\nabsolute, home-relative, and process-relative forms, and each shell process\nmaintains its own working-directory context. This allows command behavior to remain\npredictable across concurrent sessions and adapters.\n\nSymbolic-link behavior is used to present stable working surfaces such as `input`\nwhile preserving lineage structure inside project data trees.\n\n[source,text]\n----\n/home/user/projects/my-study/\n├── src/                    (mutable workshop)\n├── input -> data/...       (active portal symlink)\n└── data/                   (lineage vault)\n    └── search/\n        └── gather/\n            └── harmonize/\n----\n\n== Mutation and Event Contract\n\nMutations are executed through deterministic operations that either succeed\natomically or fail with explicit errors. Successful writes emit VFS change events\nconsumed by both interface adapters and provenance layers. This shared event stream\nensures that render updates and lineage checks observe the same underlying state\ntransition.\n\nThe key invariant is temporal coherence: what adapters display and what Merkle\nlayers anchor are both projections of the same mutation history.\n\n== Lazy Content Materialization\n\nTo avoid unnecessary memory cost for scaffolded or generated assets, nodes may be\ninitialized with generator identities. Content is synthesized on read and frozen\ninto static snapshots once manually edited. This preserves developer ergonomics\nwhile maintaining stable provenance after human intervention.\n\n== Architectural Outcome\n\nThe VFS is the operational ledger of ARGUS. It enables deterministic command\nexecution, supports adapter parity through shared event semantics, and provides the\nphysical basis on which Merkle lineage can prove workflow integrity. As backend\nstorage evolves, this contract remains the reference behavior for state truth.\n\n---\n_Last updated: 2026-02-20 (v10.3.0)_",
    "visual_language.adoc": "= ARGUS: Visual Language Specification\n:author: ATLAS Project Team\n:revdate: 2026-01-30\n:toc:\n:sectnums:\n\n== Introduction\n\nARGUS draws its visual identity from Star Trek's LCARS (Library Computer Access/Retrieval System), designed by Michael Okuda for The Next Generation. Where LCARS was created for television cameras, ARGUS adapts its design language for responsive, interactive web use. This document codifies the motion and layout patterns that give ARGUS its cinematic, mechanical feel.\n\nThe visual language is built on a central metaphor: ARGUS is a physical console. Frames are structural members that separate and rejoin. Content panels are equipment trays that slide into exposed bays. Nothing simply appears or disappears -- everything moves with deliberate, mechanical purpose.\n\n== Visual Pattern Figure\n\n[source,text]\n----\nopen sequence (double whammy):\n┌──────────────────┐      ┌──────────────────┐      ┌──────────────────┐\n│ closed frame     │ ───▶ │ frame separation │ ───▶ │ panel slide-in   │\n└──────────────────┘      └──────────────────┘      └──────────────────┘\n\nclose sequence (overlapped):\n┌──────────────────┐\n│ panel visible    │\n└────────┬─────────┘\n         ├──────────────▶ slide-out\n         └──────────────▶ frame collapse\n                        (parallel)\n----\n\n== Core Structural Elements\n\n=== The LCARS Frame\n\nBar panels form the structural skeleton of the interface. The primary frame consists of two horizontal bar rows (bars 1-5 at top, bars 6-10 at bottom) connected by a vertical left sidebar. These bars are not decorative chrome -- they are load-bearing members that define content regions and, critically, can separate to expose functional surfaces beneath them.\n\nThe frame uses rounded \"elbows\" at connection points between horizontal and vertical members, achieved through a combination of `border-radius` and pseudo-element geometry. These curves are the most recognizable LCARS signature and must be preserved at all viewport sizes.\n\n=== The Content Region\n\nThe area enclosed by bars and sidebar is the active workspace. Content within this region changes based on the current SeaGaP-MP stage. The region scrolls vertically but never horizontally.\n\n=== The Slot\n\nWhen bars separate, the space between them becomes a slot -- a bay into which content panels can be inserted. The Intelligence Console occupies the primary slot between the lower bar panel and the main content area. The slot concept is generalizable: any region where frame members can part to accept a content panel is a slot.\n\n== Animation Patterns\n\nARGUS uses three distinct animation patterns, each appropriate to different interaction contexts. All animations use the same easing curve (`cubic-bezier(0.4, 0, 0.2, 1)`) for visual consistency.\n\n=== Pattern 1: Frame Separation\n\nFrame members move apart to create space. This is a vertical height transition where a collapsed region expands to a target height.\n\n[cols=\"1,3\"]\n|===\n| Duration | 600ms (`--frame-transition-duration`)\n| Easing | `cubic-bezier(0.4, 0, 0.2, 1)` (`--lcars-easing`)\n| CSS mechanism | `transition: height` on the slot container\n| Trigger | Class toggle (`.open`)\n| Used by | Intelligence Console frame, terminal drawer\n|===\n\nFrame Separation alone does not introduce content. It exposes empty space -- a bay waiting to receive a panel. When used in isolation, the frame region would contain static content already present in the DOM that is revealed by the expansion.\n\n=== Pattern 2: Slide-In Overlay\n\nA full-surface overlay enters from the right edge of the viewport and covers the content region entirely. This is used for modal or near-modal experiences that temporarily replace the active workspace.\n\n[cols=\"1,3\"]\n|===\n| Duration | 400ms (`--slide-transition-duration`)\n| Easing | `cubic-bezier(0.4, 0, 0.2, 1)` (`--lcars-easing`)\n| CSS mechanism | `@keyframes` with `translateX(100%)` to `translateX(0)`\n| Trigger | State change via Store (`marketplaceOpen`)\n| Close | Reverse animation via `.closing` class, then `display: none` on `animationend`\n| Used by | Marketplace overlay, Asset detail overlay\n|===\n\nThe slide-in overlay implies a separate system or context. The marketplace is not part of the SeaGaP workflow -- it is an adjacent resource. The rightward origin reinforces this: it arrives from outside the console's workspace.\n\n=== Pattern 3: Frame-then-Slide (The Double Whammy)\n\nThis is the signature ARGUS interaction pattern, combining Frame Separation with a content slide-in to create a two-phase mechanical animation:\n\n==== Opening Sequence\n\n. **Phase 1 -- Frame Separation** (600ms): The slot container expands vertically. Bar panels move apart. The bay is now exposed but empty.\n. **Phase 2 -- Content Slide-In** (400ms): After the frame finishes expanding, the content panel slides in from the right edge of the slot, filling the bay.\n\nTotal opening time: ~1000ms. The sequential phasing is intentional for the opening -- the user should perceive two distinct mechanical actions: \"bay opens\" then \"equipment slides in.\"\n\n==== Closing Sequence\n\n. **Simultaneous**: The content panel begins sliding out to the right AND the frame begins collapsing at the same time. Both animations run in parallel.\n\nTotal closing time: ~600ms. The overlapped closing is intentional -- closing should feel snappier than opening. The visual effect is the content being retracted as the bay shuts, like a drawer closing with its tray still retracting.\n\n==== Timing Constants\n\n[cols=\"2,1,1\"]\n|===\n| Constant | Value | CSS Variable\n| Frame transition duration | 600ms | `--frame-transition-duration`\n| Slide transition duration | 400ms | `--slide-transition-duration`\n| Easing curve | cubic-bezier(0.4, 0, 0.2, 1) | `--lcars-easing`\n|===\n\n==== Used By\n\n* Intelligence Console (terminal)\n* Future: any panel that occupies a frame slot (diagnostics, settings, inline help)\n\n== The Frame Slot System\n\nThe Frame-then-Slide pattern is implemented as a composable system with two components:\n\n=== SlidePanel\n\nA reusable primitive that manages the slide-in and slide-out animation of a single DOM element. The SlidePanel knows nothing about frames or slots -- it only knows how to move its content element horizontally using CSS transitions.\n\nThe SlidePanel applies the `.frame-slot-panel` CSS class to its managed element. This class sets the initial state (`translateX(100%)`, `opacity: 0`) and defines the transition properties. The `.active` class triggers the slide-in; the `.exiting` class triggers the slide-out.\n\nCSS transitions are used rather than `@keyframes` animations because transitions can be interrupted and reversed mid-animation. This is essential for the draggable access strip, which allows users to manually resize the terminal bay.\n\n=== FrameSlot\n\nAn orchestrator that coordinates the two-phase sequence by combining a frame element (the expandable container) with a SlidePanel (the sliding content). The FrameSlot manages the timing between phases and provides guards against rapid-fire toggling that could leave the animation in a broken state.\n\nThe FrameSlot is the integration point. To add a new pluggable panel to a frame slot in the future, one creates a new SlidePanel instance and registers it with the FrameSlot. The frame expansion logic remains unchanged -- only the content that slides in differs.\n\n== Design Rationale\n\n=== Why Two Phases on Open?\n\nA single combined animation (frame expands while content slides) would be faster but would read as a single event. Two distinct phases create a narrative: something mechanical happened (the bay opened), and then something was delivered (the panel arrived). This maps to the physical console metaphor and gives the user's attention two anchor points rather than one.\n\n=== Why Overlap on Close?\n\nOpening is a reveal -- it deserves ceremony. Closing is a dismissal -- it should be efficient. Users who close a panel want it gone; making them wait through a sequential reverse animation creates frustration. The overlapped close respects the user's intent to dismiss while still maintaining visual coherence.\n\n=== Why Slide from the Right?\n\nThe left edge of the ARGUS interface is occupied by the LCARS sidebar -- a fixed structural member. Content entering from the right implies arrival from outside the current context, which is semantically correct for both the marketplace (an external registry) and the terminal (a system-level tool that exists below the application surface). The rightward origin also follows natural left-to-right reading flow: the workspace is read first, then the arriving panel draws attention as it enters the visual field.\n\n== Pattern Selection Guide\n\n[cols=\"2,3,2\"]\n|===\n| Scenario | Pattern | Rationale\n\n\n| System tool appearing within the console frame\n| Frame-then-Slide\n| Mechanical feel; tool is \"inserted\" into the console\n\n| External resource browser or modal overlay\n| Slide-In Overlay\n| Full takeover; content is from outside the workflow\n\n| Revealing static content within the layout\n| Frame Separation only\n| No new content arrives; existing content is exposed\n\n| Future: swapping one tool for another in an open bay\n| Slide-out then Slide-in (no frame animation)\n| Bay is already open; only the content changes\n|===\n\n== Visual Convergence: Asset Tiles and Project Tiles\n\nTo maintain a consistent visual language across the platform, ARGUS uses a unified tile-based metaphor for all addressable resources, whether they are external (Marketplace Assets) or internal (User Projects).\n\n=== The Asset Card Pattern\n\nThe `AssetCard` component codifies the established LCARS \"tile\" aesthetic. It features:\n* **The Header Badge**: Top-left identification of the resource type (e.g., \"PLUGIN\", \"PROJECT\").\n* **The Semantic Color Code**: Orange for algorithms/scripts, Honey for data/projects, Sky for core systems.\n* **Metadata Alignment**: Primary stats (stars, dataset counts) on the right, authorship/origin on the bottom-left.\n* **The Mechanical Action**: A primary action button (INSTALL, SELECT) integrated into the card's baseline.\n\n=== Interaction Parity: Preview Before Commitment\n\nConsistent with the Marketplace interaction model, User Projects now feature a **Detail Preview** phase. Clicking a project tile no longer triggers an immediate workspace load (commitment); instead, it opens a detail overlay providing a read-only preview of the project's source code and data cohort.\n\n=== The Workspace Layout\n\nAs of v4.3.0, opening a project from the detail preview activates a **workspace layout** that transforms the right-frame into a vertical stack of two independently-sized panels: the Intelligence Console (terminal) on top and a FileBrowser below.\n\nEach panel owns its own bottom-edge **resize handle** — an LCARS-styled 6px orange grip bar. Dragging a handle resizes only its associated panel. The panels are fully decoupled; the page scrolls to accommodate their combined height. This \"independent sizing\" model replaces the traditional split-pane approach (where resizing one panel shrinks the other) and aligns with the LCARS philosophy of modular, self-contained instrument panels.\n\nThe file browser tabs (SOURCE/DATA) and the terminal working directory maintain bidirectional sync: clicking a tab changes the terminal's cwd, and typing `cd` in the terminal switches the active tab.",
    "why-not-agentic.adoc": "= Why ARGUS Doesn't Let the AI Drive: The Case for Deterministic Orchestration\n:author: ATLAS Project Team\n:revdate: 2026-02-17\n:revnumber: 10.0.0\n:toc: macro\n:toclevels: 3\n:sectnums:\n\ntoc::[]\n\n== Abstract\n\nThis document presents the architectural rationale for ARGUS's rejection of the \"autonomous agent\" model in favor of a deterministic, human-in-the-loop framework. It outlines the structural risks of ungrounded agentic orchestration—specifically the Irreducible Hallucination problem—and details how ARGUS utilizes **Intent-First Design** to ensure safety, auditability, and scientific integrity in federated medical imaging workflows.\n\n== Introduction: The Historical Context\n\nThe prevailing trend in modern artificial intelligence is toward \"Agency\"—the ability for models to autonomously plan, execute, and iterate through complex tasks. While this paradigm is compelling for general-purpose assistants, it is fundamentally brittle for medical research and clinical operations. Early experiments with \"Autonomous Calypso\" revealed that unconstrained agents inevitably suffer from \"Instructional Decay.\" In these legacy versions, the AI's internal model of the project would eventually diverge from the physical reality of the data, leading the agent to \"hallucinate\" progress or skip critical validation steps (e.g., training a model on unharmonized data).\n\nWe learned that in high-stakes environments, the human operator must remain the authoritative decision-maker. The resolution was the implementation of **Deterministic Orchestration**. ARGUS uses the AI as a mediator and a compiler, but never as an autonomous controller. The system is designed so that the AI interprets what the user wants, but the underlying \"Operating System\" kernel (the Host) enforces the rules of the scientific process.\n\n== The Structural Fragility of Probabilistic Loops\n\nThe fundamental flaw in autonomous agent systems is their probabilistic nature. Because LLMs operate by predicting the next token, their \"reasoning\" is a sequence of probabilities. When an agent is placed in an open-ended loop, these probabilities multiply.\n\n*   **The Math of Failure:** If an agent has a 95% success rate for a single step, the reliability of a 10-step autonomous workflow drops to ~60% (0.95^10). For scientific research, this cumulative error rate is unacceptable.\n*   **The Truth Gap:** Without a deterministic environment like the VCS, an agent has no way to verify its own claims. It can \"believe\" a file was created because it successfully generated the command, even if the command failed silently in the environment.\n\nARGUS solves this by grounding every probability in a deterministic state. The AI may *suggest* a project rename, but the renaming only occurs if the `rename` plugin executes successfully and materializes a physical artifact in the VFS.\n\n== Intent-First Design: The IAS Separation\n\nTo manage the transition from human language to system mutation, ARGUS implements the **Intent-Action-State (IAS)** separation. This principle, drawn from the ChRIS lineage, ensures that the AI's role is strictly limited to the \"Intent\" phase.\n\n1.  **Intents (Interpretation):** The user speaks in natural language. Calypso's `IntentParser` compiles this into a structured protocol intent.\n2.  **Actions (Execution):** The Host dispatches the intent to a deterministic plugin. The plugin—not the AI—performs the work.\n3.  **States (Materialization):** The result is recorded as a physical VFS artifact.\n\nBy isolating the AI from the \"Action\" and \"State\" phases, ARGUS ensures that the \"Intelligence\" layer can be replaced or updated without affecting the underlying procedural truth of the system.\n\n== The Soft Enforcement Model: The Educational Gatekeeper\n\nRather than rigidly blocking users, ARGUS uses a \"Soft Enforcement\" model to guide them through the SeaGaP-MP workflow. When a user attempts to skip a stage (e.g., moving to code without gathering data), the system issues an educational warning.\n\n*   **Warning 1:** A brief alert indicating the missing prerequisite.\n*   **Warning 2:** A detailed explanation of why the stage is scientifically necessary.\n*   **Override:** The user is eventually allowed to proceed, but only after acknowledging the risk.\n\nThis approach acknowledges that the human researcher is the expert. The system functions as a \"Navigator,\" providing the map and the evidence, but leaving the steering to the human.\n\n== Conclusion\n\nARGUS is designed to augment human intelligence, not replace it. By using a deterministic core and an Interpretation-First pipeline, we provide the efficiency of an agentic interface with the safety and auditable truth of a traditional operating system. The system's refusal to \"let the AI drive\" is its most important safety feature, ensuring that every federated model is the result of a verifiable, human-led scientific process.\n\n---\n_Last updated: 2026-02-17 (v10.0.0)_"
};
