/**
 * @file System Knowledge Base
 * Auto-generated by scripts/bundle-docs.cjs
 * Contains the full content of the docs/ directory for AI context.
 */

export const SYSTEM_KNOWLEDGE: Record<string, string> = {
    "architecture.adoc": "= ARGUS Architecture\n:toc:\n:toclevels: 3\n:sectnums:\n\n== Core Philosophy: Robust Vanilla\nARGUS avoids heavy frontend frameworks (React, Vue) to maintain maximum performance and \"snap.\" However, to avoid state desynchronization issues common in imperative Vanilla JS, we employ a **Pub/Sub (Observer) Pattern**.\n\n== State Management (Pub/Sub)\n\nThe application state is centralized in a `Store` that acts as the single source of truth. Components do not mutate state directly; they dispatch **Actions**. The Store mutates the state and broadcasts **Events**. Components subscribe to these events to update the UI.\n\n=== The Flow\n1.  **User Action:** User clicks a dataset card.\n2.  **Action Dispatch:** UI calls `store.dataset_toggle(id)`.\n3.  **State Mutation:** Store updates the `selectedDatasets` array.\n4.  **Event Broadcast:** Store emits `Events.DATASET_SELECTION_CHANGED`.\n5.  **Reactivity:**\n    *   `search.ts` hears event -> Highlights the card.\n    *   `gather.ts` hears event -> Rebuilds the VCS tree.\n    *   `telemetry.ts` hears event -> Recalculates cost estimates.\n\n=== Key Components\n\n*   **`src/core/state/events.ts`**: The Event Emitter implementation and Event Type definitions.\n*   **`src/core/state/store.ts`**: The central Store class containing application state and business logic actions. All methods follow RPN naming (e.g., `stage_set()`, `marketplace_toggle()`, `asset_install()`).\n\n== Application Logic Layers\n\nThe application logic is decoupled from the main entry point (`argus.ts`) into specialized services and routers.\n\n=== Command Routing\n**`src/core/logic/commands.ts`**\n*   **Role**: Dispatches terminal commands to the appropriate subsystem.\n*   **Flow**: Terminal Input -> Shell (builtin check) -> CommandRouter (workflow check) -> AIService (NL query).\n*   **Commands Handled**: `search`, `add`, `review`, `gather`, `mount`, `simulate`.\n\n=== The Intent Layer (Local IAS)\n**`src/core/logic/ProjectManager.ts`**\n*   **Role**: Bridges the gap between high-level intents (\"Gather this dataset\") and low-level system operations (VFS mounting, Store mutation, Shell sync).\n*   **Architecture**: Implements the **Intent-Action Service (IAS)** pattern locally.\n    - **Concept**: Calypso (or the Web UI) should not orchestrate complex multi-step state mutations. Instead, they call a single \"Intent Function\" (e.g., `project_gather()`) which encapsulates the procedural logic.\n    - **Parallel**: This mirrors the external **Intent-Action Service** proposal for the ATLAS backend (https://github.com/FNNDSC/intent-server), where an intermediate service translates declarative API intents into procedural orchestration.\n*   **Key Function**: `project_gather(dataset)` — Handles draft project creation, VFS initialization, store updates, and tree mounting in one atomic operation.\n\n=== AI Service\n**`src/lcarslm/AIService.ts`**\n*   **Role**: Manages the RAG (Retrieval Augmented Generation) loop with the LLM backend.\n*   **Responsibility**: Builds context from the search buffer, executes queries via `LCARSEngine`, and parses structured intents (e.g., `[SELECT: ds-123]`) from the response.\n\n=== Stage Lifecycle\n**`src/core/logic/Lifecycle.ts`**\n*   **Role**: Defines the contract for stage transitions.\n*   **Pattern**: Each stage module exports `stage_enter()` and `stage_exit()` hooks. The main orchestrator (`argus.ts`) calls these hooks during transitions, inverting control and keeping the entry point clean.\n\n=== Window Bindings\n**`src/core/logic/WindowBindings.ts`**\n*   **Role**: A centralized registry for all functions exposed to the DOM (for HTML `onclick` attributes). Ensures type safety for global window extensions.\n\n== Event Catalog\n\n[cols=\"2,2,2,3\"]\n|===\n| Event Name | Payload | Triggered By | Listeners (Impact)\n\n| `STATE_CHANGED`\n| `AppState`\n| Any state update\n| Telemetry (Cascade), Marketplace overlay\n\n| `STAGE_CHANGED`\n| `AppState['currentStage']`\n| `store.stage_set()`\n| UI panels, Terminal prompt, Shell `stage_enter()`, Gutters, Stage Lifecycle Hooks\n\n| `DATASET_SELECTION_CHANGED`\n| `Dataset[]`\n| `store.dataset_select()` / `store.dataset_deselect()`\n| Gather VFS, Cost calc, Search Grid, Selection count\n\n| `PROJECT_LOADED`\n| `Project \\| null`\n| `store.project_load()`\n| VCS mount, Process IDE population\n\n| `VFS_CHANGED`\n| `{ path: string, operation: string }`\n| VirtualFileSystem mutations\n| IDE tree refresh (future)\n\n| `CWD_CHANGED`\n| `{ oldPath: string, newPath: string }`\n| `vfs.cwd_set()`\n| Shell prompt update\n|===\n\n== Virtual Computer System (VCS)\n\nThe VCS (`src/vfs/`) is ARGUS's stateful runtime environment. It provides a POSIX-like in-memory filesystem with content-aware files, a Shell interpreter, and a Provider architecture.\n\n=== Components\n\n[cols=\"1,2\"]\n|===\n| Component | Location\n\n| VirtualFileSystem\n| `src/vfs/VirtualFileSystem.ts` — Tree storage, content storage, path resolution, CWD, events.\n\n| Shell\n| `src/vfs/Shell.ts` — Command interpreter with 15 builtins, env vars (`$HOME`, `$USER`, `$PWD`, `$PS1`, `$STAGE`, `$PERSONA`), prompt generation.\n\n| ContentRegistry\n| `src/vfs/content/ContentRegistry.ts` — Maps file paths to content generators. Lazy evaluation + caching.\n\n| Templates\n| `src/vfs/content/templates/*.ts` — 14 generators for train.py, config.yaml, README.md, manifest.json, catalog, etc.\n\n| DatasetProvider\n| `src/vfs/providers/DatasetProvider.ts` — Builds `~/data/cohort/` from selected datasets.\n\n| ProjectProvider\n| `src/vfs/providers/ProjectProvider.ts` — Scaffolds `$HOME` + populates `~/src/project/`.\n\n| MarketplaceProvider\n| `src/vfs/providers/MarketplaceProvider.ts` — Installs assets to `/bin/`, `/data/sets/`, `~/models/`, etc.\n|===\n\n=== Data Flow\n\n1.  **User types `cat train.py`** in the terminal.\n2.  **Terminal** sends the raw input to the **Shell**.\n3.  **Shell** parses the command, resolves the path against `$PWD`.\n4.  **Shell** calls `vfs.node_read()`.\n5.  **VFS** looks up the node. If `content` is null, calls the **ContentRegistry**.\n6.  **ContentRegistry** finds the template, invokes it with `ContentContext`, returns content.\n7.  **VFS** caches content on the node, returns it.\n8.  **Shell** wraps content in `ShellResult { stdout, stderr, exitCode }`.\n9.  **Terminal** renders `stdout`.\n\n=== Integration\n\n*   The VCS is stored as `globals.vcs` (a `VirtualFileSystem` instance).\n*   The Shell is stored as `globals.shell` (a `Shell` instance).\n*   The Terminal delegates all input to `shell.command_execute()`.\n*   Stage transitions call `shell.stage_enter()` for CWD/env updates.\n*   The IDE reads file content from the VCS via `node_read()`.\n\nSee `docs/vcs.adoc` for the full specification.",
    "calypso.adoc": "= CALYPSO: The AI Core\n:revnumber: 5.1.11\n:revdate: 2026-02-04\n:toc: macro\n:toclevels: 3\n:sectnums:\n\ntoc::[]\n\n== Identity\n\n**Name:** CALYPSO\n**Acronym:** **C**ognitive **A**lgorithms & **L**ogic **Y**ielding **P**redictive **S**cientific **O**utcomes\n**Role:** The Intelligence Layer of the ARGUS System.\n\n=== Namesake\n\nCALYPSO carries a layered homage spanning Greek mythology and Star Trek:\n\n**The Myth (Homer's Odyssey):** Calypso was a nymph who lived on the island of Ogygia. When the shipwrecked Odysseus washed ashore, she rescued him and kept him on her island for seven years, offering immortality if he would stay. Her name derives from the Greek _kalyptō_ — \"to conceal\" or \"to hide.\" Where the mythological Calypso concealed Odysseus _from_ the world, our CALYPSO conceals complexity _for_ the user.\n\n**Star Trek: Short Treks \"Calypso\" (2018):** In this episode, set a thousand years after _Discovery_, a wounded soldier named Craft is rescued by **Zora** — the starship's evolved artificial intelligence. Like the mythological nymph, Zora nurses Craft back to health, forms a bond with him, and ultimately helps him return home to his family. The _Discovery_ series finale (2024) revealed that Zora waited alone for a millennium to ensure this encounter would happen.\n\n**The Double Homage:** ARGUS pays tribute to Star Trek twice over:\n\n1. The entire visual language is **LCARS** — the Library Computer Access/Retrieval System designed by Michael Okuda for _The Next Generation_. This is the same interface paradigm that Zora would have used aboard the Discovery.\n\n2. The name \"Calypso\" directly invokes Zora's episode — an AI manifesting through LCARS, patiently guiding users through unfamiliar territory, concealing complexity so they can focus on their mission and eventually reach their destination.\n\n== Lore & Function\n\nCALYPSO is the \"Ghost in the Machine\" — the artificial intelligence interface that bridges the gap between the human user and the massive, federated complexity of the ATLAS network.\n\nWhile ARGUS provides the graphical framework (the body), CALYPSO provides the logic and natural language understanding (the mind). She is responsible for:\n\n*   **Cohort Discovery:** Translating vague human intent (\"Show me brain scans\") into precise database queries.\n*   **Context Management:** Remembering user session state, selected datasets, and project context.\n*   **Workflow Guidance:** Suggesting the next logical steps in the SeaGaP (Search, Gather, Process) pipeline.\n*   **Knowledge Retrieval:** She has read-access to the full system documentation (`docs/*.adoc`) and can explain architecture, file structures, and workflows on demand.\n\n== Architecture: The Headless Core\n\nAs of v5.0.0, Calypso is architected as a **DOM-free headless core** that can operate in multiple environments: the browser, a Node.js server, or a CLI. This separation enables the ORACLE testing methodology (see `docs/oracle.adoc`).\n\n=== The Layer Model\n\n[source]\n----\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                           PRESENTATION LAYER                                │\n│   (Environment-specific adapters)                                           │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│   BrowserAdapter          CLIAdapter            NodeAdapter                 │\n│   ┌─────────────┐        ┌─────────────┐       ┌─────────────┐             │\n│   │ Terminal UI │        │   stdout    │       │ Test Harness│             │\n│   │ DOM updates │        │   readline  │       │ Assertions  │             │\n│   └──────┬──────┘        └──────┬──────┘       └──────┬──────┘             │\n│          │                      │                     │                     │\n└──────────┼──────────────────────┼─────────────────────┼─────────────────────┘\n           │                      │                     │\n           └──────────────────────┼─────────────────────┘\n                                  │\n                    CalypsoResponse (actions + message)\n                                  │\n┌─────────────────────────────────┼───────────────────────────────────────────┐\n│                                 ▼                                           │\n│                         CALYPSO CORE                                        │\n│   (DOM-free, pure TypeScript)                                               │\n├─────────────────────────────────────────────────────────────────────────────┤\n│                                                                             │\n│   CalypsoCore.ts                                                            │\n│   ┌─────────────────────────────────────────────────────────────────────┐   │\n│   │  command_execute(input: string): Promise<CalypsoResponse>           │   │\n│   │  ├── Shell builtins (ls, cd, cat, tree, etc.)                       │   │\n│   │  ├── Workflow commands (search, add, gather, mount, federate)       │   │\n│   │  └── LLM fallback (natural language → intent → action)              │   │\n│   └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│   Depends on (all DOM-free):                                                │\n│   ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │\n│   │     VFS      │  │    Store     │  │    Shell     │  │ LCARSEngine  │   │\n│   └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘   │\n│                                                                             │\n└─────────────────────────────────────────────────────────────────────────────┘\n----\n\n=== CalypsoCore\n\nThe `CalypsoCore` class is the central orchestrator. It receives natural language input, classifies intent, executes deterministic operations against the VFS/Store, and returns a structured response.\n\n**Integration with Intent Layer:**\nCalypso relies on the **Intent Layer** (`src/core/logic/ProjectManager.ts`) to execute complex procedural logic. Instead of manually manipulating the VFS, Store, and Shell in sequence, Calypso calls high-level intent functions like `project_gather()`. This ensures that:\n1.  **Atomicity**: Complex operations (like creating a draft project and mounting data) happen all-or-nothing.\n2.  **Parity**: Headless Calypso executes the exact same logic as the Web UI.\n3.  **Simplicity**: The AI only needs to map natural language to a single function call.\n\n[source,typescript]\n----\n// src/lcarslm/CalypsoCore.ts\n\nexport class CalypsoCore {\n    constructor(\n        private vfs: VirtualFileSystem,\n        private store: Store,\n        private shell: Shell,\n        private engine: LCARSEngine\n    ) {}\n\n    /**\n     * Execute a command (natural language or shell).\n     *\n     * @param input - User input string\n     * @returns Structured response with message and actions\n     */\n    public async command_execute(input: string): Promise<CalypsoResponse> {\n        // 1. Try shell builtins\n        // 2. Try workflow commands (delegates to Intent Layer)\n        // 3. Fall back to LLM\n    }\n}\n----\n\n=== CalypsoResponse\n\nInstead of directly manipulating the DOM, CalypsoCore returns a structured response. Adapters interpret the response according to their environment.\n\n[source,typescript]\n----\nexport interface CalypsoResponse {\n    /** Text message to display */\n    message: string;\n\n    /** Actions for the adapter to execute */\n    actions: CalypsoAction[];\n\n    /** Optional state snapshot for verification */\n    state?: {\n        vfs?: VfsSnapshot;\n        store?: Partial<ExtendedState>;\n    };\n}\n\nexport type CalypsoAction =\n    | { type: 'dataset_select'; id: string }\n    | { type: 'dataset_open'; id: string }\n    | { type: 'dataset_deselect'; id: string }\n    | { type: 'project_create'; name: string }\n    | { type: 'project_open'; id: string }\n    | { type: 'project_rename'; id: string; newName: string }\n    | { type: 'stage_advance'; stage: string; workflow?: 'fedml' | 'chris' }\n    | { type: 'workspace_render'; datasets: Dataset[] }\n    | { type: 'overlay_close' }\n    | { type: 'federation_start' }\n    | { type: 'marketplace_open' }\n    | { type: 'marketplace_close' };\n----\n\n=== Adapters\n\nAdapters translate `CalypsoResponse` into environment-specific behavior:\n\n[cols=\"1,2,2\"]\n|===\n| Adapter | Environment | Behavior\n\n| `BrowserAdapter`\n| Web browser (ARGUS UI)\n| Renders to Terminal, manipulates DOM, triggers animations\n\n| `CLIAdapter`\n| `calypso-cli` REPL\n| Prints to stdout, reads from stdin, no DOM\n\n| `NodeAdapter`\n| ORACLE test harness\n| Captures responses, ignores UI actions, enables state assertions\n|===\n\n== Operating Modes\n\nCalypso can run in three modes:\n\n=== Browser Mode (Full ARGUS)\n\nThe traditional mode where Calypso runs inside the ARGUS web application.\n\n[source,bash]\n----\n$ make serve\n# Open http://localhost:8080\n# Calypso is available in the Intelligence Console\n----\n\n=== Headless Mode (Standalone Server)\n\nCalypso runs as a Node.js server without a browser. Useful for testing, scripting, and CLI interaction.\n\n[source,bash]\n----\n$ make calypso\nStarting Calypso Server on :8081...\nCalypsoCore initialized (VFS: 47 nodes, Store: clean)\nReady for connections.\n----\n\n=== CLI Mode (Interactive REPL)\n\nA command-line client connects to the headless server. The CLI provides an SSH-style login experience, dynamic prompt with username and working directory, a spinner during async operations, and markdown-to-ANSI rendering of LLM responses.\n\n[source,bash]\n----\n$ make calypso-cli\n╔══════════════════════════════════════════════════════════════╗\n║  CALYPSO CORE V5.1.11                                        ║\n║  Cognitive Algorithms & Logic Yielding Predictive Scientific ║\n║  Outcomes                                                    ║\n╚══════════════════════════════════════════════════════════════╝\nConnected to localhost:8081\n\n┌──────────────────────────────────────────────┐\n│  CALYPSO REMOTE ACCESS TERMINAL              │\n│  Authorized personnel only.                  │\n└──────────────────────────────────────────────┘\nlogin: rudolph\n\n● Welcome, rudolph. I am CALYPSO, ready to assist with your\n  medical imaging workflows.\n○ The ATLAS catalog currently contains 6 datasets with 982\n  total images across 4 modalities.\n\nrudolph@CALYPSO:[~]> search histology\n● FOUND 1 MATCHING DATASET(S):\n  [ds-006] Histology Segmentation (Pathology/Segmentation)\n\nrudolph@CALYPSO:[~]> add that\n● DATASET GATHERED: Histology Segmentation [ds-006]\n○ MOUNTED TO [DRAFT-1234]\n\nrudolph@CALYPSO:[~/projects/DRAFT-1234]> tree input\ninput/\n├── ds-006/\n│   ├── images/\n│   └── metadata.json\n└── manifest.json\n\n3 directories, 2 files\n\nrudolph@CALYPSO:[~/projects/DRAFT-1234]> quit\nGoodbye.\n----\n\n==== CLI Features\n\n**Dynamic Prompt**: The prompt displays `<user>@CALYPSO:[<cwd>]>` with ANSI color coding (green user, cyan host, magenta path). It updates after every command to reflect the current working directory.\n\n**SSH-Style Login**: On startup, the CLI presents a login box. The entered username becomes the VFS home directory owner (e.g., `/home/rudolph/`).\n\n**LLM Greeting**: After login, Calypso generates a personalized greeting via the LLM, including facts about the available ATLAS datasets.\n\n**Spinner**: A braille-animation spinner (`⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏`) with \"CALYPSO thinking...\" displays during all async LLM operations.\n\n**Markdown Rendering**: LLM responses containing markdown are rendered with ANSI formatting:\n\n[cols=\"1,2\"]\n|===\n| Markdown Syntax | Terminal Rendering\n\n| `**bold text**`\n| Bold bright white\n\n| `*italic text*`\n| Italic\n\n| `` `code` ``\n| Yellow\n\n| `### Heading`\n| Bold cyan\n\n| `\\|table\\|rows\\|`\n| Box-drawing characters (┌─┬─┐)\n|===\n\n**Anaphora Resolution**: Pronouns like \"that\", \"it\", \"this\" in workflow commands (e.g., `add that`, `gather it`) resolve to the most recently discussed dataset(s). Plural forms (\"them\", \"those\") resolve to all recently mentioned datasets.\n\n== Visual Signature (Browser Mode)\n\nWhen running in browser mode, CALYPSO speaks in a distinct visual dialect:\n\n*   **Style:** \"MU/TH/UR 6000\" (Retro-Industrial / Alien 1979).\n*   **Color:** **LCARS Sky Blue** (Integrated but distinct).\n*   **Typography:** `Share Tech Mono`, uppercase, wide tracking (2px), soft glow.\n*   **Animation:** Text streams character-by-character (Teletype effect), non-blocking.\n\n== Interaction Model\n\nCALYPSO is helpful but industrial. She uses \"I\" to refer to herself but maintains a professional, research-focused demeanor.\n\n=== Response Markers\n\n*   **Affirmation:** `● AFFIRMATIVE.`\n*   **Data Presentation:** `○ DISPLAYING RESULTS.`\n*   **Error:** `>> ERROR: <description>`\n*   **Warning:** `>> WARNING: <description>`\n\n=== Voice Modulation\n\nUsers can adjust Calypso's communication style:\n\n[cols=\"1,2,2\"]\n|===\n| Command | Effect | Response Format\n\n| `quiet` / `mute` / `silence`\n| Disable idle monitoring\n| Silent until reactivated\n\n| `speak` / `unmute`\n| Re-enable voice\n| Resumes normal operation\n\n| `soft voice`\n| Use sentence case\n| \"Affirmative. Scan complete.\"\n\n| `normal voice` / `shout`\n| Use uppercase (default)\n| \"● AFFIRMATIVE. SCAN COMPLETE.\"\n|===\n\n=== Idle Monitoring System (Browser Mode)\n\nCalypso proactively monitors user engagement to prevent workflow stalling.\n\n*   **Trigger:** If the user remains inactive for 10 seconds (mouse/keyboard idle), Calypso initiates a check-in.\n*   **Context Awareness:** She analyzes the current stage and selection buffer to offer specific advice (e.g., \"Buffer empty, try searching for...\" vs. \"Buffer full, ready to code?\").\n*   **Persistence:** If inactivity continues, she checks back semi-randomly (every 20-50s) to maintain presence.\n*   **Mute Protocol:** Users can silence her by typing \"Mute\", \"Quiet\", or \"Silence\". She can be reactivated with \"Speak\" or \"Unmute\".\n\nNOTE: Idle monitoring is only active in browser mode. Headless mode and CLI mode do not implement idle timers.\n\n== Special Commands\n\nIn addition to natural language, Calypso recognizes special commands prefixed with `/`:\n\n[cols=\"1,3\"]\n|===\n| Command | Description\n\n| `/status`\n| Show system status (AI core mode, VFS, project, selected datasets)\n\n| `/key <provider> <key>`\n| Set API key at runtime (`openai` or `gemini`). Activates real LLM mode.\n\n| `/snapshot [path]`\n| Returns JSON snapshot of VFS subtree (default: entire tree)\n\n| `/state`\n| Returns JSON snapshot of Store state\n\n| `/store <property>`\n| Returns specific store property value\n\n| `/reset`\n| Resets VFS and Store to clean state\n\n| `/help`\n| Lists available commands\n\n| `/version`\n| Displays Calypso version and build info\n|===\n\nThese commands are primarily used for debugging and ORACLE testing, but are available in all modes.\n\n== Source Structure\n\n[source]\n----\nsrc/lcarslm/\n├── CalypsoCore.ts          # DOM-free orchestrator (NEW)\n├── engine.ts               # LCARSEngine: LLM client wrapper\n├── client.ts               # OpenAI client\n├── gemini.ts               # Gemini client\n├── types.ts                # CalypsoResponse, CalypsoAction, Intent\n│\n├── adapters/\n│   ├── BrowserAdapter.ts   # Connects CalypsoCore → Terminal + DOM\n│   ├── CLIAdapter.ts       # Connects CalypsoCore → stdout/stdin\n│   └── NodeAdapter.ts      # Connects CalypsoCore → test harness\n│\n└── AIService.ts            # Legacy browser integration (uses BrowserAdapter)\n\nsrc/cli/\n├── calypso-server.ts       # Headless server entry point\n└── calypso-cli.ts          # CLI REPL client\n----\n\n== Integration with ORACLE\n\nThe headless architecture enables the ORACLE testing methodology. See `docs/oracle.adoc` for the full specification.\n\nIn summary:\n1. ORACLE test scripts send commands to CalypsoCore\n2. CalypsoCore executes against VFS/Store (deterministic)\n3. Tests assert on resulting state (VFS snapshots, Store properties)\n4. UI rendering is bypassed — testing the logic, not the presentation\n\nThis separation allows:\n- Fast CI tests (no browser startup)\n- Fault isolation (core logic vs UI rendering)\n- CLI-based development workflows\n- Scripted automation\n\n== Future Enhancements\n\n=== Planned\n\n1. **Persistent Sessions**: Save/restore VFS and Store state across CLI sessions\n2. **Script Mode**: Execute `.calypso` script files for batch operations\n3. **Remote Mode**: Connect CLI to a remote ARGUS instance for debugging\n4. **Plugin System**: Register custom commands and intent handlers\n\n=== Research\n\n1. **Multi-Agent**: Multiple Calypso instances collaborating on complex workflows\n2. **Learning Mode**: Calypso adapts intent classification based on user corrections\n3. **Voice Interface**: Speech-to-text input, text-to-speech output\n\n---\n_Last updated: {revdate} (v{revnumber})_",
    "design.adoc": "= ARGUS Design Specification (v3.5.0)\n:toc:\n:toclevels: 3\n\n== 1. The SeaGaP-MP Paradigm\nARGUS implements the **Search, Gather, Process, Monitor, Post** workflow, specifically tailored for the **ATLAS/MERIDIAN** federated learning ecosystem.\n\n== 2. Architectural Structure (Pub/Sub)\nTo maintain a high-performance Vanilla TypeScript frontend while ensuring state synchronization, the application uses an **Event-Driven Observer Pattern**.\n\n=== 2.1 Central Store (`src/core/state/store.ts`)\nThe `Store` class encapsulates the application state and provides discrete **Actions** for mutation. All Store methods follow the RPN naming convention (e.g., `stage_set()`, `dataset_toggle()`, `marketplace_toggle()`, `asset_install()`). It maintains references to global singletons including the `VirtualFileSystem`, `Shell`, `LCARSTerminal`, and `FrameSlot`.\n\n=== 2.2 Event Bus (`src/core/state/events.ts`)\nA lightweight, typed `EventEmitter` facilitates communication between decoupled modules.\n*   **Decoupling:** `navigation.ts` doesn't need to know about `process.ts`. It simply dispatches `STAGE_CHANGED`.\n*   **Reactivity:** Modules like `telemetry.ts` and `gather.ts` subscribe to events to update their respective UI components.\n*   **Type Safety:** Each event maps to a specific payload type via `EventPayloads` interface.\n\n== 3. The Federalization Model\nThe transition from local development (**Process**) to distributed execution (**Monitor**) is mediated by the **Federalization Sequence**.\n\n=== 3.1 The Factory Concept\nRaw code assets (`train.py`) are not executed locally. Instead, the `federate` command triggers a build process:\n1.  **Ingestion:** Assets are sent to the ATLAS Hub.\n2.  **Containerization:** The ATLAS Factory wraps the code into a MERIDIAN App.\n3.  **Distribution:** Container images are dispatched to Trusted Domains (BCH, MGH, etc.).\n4.  **Synchronization:** Training only begins once all nodes verify the payload.\n\nThe sequence is orchestrated by `federation_sequence()` in `process.ts`, decomposed into four phases: `federationOverlay_initialize()`, `federationBuild_run()`, `federationDistribution_run()`, and `federationHandshake_run()`.\n\n=== 3.2 The Simulation Loop (Local Testbed)\nBefore federalization, code must pass a **Phantom Federation** check. This local simulation validates that:\n1.  **Serialization**: Model weights can be serialized and deserialized.\n2.  **Aggregation**: The aggregation algorithm converges on local data shards.\n3.  **Privacy**: Differential privacy noise budgets are respected.\n\nThe `simulate` command shards the local VFS `input/` directory into ephemeral \"Phantom Nodes\" and runs the federation cycle in-memory. Only successful simulation unlocks the external federation capability.\n\n== 4. Virtual Computer System (VCS)\nA complete Virtual Computer System (`src/vfs/`) provides the stateful runtime environment underlying the ARGUS Intelligence Terminal. The VCS comprises:\n\n*   **VirtualFileSystem** (`src/vfs/VirtualFileSystem.ts`): In-memory POSIX-like filesystem with content-aware files, path resolution, lazy content generation, and event emission.\n*   **Shell** (`src/vfs/Shell.ts`): Command interpreter with 15 builtins, environment variables, `$PS1` prompt generation, and stage transitions.\n*   **ContentRegistry** (`src/vfs/content/ContentRegistry.ts`): Maps file paths to content generators. 14 templates generate file bodies on demand.\n*   **Providers**: Three providers translate application domain objects into filesystem trees:\n    - `DatasetProvider` — builds `~/data/cohort/` from selected datasets\n    - `ProjectProvider` — scaffolds `$HOME` and populates `~/src/project/`\n    - `MarketplaceProvider` — installs assets to `/bin/`, `/data/sets/`, `~/models/`, etc.\n\nThis ensures that the **Terminal**, **IDE**, and **Marketplace** share a consistent, content-rich view of the project structure. See `docs/vcs.adoc` for the full specification.",
    "dev.adoc": "= ARGUS Developer Notes\n:author: ATLAS Project Team\n:revdate: 2026-01-29\n:toc:\n:toclevels: 3\n\n== LCARS UI Refactoring: Lessons Learned\n\nThis document captures the lessons learned during the LCARS UI refactoring of ARGUS v0.2.0. It serves as a reference for future developers (human or AI agent) to understand the correct approach to implementing LCARS-style interfaces.\n\n=== The Problem: Initial Implementation Was Wrong\n\nThe initial ARGUS UI implementation attempted to create an \"LCARS-inspired\" interface from scratch without properly referencing the established LCARS Lower Decks theme. This resulted in:\n\n* Incorrect panel structure (missing the stacked colored panel divs)\n* Missing black borders between bars and panels\n* Incorrect bar width proportions\n* Missing corner elbow effects (60x60px gradient-based pseudo-elements)\n* Navigation buttons that didn't match the LCARS pill-button aesthetic\n* Overall layout that felt \"off\" compared to authentic LCARS\n\n=== The Solution: Use the Reference Implementation\n\nThe slidedown project contains a complete, working LCARS Lower Decks theme implementation at:\n\n----\n/home/rudolphpienaar/src/slidedown/themes/lcars-lower-decks/\n├── templates/lcars-frame.html   # Reference HTML structure\n└── theme.css                    # Complete LCARS CSS (~2100 lines)\n----\n\nThis is the authoritative reference by Jim Robertus (www.thelcars.com) and should be used as the template for any LCARS UI work.\n\n=== Critical LCARS Structure Requirements\n\n==== HTML Structure\n\nThe correct LCARS layout uses a specific nested structure:\n\n[source,html]\n----\n<section class=\"wrap-all\">\n    <!-- TOP SECTION -->\n    <div class=\"wrap\">\n        <div class=\"left-frame-top\">\n            <div class=\"panel-1\">...</div>\n            <div class=\"panel-2\">...</div>\n        </div>\n        <div class=\"right-frame-top\">\n            <div class=\"banner\">TITLE</div>\n            <div class=\"bar-panel first-bar-panel\">\n                <div class=\"bar-1\"></div>\n                <div class=\"bar-2\"></div>\n                <div class=\"bar-3\"></div>\n                <div class=\"bar-4\"></div>\n                <div class=\"bar-5\"></div>\n            </div>\n        </div>\n    </div>\n\n    <!-- BOTTOM SECTION (with gap) -->\n    <div class=\"wrap\" id=\"gap\">\n        <div class=\"left-frame\">\n            <div class=\"panel-3\">...</div>\n            <div class=\"panel-4\">...</div>\n            <div class=\"panel-5\">...</div>\n            <div class=\"panel-6\">...</div>\n            <div class=\"panel-7\">...</div>\n        </div>\n        <div class=\"right-frame\">\n            <div class=\"bar-panel\">\n                <div class=\"bar-6\"></div>\n                <div class=\"bar-7\"></div>\n                <div class=\"bar-8\"></div>\n                <div class=\"bar-9\"></div>\n                <div class=\"bar-10\"></div>\n            </div>\n            <main id=\"main-content\">...</main>\n        </div>\n    </div>\n</section>\n----\n\n==== CSS Variables\n\nEssential CSS custom properties that must be defined:\n\n[source,css]\n----\n:root {\n    /* Frame dimensions */\n    --lfw: 240px;                    /* Left frame width */\n    --bar-height: 28px;              /* Height of bar panels */\n\n    /* Bar widths (must total ~100% with flex on bar-4/bar-9) */\n    --bar-1-6-width: 10%;\n    --bar-2-7-width: 12%;\n    --bar-3-8-width: 17%;\n    --bar-5-10-width: 5%;\n\n    /* Critical: Black borders between elements */\n    --panel-border: .4rem solid black;\n    --bar-border: .4rem solid black;\n\n    /* Cut-out notch dimensions */\n    --bar-cut-width: 32%;\n    --bar-cut-out-width: 40%;\n\n    /* LCARS Colors (Lower Decks palette) */\n    --african-violet: #b48cc8;\n    --mars: #d38c8b;\n    --tamarillo: #a93734;\n    --ice-cold: #a3f4f7;\n    --sundown: #f4b4c0;\n    --harvestgold: #d4a454;\n    --almond-frost: #a08484;\n    --butterscotch: #d49448;\n}\n----\n\n==== Bar Cut-out Notches\n\nBars 4 and 9 require pseudo-elements to create the characteristic LCARS cut-out corners:\n\n[source,css]\n----\n.bar-4::after,\n.bar-9::after {\n    content: \"\";\n    width: var(--bar-cut-width);\n    height: 48%;\n    background-color: black;\n    border-radius: 0 8px 0 0;\n    position: absolute;\n    left: 0;\n    bottom: 0;\n}\n----\n\n==== Corner Elbows\n\nThe curved corners on the left frame require gradient-based pseudo-elements:\n\n[source,css]\n----\n.left-frame-top::after,\n.left-frame::before {\n    content: \"\";\n    position: absolute;\n    width: 60px;\n    height: 60px;\n    background: radial-gradient(\n        circle at 0% 0%,\n        transparent 55px,\n        var(--elbow-color) 55px,\n        var(--elbow-color) 60px,\n        transparent 60px\n    );\n}\n----\n\n=== TypeScript/JavaScript Coordination\n\nWhen the HTML structure changes, the TypeScript must be updated to match:\n\n|===\n| HTML Change | TypeScript Update Required\n\n| `.persona-pill` -> `.persona-btn`\n| Update all `querySelectorAll('.persona-pill')` calls\n\n| `.stage-btn` -> `.stage-indicator`\n| Update stage navigation selectors and event handlers\n\n| New elements (e.g., toggle button)\n| Add handler functions and expose to window\n|===\n\n==== Exposing Functions to Window\n\nFor `onclick` handlers in HTML, functions must be exposed to the window object using typed `declare global` extensions:\n\n[source,typescript]\n----\n// In the module that defines the functions:\ndeclare global {\n    interface Window {\n        myFunction: typeof myFunction;\n    }\n}\n\n// Assign to window (type-safe, no 'any' cast):\nwindow.myFunction = myFunction;\n----\n\nThis pattern replaces the legacy `(window as any).functionName = functionName` approach. All modules that expose window bindings now use typed Window interface extensions: `argus.ts`, `marketplace/view.ts`, `ui/components/LCARSFrame.ts`.\n\n=== File Mapping: ARGUS to LCARS Reference\n\n|===\n| ARGUS File | Reference Source | Purpose\n\n| `dist/index.html`\n| `slidedown/.../lcars-frame.html`\n| HTML structure template\n\n| `dist/css/lcars.css`\n| `slidedown/.../theme.css`\n| Complete LCARS styling\n\n| `src/argus.ts`\n| N/A (ARGUS-specific)\n| Application entry point and orchestration\n|===\n\n=== Debugging LCARS Layout Issues\n\nIf the LCARS layout looks wrong:\n\n1. **Compare against reference screenshot** - Keep `tmp/lcars.png` as the visual target\n2. **Check bar borders** - Every bar except bar-4, bar-5, bar-9, bar-10 needs `border-right: var(--bar-border)`\n3. **Verify panel borders** - Panels need `border-bottom: var(--panel-border)`\n4. **Check cut-out pseudo-elements** - bar-4 and bar-9 need `::after` elements with black background\n5. **Verify corner elbows** - Check `::before` and `::after` on `.left-frame-top` and `.left-frame`\n6. **Check flex settings** - bar-4 and bar-9 should be `flex: 1` to fill remaining space\n\n=== Build and Test Commands\n\n[source,bash]\n----\n# Full rebuild\nmake argus\n\n# Quick build (TypeScript only)\nmake build\n\n# Development server\nmake serve\n\n# Watch mode (auto-rebuild on changes)\nmake watch\n\n# Run all tests (134 tests)\nnpm run test\n----\n\n== Top Frame Redesign: SeaGaP Tracker (v1.2.0 - v1.3.0)\n\n=== Design Evolution: From Accordion to \"Hanging Subway\"\n\nThe initial top frame design used a horizontal accordion. While functional, it lacked the \"command center\" feel of LCARS. The design evolved into a \"Hanging Subway\" layout:\n\n* **Top-Aligned Stations:** The station circles are anchored to the top of the panel, creating a persistent, straight \"subway line\" that never jumps.\n* **Hanging Telemetry:** Instead of expanding sideways, telemetry windows \"hang\" down from the active station.\n* **Multi-Window Display:**\n    * **Active Station:** Large, detailed window with real-time stats.\n    * **Visited Stations:** Compact, dimmed windows to the left, showing summary stats.\n* **Global Ticker:** A single heartbeat loop updates all visible telemetry windows simultaneously, creating a busy, living dashboard effect.\n\n==== CSS Implementation Details\n\n[source,css]\n----\n.seagap-stations {\n    align-items: flex-start; /* Anchors circles to top */\n}\n\n/* Reaching Connector Lines */\n.station-line {\n    margin-left: -55px;  /* Negative margins bridge the gap */\n    margin-right: -55px; /* between wide station containers */\n}\n\n/* Hanging Window Effect */\n.station-telemetry {\n    border-top: none; /* Seamless connection to station */\n    border-radius: 0 0 12px 12px;\n}\n----\n\n== Testing Strategy\n\n=== Framework\n\nVitest — chosen for native ESM/TypeScript support and speed.\n\n=== Test Suites\n\n[cols=\"2,1,3\"]\n|===\n| Suite | Tests | Scope\n\n| `src/vfs/VirtualFileSystem.test.ts`\n| 64\n| Path resolution, CWD, directory/file CRUD, node read/write/copy/move/remove, mount/unmount, lazy content generation, invalidation, event emission.\n\n| `src/vfs/Shell.test.ts`\n| 51\n| Environment variables, prompt generation with ~ substitution, command parsing, all 15 builtins (cd, pwd, ls, cat, mkdir, touch, rm, cp, mv, echo, env, export, whoami, date, history, help), stage transitions, external handler delegation.\n\n| `src/vfs/content/ContentRegistry.test.ts`\n| 16\n| Generator registration, path resolution, VFS integration (lazy generation + caching), all 8 core template generators.\n\n| `src/core/logic/costs.test.ts`\n| 3\n| Cost estimation engine.\n\n| **Total**\n| **134**\n|\n|===\n\n[source,bash]\n----\n# Run all tests\nnpm run test\n\n# Run specific suite\nnpx vitest run src/vfs/Shell.test.ts\n----\n\n== Version History\n\n|===\n| Version | Date | Changes\n\n| 0.1.0\n| 2026-01-23\n| Initial prototype (incorrect LCARS styling)\n\n| 0.2.0\n| 2026-01-24\n| Complete LCARS UI refactoring based on slidedown reference\n\n| 1.0.0\n| 2026-01-24\n| First stable release with complete SeaGaP workflow\n\n| 1.1.0\n| 2026-01-25\n| SeaGaP tracker navigation improvements\n\n| 1.2.0\n| 2026-01-25\n| Top frame redesign with subway-stop SeaGaP tracker, telemetry windows, elbow curve fix\n\n| 1.3.0\n| 2026-01-25\n| \"Hanging Subway\" layout, multi-window telemetry, Monitor stage fix, Vitest integration\n\n| 3.0.0\n| 2026-01-26\n| \"The Federalization Update\" — Pub/Sub architecture, Store + EventBus, `federate` command, full modularization\n\n| 3.1.0\n| 2026-01-26\n| \"The Marketplace Update\" — 400+ assets, category filtering, VFS integration\n\n| 3.2.1\n| 2026-01-26\n| \"The Telemetry Restore\" — Fixed telemetry regression, unified registry-based service\n\n| 3.3.0\n| 2026-01-28\n| \"The Modularization Update\" — Decoupled `lcars-framework`, procedural WorkflowTracker\n\n| 3.4.0\n| 2026-01-28\n| \"The Visual Language Update\" — Frame Slot system, Beckon Pulse, SlidePanel\n\n| 3.4.1\n| 2026-01-29\n| \"The VCS Update\" — Complete Virtual Computer System: VirtualFileSystem, Shell (15 builtins), ContentRegistry (14 generators), 3 Providers, 134 tests\n\n| 3.5.0\n| 2026-01-29\n| \"The Style Sweep\" — Comprehensive code audit: eliminated `any` from core, RPN-renamed 20+ functions, JSDoc on 50+ functions, decomposed long methods, typed all lambdas/params, `declare global` Window extensions\n|===",
    "experiences.adoc": "= ARGUS User Experiences: The SeaGaP-MP Workflow\n:revnumber: 4.6.0\n:revdate: 2026-02-01\n:toc: macro\n:sectanchors:\n\ntoc::[]\n\n== Overview\n\nThis document outlines the refined user experience (UX) in ARGUS v4.6.0. It describes the \"Filesystem First\" philosophy, where projects begin as simple directories and evolve into structured workspaces through interactive gathering and explicit initialization.\n\n== 1. Project Initialization: The \"Just a Folder\" Draft\n\nThe workflow begins in the **Search Stage**. To create a new context, the user interacts with the **Project Strip**.\n\n*   **The Beckon Pulse**: The `+ NEW` chip uses a high-visibility \"harvest gold\" pulse animation to attract the user's attention.\n*   **Draft Creation**: Clicking `+ NEW` immediately creates a \"Draft Project\" (e.g., `DRAFT-1234`).\n*   **VFS State**: At this stage, the project is \"Just a Folder\" at `~/projects/DRAFT-XXXX/`. No boilerplate code is generated yet, allowing for a clean, data-centric start.\n*   **Shell Sync**: The Intelligence Console (Terminal) automatically `cd`s into the new project root, and the prompt updates to reflect the new context.\n\n== 2. Discovery: Interaction with MU/TH/UR 6000\n\nWith a project context active, the user searches for data.\n\n*   **Intelligence Console**: The user types natural language queries (e.g., \"Show me histology data\") into the terminal.\n*   **MU/TH/UR Interface**: Responses from the AI Core are rendered in the **MU/TH/UR 6000** style:\n** **Visuals**: LCARS Sky Blue typography with wide tracking and a retro-industrial glow.\n** **Teletype Effect**: Text streams in character-by-character, simulating a real-time link to the Nostromo-era mainframe.\n** **Non-Blocking**: The user can continue typing or interacting with the UI while the AI response is streaming.\n*   **Grid Filtering**: The AI interprets intent. \"Search\" queries filter the dataset grid, while \"Open\" queries trigger the asset detail slide-out.\n\n== 3. Assembly: The Gather Cycle\n\nThe user assembles their cohort by browsing the catalog.\n\n*   **Persistent Workspace**: As datasets are gathered, they remain visible in a dedicated `WORKSPACE ASSETS` section at the top of the grid. New search results appear below in `SEARCH RESULTS`. This ensures the user never \"loses\" their active selection during deep searches.\n*   **Granular Selection**: Clicking a dataset tile opens the **Dataset Detail**. Users can long-press files to select specific subsets or click **ADD** to commit the entire dataset.\n*   **Input Mounting**: Gathered data is mounted into the project's virtual filesystem under the `input/` directory (e.g., `~/projects/MY-PROJECT/input/Dataset_Name/`).\n\n== 4. Refinement: Renaming and Context\n\nDrafts can be formalized at any time.\n\n*   **Interactive Rename**: Clicking the **RENAME** pill in the Project Detail overlay allows the user to give the project a meaningful name.\n*   **Atomic Move**: The system moves the VFS directory, updates the project model, and **synchronizes the terminal prompt** instantly to reflect the new path.\n\n== 5. Finalization: The \"CODE\" Directive\n\nWhen the user is ready to move from gathering data to writing logic, they use the **CODE** button (available in both the Search grid and the Project Detail).\n\n*   **Smart Branching**:\n** **If Initialized**: If the project already has a `src/` directory, the system jumps straight to the **Process Stage** (IDE).\n** **If Draft**: If the project is uninitialized, the system opens the Project Detail and presents the **SELECT WORKFLOW TYPE** interface.\n*   **Workspace Scaffolding**: The user chooses between a **Standard ChRIS App** or a **Federated ML Task**. The system then:\n1.  Creates the `src/`, `input/`, and `output/` directory structure.\n2.  Populates `src/` with canonically accurate template files (e.g., `app.py`, `Dockerfile`).\n3.  Expands the UI into the **Split-Pane Workspace**.\n\n== 6. Analysis: The Heterogeneity Check\n\nBefore committing to a federated training run, the engineer must validate that the gathered cohort is statistically viable. Training on non-IID (Independent and Identically Distributed) data—for example, mixing X-Ray and MRI modalities, or having one site with 90% positive labels and another with 10%—can cause the global model to fail.\n\n*   **Command**: `analyze cohort`\n*   **Visual Output**: The terminal renders an ASCII-based statistical report:\n    1.  **Modality Check**: Verifies all sites provide the same imaging modality. Flags mismatches (e.g., \"WARNING: MIXED MODALITIES DETECTED\").\n    2.  **Distribution Sparklines**: Visualizes label balance per site using text-based histograms (e.g., `[####----]`).\n*   **Workflow**: If the analysis reveals high heterogeneity, the user can return to the Gather stage to adjust the cohort or add preprocessing steps to the `src/` code to normalize the data.\n\n== 7. Development: The Local Loop\n\nBefore simulating federation, the developer must verify that their training code runs correctly on the local machine. This mirrors the standard \"edit-run-debug\" loop of traditional development.\n\n*   **Command**: `python train.py`\n*   **Behavior**: The shell executes the script against the local `input/` directory (which contains the gathered cohort).\n*   **Purpose**: Validates syntax, data loading, and model convergence on the raw data, ignoring all federation complexity.\n\n== 8. Simulation: The Phantom Federation\n\nTo bridge the gap between local development and global deployment, ARGUS enforces a \"Phantom Federation\" step. This allows the developer to test their federation logic (aggregation, privacy noise, serialization) in a local sandbox before deploying to secure partners.\n\n*   **Command**: `simulate federation`\n*   **Mechanism**: The system virtually shards the local gathered data into multiple \"Phantom Nodes\" (e.g., `phantom-1`, `phantom-2`).\n*   **Execution**: The training code runs against these phantom nodes locally.\n*   **Gatekeeper**: The **FEDERALIZE** button is initially **LOCKED**. It only unlocks after a successful simulation run proves that the code is federation-ready.\n\n== 9. Development: The 4-Tab IDE\n\nThe formalized workspace provides a professional development environment.\n\n*   **Split-Pane Layout**: The Intelligence Console stays at the top, while the Project Browser and Previewer fill the bottom.\n*   **The 4-Tab Model**: The File Browser is organized into logical views:\n1.  **ROOT**: The entire project repository (including `README.md`, `Dockerfile`).\n2.  **SOURCE**: Focused view of the `src/` directory.\n3.  **INPUT**: Access to all gathered datasets and local uploads.\n4.  **OUTPUT**: Destination for program results and logs.\n*   **Terminal Sync**: Navigating between tabs automatically `cd`s the shell to the corresponding directory, keeping the CLI and GUI in perfect lockstep.",
    "framework.adoc": "= ARGUS Framework Patterns\n:author: ATLAS Project Team\n:revdate: 2026-01-30\n:toc:\n:sectnums:\n\n== Purpose\n\nARGUS is built without a frontend framework (React, Vue, Svelte). Reactivity, component lifecycle, and DOM ownership are handled through project-specific patterns that have emerged organically during development. This document codifies those patterns as they exist today -- not as aspirational design, but as working conventions extracted from the codebase.\n\nThe goal is threefold:\n\n1. **Onboarding**: A new developer (human or AI) can read this document and understand how to add features without reverse-engineering implicit conventions.\n2. **Consistency**: Named patterns are referenceable. \"Use the slot pattern\" is an actionable instruction.\n3. **Guard rails**: Documented anti-patterns prevent re-invention of known mistakes.\n\n== Naming Convention: RPN\n\nAll functions follow **Reverse Polish Notation**: `<subject>_<verb>`.\n\n[source,typescript]\n----\n// Good\nfunction workspace_expand(): void { ... }\nfunction cohortTree_build(datasets: DatasetInput[]): FileNode { ... }\nfunction detailHeader_populate(asset, id, overlay, lcarsFrame): void { ... }\n\n// Bad\nfunction expandWorkspace(): void { ... }\nfunction buildCohortTree(datasets: DatasetInput[]): FileNode { ... }\n----\n\nThe subject is the thing being acted on. The verb is the action. This applies to:\n\n- Module-level functions: `catalog_search()`, `projectStrip_render()`\n- Class methods: `browser.trees_set()`, `browser.tab_switch()`, `shell.env_set()`\n- Store actions: `store.project_load()`, `store.marketplace_toggle()`\n- Event handlers: `selectionToggle_handle()`, `terminalCommand_handle()`\n\nPrivate helpers follow the same convention: `descendantPaths_collect()`, `imageWebUrl_resolve()`.\n\n== State Management: Store + EventBus\n\n=== Architecture\n\nApplication state is centralized in a single `Store` class (`src/core/state/store.ts`). The store holds:\n\n- **Reactive state** (`ExtendedState`): current stage, selected datasets, active project, training job, installed assets.\n- **Global singletons** (`globals`): terminal, VCS, shell, frame slot, AI engine.\n\nAll mutations go through Store actions, which emit typed events via the `EventBus` (`src/core/state/events.ts`).\n\n[source,typescript]\n----\n// Store action\npublic stage_set(stage: AppState['currentStage']): void {\n    this._state.currentStage = stage;\n    events.emit(Events.STAGE_CHANGED, stage);\n    events.emit(Events.STATE_CHANGED, this._state);\n}\n\n// Consumer subscribes\nevents.on(Events.STAGE_CHANGED, (newStage): void => {\n    stageContent_update(newStage);\n});\n----\n\n=== The `globals` Object\n\nThe `globals` bag on the Store holds runtime singletons that don't belong in serializable state:\n\n[cols=\"1,2\"]\n|===\n| Key | Type\n\n| `terminal` | `LCARSTerminal \\| null`\n| `vcs` | `VirtualFileSystem`\n| `shell` | `Shell \\| null`\n| `frameSlot` | `FrameSlot \\| null`\n| `lcarsEngine` | `LCARSEngine \\| null`\n| `lossChart` | `{ ctx, data } \\| null`\n| `trainingInterval` | `number \\| null`\n|===\n\nAccess via `import { globals } from '../state/store.js'`.\n\nIMPORTANT: The VCS instance is `globals.vcs`, not `globals.vfs`. This has caused bugs.\n\n=== Event Types\n\nAll events are typed via the `EventPayloads` interface. The compiler enforces payload types at both emit and subscribe sites:\n\n[source,typescript]\n----\nexport enum Events {\n    STATE_CHANGED       // payload: AppState\n    STAGE_CHANGED       // payload: AppState['currentStage']\n    DATASET_SELECTION_CHANGED  // payload: Dataset[]\n    PROJECT_LOADED      // payload: Project | null\n    VFS_UPDATED         // payload: void\n    VFS_CHANGED         // payload: VfsChangeEvent\n    CWD_CHANGED         // payload: CwdChangeEvent\n}\n----\n\n=== Rules\n\n1. **Never mutate `state` directly from outside the Store.** Use Store actions.\n2. **Emit `STATE_CHANGED` after every mutation.** Consumers may depend on any field.\n3. **`globals` is mutable by design** -- singletons are initialized at boot and nulled on teardown. Guard access with null checks.\n\n== The Command Router Pattern\n\n=== Problem\nThe main application entry point (`argus.ts`) should be an orchestrator, not a logic handler. Routing string commands (e.g., \"search\", \"mount\", \"federate\") in a massive switch statement inside `argus.ts` couples it tightly to every feature.\n\n=== Solution\nDelegate all command logic to a dedicated router (`src/core/logic/commands.ts`).\n\n[source,typescript]\n----\n// argus.ts (Entry Point)\nimport { command_dispatch } from './core/logic/commands.js';\nterminal.fallback_set(command_dispatch);\n\n// commands.ts (Router)\nexport async function command_dispatch(cmd: string, args: string[]): Promise<void> {\n    if (workflow_dispatch(cmd, args)) return;\n    await ai_query([cmd, ...args].join(' '));\n}\n----\n\n== The Stage Lifecycle Pattern\n\n=== Problem\nStage transitions (Search -> Process) require setup and teardown logic (e.g., opening the terminal, populating the IDE). Hardcoding this in `argus.ts` makes it a \"God Object.\"\n\n=== Solution\nInvert control. Each stage module exports `stage_enter()` and `stage_exit()` hooks. The orchestrator simply calls them.\n\n[source,typescript]\n----\n// src/core/stages/process.ts\nexport function stage_enter(): void {\n    projectDir_populate(...);\n    globals.frameSlot.frame_open();\n}\nexport function stage_exit(): void {\n    // Cleanup\n}\n\n// argus.ts\nconst newHandler = STAGE_HANDLERS[stageName];\nif (newHandler) newHandler.stage_enter();\n----\n\n== The Window Binding Registry Pattern\n\n=== Problem\nHTML `onclick=\"myFunc()\"` requires `myFunc` to be on `window`. Scattering `window.foo = foo` assignments throughout the codebase is untidy and bypasses type safety.\n\n=== Solution\nCentralize all bindings in `src/core/logic/WindowBindings.ts`. This provides a single manifest of the application's public DOM API.\n\n[source,typescript]\n----\n// WindowBindings.ts\ndeclare global {\n    interface Window {\n        myFunction: typeof myFunction;\n    }\n}\n\nexport function windowBindings_initialize(): void {\n    window.myFunction = myFunction;\n}\n----\n\n== The Slot Pattern\n\n=== Problem\n\nMultiple consumers need to display different content inside a shared DOM container (e.g., the asset detail overlay is used by marketplace, project detail, and dataset detail). The naive approach -- rewriting `innerHTML` on open and restoring it on close -- is fragile. If any consumer forgets to restore, the next consumer inherits corrupted DOM.\n\n=== Solution\n\nThe shared container holds the **default consumer's** content as static HTML. Additional consumers get empty **slot containers** -- `<div>` elements that are hidden by default and shown on demand via a CSS `data-mode` attribute.\n\n==== DOM Structure\n\n[source,html]\n----\n<div id=\"asset-detail-overlay\" data-mode=\"marketplace\">\n    <!-- Original marketplace content (never mutated) -->\n    <div class=\"lcars-sidebar\">...</div>\n    <div id=\"overlay-sidebar-slot\" class=\"lcars-sidebar overlay-slot\"></div>\n\n    <div class=\"lcars-content\">...</div>\n    <div id=\"overlay-content-slot\" class=\"lcars-content overlay-slot\"></div>\n\n    <div class=\"detail-command-column\">...</div>\n    <div id=\"overlay-command-slot\" class=\"detail-command-column overlay-slot\"></div>\n</div>\n----\n\n==== CSS Visibility Rules\n\n[source,css]\n----\n/* Default mode: hide slots */\n#asset-detail-overlay[data-mode=\"marketplace\"] .overlay-slot {\n    display: none !important;\n}\n\n/* Project/dataset modes: hide originals, show slots */\n#asset-detail-overlay[data-mode=\"project\"] .lcars-sidebar:not(.overlay-slot),\n#asset-detail-overlay[data-mode=\"project\"] .lcars-content:not(.overlay-slot),\n#asset-detail-overlay[data-mode=\"project\"] .detail-command-column:not(.overlay-slot) {\n    display: none !important;\n}\n----\n\n==== Consumer Contract\n\nOpening a non-default consumer:\n\n[source,typescript]\n----\n// 1. Set mode\noverlay.dataset.mode = 'project';\n\n// 2. Write into slots (never touch originals)\nconst sidebarSlot = document.getElementById('overlay-sidebar-slot');\nsidebarSlot.innerHTML = '...';\n\nconst contentSlot = document.getElementById('overlay-content-slot');\ncontentSlot.innerHTML = '...';\n\nconst commandSlot = document.getElementById('overlay-command-slot');\ncommandSlot.innerHTML = '...';\n----\n\nClosing a non-default consumer:\n\n[source,typescript]\n----\n// 1. Clear slots\noverlaySlots_clear();\n\n// 2. Reset mode -- CSS shows originals, hides (now-empty) slots\noverlay.dataset.mode = 'marketplace';\n----\n\nThe `overlaySlots_clear()` helper is defined in `search.ts`:\n\n[source,typescript]\n----\nfunction overlaySlots_clear(): void {\n    const sidebarSlot = document.getElementById('overlay-sidebar-slot');\n    const contentSlot = document.getElementById('overlay-content-slot');\n    const commandSlot = document.getElementById('overlay-command-slot');\n    if (sidebarSlot) sidebarSlot.innerHTML = '';\n    if (contentSlot) contentSlot.innerHTML = '';\n    if (commandSlot) commandSlot.innerHTML = '';\n}\n----\n\n=== When to Use\n\nUse the slot pattern whenever multiple consumers share a DOM container. The default consumer's content stays as static HTML. Each additional consumer gets a slot.\n\n=== Anti-Pattern: innerHTML Restore\n\n[WARNING]\n====\n*Do not* cache `innerHTML` on open and restore it on close. This was the original approach in ARGUS (`detailContent_restore()`). It failed when `datasetDetail_populate()` replaced the command column's `innerHTML` with DONE/ADD/CANCEL pills, but `datasetDetail_close()` only restored `.lcars-content` -- not the command column. When a marketplace asset was opened next, it showed gather pills instead of INSTALL/CLOSE.\n\nThe slot pattern eliminates this entire class of bug. The marketplace's original DOM is never read, cached, or written. Mode switching is pure CSS visibility.\n====\n\n== The Populate / Teardown Lifecycle\n\n=== The Pattern\n\nEvery overlay consumer follows the same implicit lifecycle:\n\n----\npopulate → show → [expand] → [collapse] → close → clear\n----\n\n[cols=\"1,3\"]\n|===\n| Phase | Responsibility\n\n| **populate** | Write content into the appropriate containers (slots or originals). Set LCARS hue, header fields, event listeners.\n| **show** | Remove `hidden` / `closing` classes from the overlay. Trigger slide-in animation.\n| **expand** _(optional)_ | Transform the overlay into a workspace layout (split-pane, resize handles).\n| **collapse** _(optional)_ | Reverse workspace expansion. Remove resize handles, restore layout.\n| **close** | Trigger slide-out animation. On `animationend`, add `hidden` class.\n| **clear** | Clear slot innerHTML, reset `data-mode`, destroy component instances (FileBrowser).\n|===\n\n=== Critical Rule: Teardown Before Stage Transition\n\n[IMPORTANT]\n====\nAny code that transitions away from an active workspace **MUST** call `workspace_teardown()` first. The workspace sets `display: none` on the search stage content, adds `workspace-active` to the right-frame, and keeps the asset-detail overlay visible. If these aren't reversed, the destination stage's content renders behind the overlay and is invisible.\n\nThis rule was learned when `federationHandshake_run()` in `process.ts` called `stage_advanceTo('monitor')` without collapsing the workspace. The monitor stage content was correctly activated but invisible behind the expanded overlay.\n====\n\n`workspace_teardown()` is the canonical cleanup function:\n\n[source,typescript]\n----\nexport function workspace_teardown(): void {\n    if (isWorkspaceExpanded) {\n        workspace_collapse();    // resize handles, layout, stage content\n    }\n    overlay.classList.add('hidden');\n    overlay.dataset.mode = 'marketplace';\n    overlaySlots_clear();\n    if (globals.frameSlot?.state_isOpen()) {\n        globals.frameSlot.frame_close();\n    }\n}\n----\n\n== The Component Pattern\n\nARGUS uses two styles of reusable UI element: **class components** and **render functions**.\n\n=== Class Components\n\nUsed when the component has internal state, event listeners, or a destroy lifecycle.\n\n==== FileBrowser\n\n`src/ui/components/FileBrowser.ts`\n\nThe most complex component. Renders a VFS file tree with preview pane, supports multiple named tabs, and an optional selectable mode for gathering.\n\n**Constructor options:**\n[source,typescript]\n----\ninterface FileBrowserOptions {\n    treeContainer: HTMLElement;\n    previewContainer: HTMLElement;\n    vfs: VirtualFileSystem;\n    projectBase: string;\n    selectable?: boolean;\n    onSelectionChange?: (selectedPaths: string[]) => void;\n}\n----\n\n**Public API (RPN convention):**\n[cols=\"2,3\"]\n|===\n| Method | Purpose\n\n| `trees_set(trees)` | Set named tree roots (e.g. `{ source: srcNode, data: dataNode }`)\n| `tab_switch(tabId)` | Switch active tree and re-render\n| `tree_render()` | Render active tree into DOM\n| `preview_show(path, display)` | Read VFS content, syntax-highlight, display in preview pane\n| `activeTab_get()` | Return current tab ID\n| `selection_get()` | Return selected file paths (selectable mode)\n| `selection_clear()` | Clear all selections\n| `selectionSubtree_extract(root)` | Return pruned tree containing only selected files + skeleton dirs\n| `destroy()` | Clear DOM references, timers, callbacks\n|===\n\n**Selectable mode**: Activated via `selectable: true`. Short click = preview. Long press (500ms) = toggle selection. Long press on folder cascades to all descendants.\n\n**Lifecycle rule**: Always call `destroy()` before discarding a FileBrowser instance. The component holds event listeners that will leak otherwise.\n\n==== FrameSlot\n\n`src/ui/components/FrameSlot.ts`\n\nOrchestrates the two-phase \"double whammy\" animation (frame separation + content slide-in). See `docs/visual_language.adoc` for the animation spec.\n\n==== LCARSTerminal\n\n`src/ui/components/Terminal.ts`\n\nGlobal singleton terminal with command registration, AI mode, and status bar.\n\n=== Render Functions\n\nUsed for stateless, declarative HTML generation. No lifecycle, no event listeners (those are attached by the caller via `onclick` strings).\n\n==== AssetCard\n\n`src/ui/components/AssetCard.ts`\n\nReturns an HTML string for a grid tile. Used by both Marketplace and Search stages.\n\n[source,typescript]\n----\ninterface AssetCardOptions {\n    id: string;\n    type: string;\n    title: string;\n    description: string;\n    metaLeft: string;\n    metaRight: string;\n    badgeText: string;\n    badgeRightText?: string;\n    isInstalled?: boolean;\n    onClick: string;          // onclick handler as string\n    actionButton?: { label, activeLabel?, onClick, isActive? };\n}\n\nconst html: string = render_assetCard(opts);\ncontainer.innerHTML = cards.map(render_assetCard).join('');\n----\n\n**Note**: `onClick` is a string (e.g. `\"assetDetail_open('abc')\"`), not a function reference. This is because the HTML is inserted via `innerHTML`. The target function must be exposed on `window` via typed declarations:\n\n[source,typescript]\n----\n// Use WindowBindings.ts registry\ndeclare global {\n    interface Window {\n        assetDetail_open: typeof assetDetail_open;\n    }\n}\n----\n\n=== Choosing Between Styles\n\n[cols=\"1,1,3\"]\n|===\n| Style | Example | When to Use\n\n| Class component | FileBrowser | Has internal state, event listeners, needs explicit destroy\n| Render function | AssetCard | Stateless HTML generation, no lifecycle\n|===\n\n== The Provider Pattern\n\nProviders translate domain data into VCS filesystem trees. They are pure functions that take domain objects and return `FileNode` trees suitable for mounting.\n\n=== Existing Providers\n\n[cols=\"2,3,2\"]\n|===\n| Provider | Purpose | Location\n\n| `DatasetProvider` | Builds cohort tree from datasets (`/data/training/`, `/data/validation/`) | `src/vfs/providers/DatasetProvider.ts`\n| `ProjectProvider` | Scaffolds project directory (`~/projects/{name}/src/`, config files) | `src/vfs/providers/ProjectProvider.ts`\n| `MarketplaceProvider` | Installs assets to VCS (`/bin/`, `/data/sets/`, `~/models/`) | `src/vfs/providers/MarketplaceProvider.ts`\n|===\n\n=== Contract\n\nA provider:\n\n1. Accepts domain data (datasets, project config, marketplace asset) as input.\n2. Returns a `FileNode` tree (or mutates the VCS directly for `MarketplaceProvider`).\n3. Uses `contentGenerator` strings for lazy file content (evaluated by `ContentRegistry` on read).\n4. Sets `metadata` on nodes for consumer-specific data (e.g., `imageWebBase` for web-servable image URLs).\n\n=== Usage Pattern\n\n[source,typescript]\n----\nimport { cohortTree_build } from '../../vfs/providers/DatasetProvider.js';\n\n// Build tree\nconst dataRoot: VcsFileNode = cohortTree_build(project.datasets);\n\n// Mount into VCS\nglobals.vcs.tree_unmount(`${projectBase}/data`);\nglobals.vcs.tree_mount(`${projectBase}/data`, dataRoot);\n----\n\nAlways `tree_unmount` before `tree_mount` to avoid stale data from a previous mount.\n\n== The Strip Pattern\n\nA horizontal bar of compact chips that persists across context changes. Used for the project strip at the top of the Search stage.\n\n=== Structure\n\n[source,html]\n----\n<div class=\"project-strip\" id=\"project-strip\">\n    <!-- Populated by projectStrip_render() -->\n</div>\n----\n\nThe strip is re-rendered on every state change by calling `projectStrip_render()`. Chips have click handlers attached after render via `addEventListener` (not inline `onclick`).\n\n=== Visual States\n\n[cols=\"1,3\"]\n|===\n| State | Appearance\n\n| Default | Honey border, dark background, `border-radius: 100vmax` (LCARS pill)\n| Active (gather target) | Solid honey background, black text, glow\n| New project | Dashed harvestgold border\n|===\n\n=== Interaction\n\n- First click: set as gather target.\n- Second click (already active): open detail overlay.\n- \"+ NEW\" chip: clear gather target, enter new-project mode.\n\n== The Selectable Mode Pattern\n\nAny tree-based component can support granular selection via long-press interaction.\n\n=== Activation\n\nPass `selectable: true` to the component constructor. The component manages its own `selectedPaths: Set<string>` and reports changes via the `onSelectionChange` callback.\n\n=== Interaction Model\n\n[cols=\"1,3\"]\n|===\n| Gesture | Effect\n\n| Short click (< 500ms) on file | Preview file content (standard behavior)\n| Short click on folder | Toggle folder open/closed\n| Long press (>= 500ms) on file | Toggle selection of individual file\n| Long press on folder | Toggle all descendant files (select all / deselect all)\n|===\n\n=== Subtree Extraction\n\nAfter selection, call `selectionSubtree_extract(root)` to get a pruned copy of the tree containing only selected files and the directory skeleton needed to reach them. This is used by the gather flow to mount partial datasets into a project's VCS tree.\n\n=== Visual Feedback\n\nSelected items receive the `.selected-for-gather` CSS class: canary left-border, subtle background tint, checkmark prefix.\n\n== CSS Architecture\n\n=== File Organization\n\n[cols=\"2,3\"]\n|===\n| File | Scope\n\n| `dist/css/lcars.css` | Global layout, frame, bars, project strip, workspace handles, selection visuals\n| `dist/css/lcars-components.css` | LCARS frame component system (hue-based shading, panels, elbows)\n| `dist/css/marketplace.css` | Marketplace overlay, asset detail overlay, command pills, slot visibility rules, gather pills\n| `dist/css/federation.css` | Federation animation overlay\n|===\n\n=== The Hue System\n\nAll LCARS component colors derive from `--lcars-hue` (0-360). Set the hue on a `.lcars-frame` and all child panels, elbows, and bars inherit computed HSL shades. See `docs/lcars.adoc` for the full spec.\n\n=== Naming\n\nCSS classes follow BEM-like conventions but without strict BEM syntax:\n\n- `.market-card` (block)\n- `.card-header`, `.card-title`, `.card-desc` (elements)\n- `.market-card.installed`, `.market-card.fda` (modifiers)\n- `.workspace-expanded`, `.command-col-hiding` (state classes)\n\n== TypeScript Conventions\n\n=== Explicit Typing\n\nEvery `const`, parameter, return type, and lambda parameter has an explicit type annotation:\n\n[source,typescript]\n----\n// Good\nconst overlay: HTMLElement | null = document.getElementById('asset-detail-overlay');\nconst filtered: Dataset[] = DATASETS.filter((ds: Dataset): boolean => { ... });\n\n// Bad\nconst overlay = document.getElementById('asset-detail-overlay');\nconst filtered = DATASETS.filter(ds => { ... });\n----\n\n=== No `any`\n\n`any` is eliminated from core application code. Use `unknown` with `instanceof` narrowing for catch blocks:\n\n[source,typescript]\n----\ntry { ... } catch (e: unknown) {\n    if (e instanceof Error) {\n        globals.terminal?.println(`Error: ${e.message}`);\n    }\n}\n----\n\n=== Module Exports\n\n- Functions intended for cross-module use are explicitly `export`ed.\n- Module-level state (e.g., `let isWorkspaceExpanded`) is private by default.\n- Types are exported via `export type` or `export interface`.\n\n== Testing Strategy\n\n=== Current Coverage\n\n[cols=\"2,1,2\"]\n|===\n| Suite | Tests | Focus\n\n| VirtualFileSystem | 64 | Path resolution, CWD, CRUD, mount/unmount, lazy content, events\n| Shell | 57 | Env vars, prompt, builtins, stage transitions, external handlers\n| ContentRegistry | 16 | Registration, resolution, VFS integration, template generators\n| Costs | 3 | Cost estimation engine\n| **Total** | **140** |\n|===\n\n=== Gap: UI Layer\n\nThe UI layer (overlays, stage transitions, DOM manipulation) has zero test coverage. All regressions to date have occurred in this layer. The primary barrier is the absence of a DOM environment in the test runner (Vitest with no jsdom/happy-dom configured).\n\n=== Mitigation\n\nThe slot pattern and the populate/teardown lifecycle are architectural mitigations for UI bugs. By reducing shared mutable DOM state, the slot pattern eliminates the class of bug where one consumer corrupts another's DOM. The teardown convention ensures workspace state is cleaned up before stage transitions.\n\nFuture improvement: add integration tests with a DOM environment to verify overlay lifecycle sequences.\n\n== Known Patterns to Extract\n\nThe following patterns currently live inline in stage modules but are candidates for extraction into `src/lcars-framework/` or `src/ui/`:\n\n1. **`workspace_teardown()`**: Currently in `search.ts`, imported by `process.ts`. If more stage transitions need workspace cleanup, this should move to a lifecycle module.\n\n== Extracted Patterns (Completed)\n\n1. **`overlaySlots_clear()`**: Moved to `src/core/logic/OverlayUtils.ts`.\n2. **Resize handle logic**: Moved to `src/ui/interactions/ResizeHandle.ts`.\n\n---\n_Last updated: 2026-01-30 (v4.5.1)_",
    "intents.adoc": "= ARGUS: Intent-Action Switchboard Registry\n:author: ATLAS Project Team\n:revdate: 2026-02-04\n:revnumber: 1.0.0\n:toc: macro\n:toclevels: 3\n:sectnums:\n\ntoc::[]\n\n== Philosophy\n\nARGUS follows an **Intent-Action Design** pattern. The system is architected as a \"switchboard\" of deterministic, single-function-call actions. \n\n* **First-Class Intents**: Manual commands that a user can type directly into the terminal or CLI (e.g., `add ds-001`, `rename my-project`).\n* **Agentic Intents**: Natural language requests interpreted by CALYPSO, which then \"flips the switch\" on a corresponding First-Class Intent or system function.\n\nThis separation ensures that the AI is not \"guessing\" how to perform work; it is simply a natural language interface for a robust, deterministic API.\n\n== The Switchboard Mapping\n\n|===\n| Intent | Agentic Marker (LLM) | First-Class Command | Deterministic Function | VFS / State Effect\n\n| **SEARCH**\n| `[ACTION: SHOW_DATASETS]`\n| `search <query>`\n| `workspace_render`\n| Filters catalog; updates mention buffer.\n\n| **GATHER**\n| `[SELECT: ds-XXX]`\n| `add <id>`\n| `project_gather(dataset)`\n| Auto-creates Draft; mounts VFS to `~/input/`.\n\n| **RENAME**\n| `[ACTION: RENAME <name>]`\n| `rename <name>`\n| `project_rename(project, name)`\n| `mv` project directory; updates Store state.\n\n| **HARMONIZE**\n| (LLM reasoning)\n| `harmonize cohort`\n| `project_harmonize(project)`\n| Creates `.harmonized` marker; bypasses non-IID gates.\n\n| **PROCEED (FEDML)**\n| `[ACTION: PROCEED fedml]`\n| `proceed` / `mount`\n| `projectDir_populate()`\n| Scaffolds `train.py`; advances stage to Process.\n\n| **PROCEED (CHRIS)**\n| `[ACTION: PROCEED chris]`\n| `proceed` / `mount`\n| `chrisProject_scaffold()`\n| Scaffolds ChRIS plugin; advances stage to Process.\n\n| **FEDERATE**\n| (LLM reasoning)\n| `federate`\n| `federation_sequence()`\n| Triggers build/distribute/monitor workflow.\n|===\n\n== Anaphora Resolution\n\nCALYPSO maintains a context buffer of recently mentioned datasets. This allows fuzzy intents to resolve to specific First-Class IDs.\n\n[cols=\"1,2\"]\n|===\n| Token | Resolution\n\n| **Singular** (`that`, `it`, `this`)\n| Resolves to the *last* mentioned dataset ID.\n\n| **Plural** (`them`, `those`, `all`)\n| Resolves to *all* recently mentioned dataset IDs.\n|===\n\n== Special System Commands\n\nThese intents are primarily for environment control and ORACLE verification.\n\n[cols=\"1,3\"]\n|===\n| Command | Effect\n\n| `/status`\n| Show system status (AI Core, VFS, Project context).\n\n| `/snapshot [path]`\n| Returns JSON serialization of the VFS subtree.\n\n| `/state`\n| Returns JSON snapshot of Store state.\n\n| `/reset`\n| Resets VFS and Store to clean state.\n|===\n\n== Iteration Strategy\n\nTo add a new capability to ARGUS:\n1. Implement the deterministic logic in `ProjectManager.ts`.\n2. Expose it as a **First-Class Intent** in `CalypsoCore.ts` (`workflow_dispatch`).\n3. Define an **Agentic Intent** (LLM marker) and update the system prompt in `LCARSEngine` to recognize it.\n4. Codify the mapping in this document.",
    "lcars.adoc": "= ARGUS LCARS Interface Design\n:toc:\n:icons: font\n\nThis document captures the specific interaction and visual metaphors used in the ARGUS (ATLAS Resource Graphical User System) LCARS interface.\n\n== The Intelligence Console (Terminal)\n\nThe terminal is the primary command and control hub for ARGUS. It functions as a \"Unified Intelligence Console\" where standard system commands (bash-like), natural language queries (LCARSLM), and agentic UI manipulations are integrated into a single stream.\n\n=== Visual Metaphor: The Tactical Drawer\n\nThe terminal is conceptually positioned **between** the Status Header (top panel) and the Operational Workspace (bottom panel). It is designed as a \"retractable drawer\" that unfurls from behind the main workspace.\n\n.Key Design Principles:\n* **Framework Integration**: The terminal is powered by the `LCARSTerminal` component from the `lcars-framework`. It is decoupled from application logic, using a command-registration API.\n* **Frameless Integration**: To avoid visual clutter, the terminal does not have its own left-side LCARS framing. Instead, it sits flush against the primary `left-frame` (sidebar), which acts as a \"rail\" for the drawer.\n* **The Workspace Lid**: The horizontal `bar-panel` (containing bars 6-10) functions as the physical \"lid\" of the bottom panel.\n* **Retraction Logic**:\n  - **Closed**: The lid sits at the top of the right-frame; the terminal is hidden (height: 0).\n  - **Open**: The lid slides downward, revealing the terminal screen above it.\n* **Dynamic Elbows**: The LCARS corner elbows are attached to the sliding \"lid\" rather than the frame, ensuring a flush join at any deployment height. These elbows have a high z-index (300) to sit above overlays like the Marketplace.\n\n=== Interaction Metaphor: The Pullable Access Strip\n\nThe primary method for adjusting the terminal's height is the **Access Strip**.\n\n* **The Handle**: A horizontal orange bar (`october-sunset`) floating 5px above the workspace lid.\n* **Draggable Workspace**: By \"grabbing\" this handle, the user physically pulls the entire workspace down, increasing the terminal's visibility. The height limit has been removed to allow full-screen console expansion.\n* **Visual Feedback**: The handle glows when active, providing tactile confirmation.\n* **Integrated Toggles**:\n  - **Tactical Close**: A glowing `mars` red pill at the top-right of the terminal header for quick retraction. Pulses with `lcars-beckon-mars` to signal interactivity.\n  - **Primary Toggle**: The rightmost bar segment (`bar-10`) of the workstation lid acts as the toggle switch. Pulses with `lcars-beckon-orange` when the terminal is closed; stops pulsing when open.\n  - **Resize Handle**: The Access Strip pulses with `lcars-beckon-orange` when the terminal is open, indicating drag-to-resize capability.\n\n== The Workspace Split-Pane\n\nWhen a project is OPENed from the Search stage, the right-frame transforms into a **workspace layout** — a vertical stack of two independently-sized panels separated by resize handles.\n\n=== Layout Structure\n\nThe workspace activates by adding `workspace-active` to `.right-frame`, switching it to a flex column. The DOM order becomes:\n\n----\n.right-frame.workspace-active\n├── #intelligence-console .terminal-drawer     (terminal panel)\n├── .workspace-resize-handle[data-target=terminal]  (terminal resize grip)\n├── #asset-detail-overlay.workspace-expanded   (file browser panel)\n├── .workspace-resize-handle[data-target=browser]   (browser resize grip)\n├── .bar-panel.main-bar-panel                  (hidden in workspace)\n└── #main-content                              (hidden in workspace)\n----\n\n=== Independent Panel Sizing\n\nThe two panels are **fully decoupled** — resizing one does not affect the other. This is achieved by giving each panel its own bottom-edge resize handle, rather than using a traditional split-pane divider that redistributes a fixed pool of height.\n\n* **Terminal panel**: Height set explicitly by drag (default: 30% of frame). `flex: none`. Min-height: 80px. No upper bound — making the terminal taller makes the page taller.\n* **File browser panel**: `flex: none; height: 70vh; min-height: 400px`. Independently resizable via its own handle.\n* **Page scrolling**: `.right-frame.workspace-active` has `min-height: 100vh` and `overflow: visible`, so the page scrolls to accommodate the total height of both panels. Users can scroll the top LCARS header off-screen for maximum workspace area.\n\n=== Resize Handles\n\nBoth handles share the `.workspace-resize-handle` CSS class:\n\n* **Visual**: 6px horizontal bar in `october-sunset` (orange). On hover/active: `canary` (yellow) with a subtle box-shadow glow.\n* **Interaction**: `cursor: row-resize`. Standard mousedown → mousemove → mouseup drag pattern.\n* **Cleanup**: Both handles and their event listeners are created by `workspace_expand()` and torn down by `workspace_collapse()`.\n\n=== Bidirectional Tab ↔ Terminal Sync\n\nThe file browser sidebar (SOURCE/DATA tabs) and the terminal working directory stay in sync:\n\n* **Tab → Terminal**: Clicking a sidebar tab calls `shell.cd()` to change the terminal's working directory to the corresponding project subdirectory (`/src` or `/data`).\n* **Terminal → Tab**: The Shell's `onCwdChange_set()` callback fires whenever `cd` succeeds. The workspace handler resolves the new cwd to a tab ID via `cwdToTab_resolve()` and switches the visual tab accordingly.\n\n== The Dataset Detail Overlay (Gather Mode)\n\nWhen a dataset tile is clicked from the search results, the asset detail overlay opens in **gather mode** — a selectable FileBrowser showing the dataset's data tree.\n\n=== Visual Identity\n\nThe dataset detail uses LCARS hue 200 (sky blue) to distinguish it from project detail (hue 30, orange/honey). The sidebar shows a single \"DATA\" tab and a \"GATHER\" label at the bottom corner.\n\n=== Selectable FileBrowser\n\nThe FileBrowser component operates in `selectable: true` mode. Short clicks still preview files. Long-pressing (500ms+) toggles selection:\n\n* **File long-press**: Toggles the individual file. Selected files show `.selected-for-gather` — a canary left-border, background tint, and checkmark prefix.\n* **Folder long-press**: Toggles all descendant files. If all are selected, deselects all; otherwise selects all.\n\n=== Command Column\n\nThe standard INSTALL/CLOSE pills are replaced with:\n\n* **DONE** (canary/gold): Commits gathered selection, closes overlay, marks dataset tile as `.gathered`.\n* **ADDITIONAL DATA** (october-sunset/orange): Commits selection, closes overlay, returns to grid for more dataset browsing.\n* **CANCEL** (mars/red): Closes without committing.\n\n=== Cost Strip\n\nA real-time cost summary bar at the bottom of the content area:\n\n----\nSELECTED: 45 / 293 FILES  |  ESTIMATED COST: $6.92\n----\n\nPer-file cost = dataset total cost / total file count. Updates live via `onSelectionChange` callback.\n\n== The Persistent Project Strip\n\nA horizontal strip of compact project chips persists at the top of the Search stage across all search operations. Projects never disappear when dataset results are displayed.\n\n* **Default chip**: honey border on dark background.\n* **Active chip** (gather target): solid honey background, black text, glow. Gathered data merges into this project.\n* **\"+ NEW\" chip**: dashed harvestgold border. Clears the active target for new project creation.\n\nFirst click on a chip sets it as the gather target. Second click (already active) opens the project detail overlay.\n\n== The Multi-Mode Overlay Architecture\n\nThe `#asset-detail-overlay` is shared by three consumers — marketplace assets, project detail, and dataset detail — each requiring different sidebar panels, content areas, and command pills. Rather than rewriting the overlay's innerHTML on each open and restoring it on close (a fragile pattern that caused regressions), the overlay uses a **slot-based multi-mode** approach.\n\n=== DOM Structure\n\nThe overlay contains both the marketplace's original static DOM and three empty **slot containers**:\n\n----\n#asset-detail-overlay[data-mode=\"marketplace|project|dataset\"]\n├── .detail-layout\n│   ├── .detail-panel\n│   │   ├── .lcars-frame\n│   │   │   ├── .lcars-sidebar            ← marketplace original (never mutated)\n│   │   │   ├── #overlay-sidebar-slot     ← project/dataset sidebar\n│   │   │   ├── .lcars-content            ← marketplace original (never mutated)\n│   │   │   ├── #overlay-content-slot     ← project/dataset content\n│   ├── .detail-command-column            ← marketplace original (CLOSE/INSTALL)\n│   ├── #overlay-command-slot             ← project/dataset commands (DONE/ADD/CANCEL or CLOSE/OPEN)\n----\n\n=== Mode Switching\n\nThe `data-mode` attribute on the overlay root controls visibility via CSS attribute selectors:\n\n* **`marketplace`** (default): Original sidebar, content, and command column are visible. All `.overlay-slot` containers are `display: none`.\n* **`project`** / **`dataset`**: Original elements are hidden via `:not(.overlay-slot)` selectors. Slot containers are visible and populated by `projectDetail_populate()` or `datasetDetail_populate()`.\n\nWhen a project or dataset detail is closed, the close handler:\n\n1. Clears slot innerHTML (via `overlaySlots_clear()`)\n2. Sets `data-mode=\"marketplace\"`\n\nThe marketplace's original DOM is **never touched**. No restore logic is needed.\n\n=== Workspace Teardown\n\nWhen the user triggers FEDERALIZE AND LAUNCH from within an expanded workspace, the system must fully tear down the workspace before transitioning to the Monitor stage. The `workspace_teardown()` function handles this:\n\n1. Calls `workspace_collapse()` — removes resize handles, restores `rightFrame` layout, shows stage content\n2. Hides the `asset-detail-overlay` and resets `data-mode` to `marketplace`\n3. Clears all slot contents\n4. Closes the terminal (monitor has its own telemetry)\n\nThis ensures the Monitor stage content renders unobstructed.\n\n== Operational Modes\n\nThe terminal dynamically adapts its persona and capabilities based on the active SeaGaP stage.\n\n=== Search Mode (AI Core)\nDuring the Search stage, the terminal acts as an AI-driven discovery engine.\n* **Prompt**: `ARGUS: SEARCH >`\n* **Agentic Logic**: The AI can automatically select datasets in the visual grid using the `[SELECT: ID]` intent parser.\n* **Telematic Readout**: The visual grid below the terminal serves as a secondary evidence display, updating in real-time as the AI identifies relevant cohorts.\n\n=== Developer Mode (Technical Shell)\nUpon entering the Process stage, the console transitions into a technical coding environment.\n* **Prompt**: `dev@argus:~/src/project $`\n* **Styling**: The UI automatically switches to a monospaced font (**Inconsolata**), clears history, and enables mixed-case input/output for technical accuracy.\n* **Commands**: Supports standard linux-style commands (`ls`, `cd`, `pwd`, `mkdir`, `rm`, `python`).\n\n== Typography: The Dual-Voice System\n\nARGUS uses the **Antonio** font family with a selective casing strategy:\n\n* **The System Voice (Uppercase)**: All structural elements, headers, prompts, and button labels are strictly uppercase.\n* **The Data Voice (Mixed Case)**: Terminal output (AI responses, file contents) and user input allow mixed case to preserve technical precision and improve readability.\n* **Visual Polish**: Terminal readouts feature a soft text-shadow glow, simulating a high-density CRT display.\n\n== LCARS Component System\n\nARGUS is built on a reusable **LCARS Framework** (`src/lcars-framework/`) that decouples data simulation from UI rendering.\n\n=== Telemetry Service\nThe telemetry system uses a provider-renderer pattern:\n* **Generators**: Pure logic classes (e.g., `ProcessGenerator`, `NetworkGenerator`) that produce data objects.\n* **Renderers**: Visual components (e.g., `ListRenderer`, `LogRenderer`) that take data and update the DOM.\n* **Service**: A central orchestrator that manages registration and the 800ms \"flicker\" update loop.\n\n=== Workflow Tracker\nThe `WorkflowTracker` procedurally generates linear pipelines (like SeaGaP) with:\n* **Stations**: Circular \"stops\" with associated labels and status classes (`active`, `visited`).\n* **Connectors**: Dynamic line segments between stops.\n* **Integrated Telemetry**: Each station includes a \"hanging\" telemetry window that populates via the `TelemetryService`.\n\n=== Asset Card Component\nThe `AssetCard` (`src/ui/components/AssetCard.ts`) is a shared UI primitive used to represent both Marketplace assets and User Projects. It unifies the visual language between external resources and internal workspaces.\n\n.Features:\n* **Polymorphic Rendering**: Adapts metadata display (stars/version for assets vs. dataset counts/modification date for projects).\n* **Integrated Actions**: Supports an optional primary action pill (INSTALL, SELECT, OPEN).\n* **Identity States**: Visually flags \"Installed\" or \"Active\" items via CSS class toggles.\n\n=== Architecture\n\nThe system consists of two parts:\n\n1. **TypeScript Generator** (`src/ui/components/LCARSFrame.ts`)\n   - Creates DOM structures for LCARS frames\n   - Handles panel configuration and layout\n   - Exposes utility functions to window for HTML event handlers\n\n2. **CSS Design System** (`dist/css/lcars-components.css`)\n   - Defines base styles using CSS custom properties\n   - Computes color shades via HSL\n   - Handles responsive breakpoints\n\n=== The Hue-Based Color System\n\nAll LCARS component colors derive from a single `--lcars-hue` value (0-360). The CSS automatically computes four shade variants:\n\n[source,css]\n----\n.lcars-frame {\n    --lcars-hue: 200;           /* Blue family */\n    --lcars-sat: 70%;\n    --lcars-light-1: 75%;       /* Lightest */\n    --lcars-light-2: 65%;\n    --lcars-light-3: 55%;\n    --lcars-light-4: 45%;       /* Darkest */\n\n    /* Computed shades */\n    --lcars-shade-1: hsl(var(--lcars-hue), var(--lcars-sat), var(--lcars-light-1));\n    --lcars-shade-2: hsl(var(--lcars-hue), var(--lcars-sat), var(--lcars-light-2));\n    /* ... */\n}\n----\n\n.Predefined Hue Values\n[cols=\"1,1,2\"]\n|===\n|Name |Hue |Usage\n\n|BLUE/SKY |200 |Default marketplace assets\n|ORANGE |30 |Main application frame\n|GREEN/FDA |140 |FDA regulatory tools\n|PURPLE/NEBULA |270 |Special categories\n|RED/MARS |0 |Alerts, warnings\n|GOLD |45 |Highlights\n|===\n\n=== LCARS Frame Structure\n\nA complete LCARS frame consists of four grid areas:\n\n----\n╭━━━━━━━━━━╮━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n┃  ELBOW   ┃  TOP BAR (title + actions)\n┣━━━━━━━━━━╋━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n┃ PANEL 1  ┃\n┃──────────┃  CONTENT AREA\n┃ PANEL 2  ┃  (scrollable)\n┃──────────┃\n┃ PANEL 3  ┃\n┃ [spacer] ┃\n┃ PANEL N  ┃  ← corner radius\n╰━━━━━━━━━━╯─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─\n----\n\n* **Elbow**: Curved corner piece connecting top bar to sidebar\n* **Top Bar**: Horizontal header with title, metadata, and action buttons\n* **Sidebar**: Vertical stack of navigation panels (same width, varying heights/shades)\n* **Content**: Main scrollable content area\n\n=== Panel Design Principles\n\nLCARS panels follow strict design rules:\n\n1. **Uniform Width**: All sidebar panels are the same width. Visual variety comes from color and height, not width.\n2. **Shade Cycling**: Panels alternate through shade variants (1-4) for visual rhythm\n3. **Height Variants**: Panels can have different heights (`tall`, `medium`, `short`)\n4. **Corner Radii**: Only the elbow (top-left) and bottom panel (bottom-left) have rounded corners\n5. **Text Alignment**: Panel labels align right (LCARS convention for left sidebars)\n6. **Spacer Element**: A colored spacer fills remaining height between panels and the bottom corner\n\n=== Usage Example\n\n**HTML Structure:**\n[source,html]\n----\n<div class=\"lcars-frame\" style=\"--lcars-hue: 200;\">\n    <div class=\"lcars-elbow\"></div>\n    <div class=\"lcars-top-bar\">\n        <h1>Title</h1>\n        <button class=\"close-btn\">CLOSE</button>\n    </div>\n    <div class=\"lcars-sidebar\">\n        <a class=\"lcars-panel\" data-shade=\"1\" data-height=\"tall\">SECTION 1</a>\n        <a class=\"lcars-panel\" data-shade=\"2\">SECTION 2</a>\n        <a class=\"lcars-panel\" data-shade=\"3\">SECTION 3</a>\n        <div class=\"lcars-sidebar-spacer\" data-shade=\"4\"></div>\n        <a class=\"lcars-panel lcars-corner-bl\" data-shade=\"1\">SECTION N</a>\n    </div>\n    <div class=\"lcars-content\">\n        <!-- Scrollable content -->\n    </div>\n</div>\n----\n\n**Dynamic Theming (TypeScript):**\n[source,typescript]\n----\n// Change color scheme at runtime\nconst frame = document.getElementById('my-lcars-frame');\nframe.style.setProperty('--lcars-hue', '140');  // Switch to green\n----\n\n=== Marketplace Integration\n\nThe Asset Detail Overlay demonstrates the \"Floating Command Module\" pattern, where critical actions are decoupled from the information display to maximize screen real estate and mimic hardware controls.\n\n==== Visual Style: PADD Aesthetic\nThe asset tiles and detail frames use an asymmetrical \"PADD\" (Personal Access Display Device) geometry:\n* **Thick Top Bar:** 10px solid accent bar (Sky Blue or FDA Green).\n* **Rounded Corner:** Bottom-right corner has a 24px radius (`border-radius: 0 0 24px 0`), creating a distinct physical shape.\n* **No Borders:** Replaced thin outlines with deep contrast backgrounds and shadow glows.\n\n==== Floating Command Pills\nAction buttons are removed from the internal content area and placed in a dedicated **Command Column** to the right of the main panel.\n\n* **Structure:**\n  [source,html]\n  ----\n  <div class=\"detail-layout\">\n      <!-- Main Information Display -->\n      <div class=\"detail-panel\">...</div>\n\n      <!-- Floating Command Column -->\n      <div class=\"detail-command-column\">\n          <button class=\"pill-btn close-pill\">CLOSE</button>\n          <button class=\"pill-btn install-pill\">INSTALL</button>\n      </div>\n  </div>\n  ----\n* **Dynamic Coloring:** The INSTALL pill automatically inherits the asset's hue (Blue vs. FDA Green) via CSS variables.\n* **Status Feedback:** The INSTALL pill contains a progress bar overlay and status text (`READY` -> `INSTALLING` -> `INSTALLED`).\n\n==== Color Coding\n* **Standard Assets:** `--lcars-hue: 200` (Sky Blue)\n* **FDA Regulatory Tools:** `--lcars-hue: 140` (Green)\n* **Close Actions:** `var(--mars)` (Red)\n\n[source,typescript]\n----\n// In marketplace/view.ts\nconst hue = asset.type === 'fda' ? 140 : 200;\nlcarsFrame.style.setProperty('--lcars-hue', String(hue));\n----\n\n== Interactive Affordances: The Beckon Pulse\n\nIn Michael Okuda's original LCARS designs for The Next Generation, instrument panels were never entirely static. Panels flickered, shifted, and cycled through subtle brightness changes to suggest ongoing background system activity. This visual \"life\" served a dual purpose: it made the interface feel like a living system, and it drew attention to active controls without explicit labels or iconography.\n\nARGUS adopts this principle as a formal visual language pattern called the **Beckon Pulse**. Any interactive element that lacks an obvious affordance (no label, no icon, no conventional button shape) uses a slow brightness oscillation to signal \"interact with me.\"\n\n=== The Pattern\n\nThe Beckon Pulse is a `3-3.5s` CSS animation that oscillates `filter: brightness()` between `1.0` and `1.15-1.25`, with an optional `box-shadow` glow. The effect is subtle enough to register in peripheral vision without demanding attention. On hover, the animation stops and the element shows a static highlight, confirming interactivity.\n\n=== Variants\n\n[cols=\"1,2,2\"]\n|===\n| Variant | Animation | Usage\n\n| `lcars-beckon-orange`\n| brightness 1.0 → 1.15, soft orange glow\n| Open/activate controls (e.g., `bar-6` terminal opener)\n\n| `lcars-beckon-mars`\n| brightness 1.0 → 1.25, red glow intensifies\n| Close/dismiss controls (e.g., terminal close pill)\n\n| `.lcars-beckon` (utility class)\n| Applies `lcars-beckon-orange` by default\n| Any generic interactive element\n|===\n\n=== Contextual Activation\n\nBeckon animations are **context-sensitive**: they only pulse when the affordance is relevant. For example, `bar-6` (the terminal opener) beckons only when the terminal is closed. Once the terminal is open, bar-6 stops pulsing — the user's attention should shift to the terminal content and its close control, which now takes over the beckon duty.\n\nThis prevents **pulse fatigue**: the visual rhythm of the interface changes as the user navigates, with different elements beckoning at different moments rather than everything pulsing simultaneously.\n\n=== CSS Usage\n\n[source,css]\n----\n/* Apply via utility class */\n.my-interactive-element {\n    /* ... */\n}\n.my-interactive-element.lcars-beckon {\n    animation: lcars-beckon-orange 3.5s ease-in-out infinite;\n}\n.my-interactive-element.lcars-beckon:hover {\n    animation: none;\n}\n\n/* Or apply a specific variant directly */\n.my-close-button {\n    animation: lcars-beckon-mars 3s ease-in-out infinite;\n}\n----\n\n=== Toggling via JavaScript\n\n[source,typescript]\n----\n// Start beckoning\nelement.classList.add('lcars-beckon');\n\n// Stop beckoning (e.g., when the associated panel is open)\nelement.classList.remove('lcars-beckon');\n----\n\n== Implementation Details\n\n* **Global Component**: The `LCARSTerminal` is a global singleton.\n* **Intent Parsing**: The `terminalCommand_handle()` dispatcher in `argus.ts` routes commands to `workflowCommand_handle()` (search/add/review/mount/simulate) and `aiQuery_handle()` (LLM queries). AI responses are parsed by `aiResponse_process()` to trigger system actions (selecting data, transitioning stages).\n* **Contextual Awareness**: The AI engine receives the full dataset catalog and the user's current \"Selection Buffer\" with every query, ensuring high-fidelity RAG (Retrieval Augmented Generation) reasoning.\n* **LCARS Frame Generator**: The `lcarsFrame_create()` function and related utilities are exposed on the `window` object for use in HTML event handlers.",
    "marketplace.adoc": "= ATLAS Marketplace Specification (v3.5.0)\n:toc:\n:toclevels: 3\n\n== 1. Overview\nThe ATLAS Marketplace is a global asset registry providing ChRIS plugins (MERIDIAN apps), reference datasets, pre-trained models, annotation tools, and FDA regulatory tools. It serves as the primary distribution channel for extending the capabilities of an ARGUS instance.\n\n== 2. Asset Types\n\n[cols=\"1,2,2\"]\n|===\n| Type | Description | VCS Impact\n\n| `plugin`\n| Containerized MERIDIAN/ChRIS applications.\n| Installed to `/bin/<plugin-name>` with executable stub content.\n\n| `dataset`\n| Standalone reference cohorts for local validation.\n| Installed to `/data/sets/<dataset-name>/manifest.json`.\n\n| `model`\n| Pre-trained neural network weights (e.g., ResNet, UNet).\n| Installed to `~/models/<model-name>/README.md` with model card.\n\n| `annotation`\n| Annotation tools and label schemas.\n| Installed to `/data/annotations/<tool-name>/manifest.json`.\n\n| `fda`\n| FDA regulatory compliance tools.\n| Dual install: `/bin/<tool-name>` + `/data/annotations/<tool-name>/`.\n\n| `workflow`\n| Federated learning workflow templates.\n| Installed to `~/workflows/<workflow-name>/manifest.json`.\n|===\n\n== 3. Installation Lifecycle\n\nThe Marketplace is a **Public Service** (accessible without authentication) but requires an active session for VCS integration.\n\n1.  **Browse:** Users explore the high-density grid. Filter by type, search by name/description/author, sort by stars/name/size.\n2.  **Install:** Clicking \"INSTALL\" triggers a progress animation (1.5s).\n3.  **Store Action:** The button calls `store.asset_install(id)`, which adds the asset ID to `state.installedAssets`.\n4.  **Provider Dispatch:** The `MarketplaceProvider.asset_install()` translates the asset into VCS filesystem entries at the appropriate paths (see table above). Each entry includes content generators for manifest files, executable stubs, and model cards.\n5.  **Terminal Notification:** The Intelligence Console confirms availability and provides usage hints.\n\n== 4. Architectural Integration\nThe Marketplace is decoupled from the SeaGaP workflow. It operates as a modal overlay driven by the central `Store` and `EventBus`. The overlay slides in from the right (Slide-In Overlay animation pattern, see `docs/visual_language.adoc`).\n\n=== Key Files\n\n[cols=\"1,2\"]\n|===\n| File | Purpose\n\n| `src/marketplace/view.ts`\n| Marketplace UI: grid rendering, filtering, sorting, search, detail overlay, install handlers.\n\n| `src/core/data/marketplace.ts`\n| `MARKETPLACE_ASSETS` registry of 400+ assets with metadata.\n\n| `src/vfs/providers/MarketplaceProvider.ts`\n| Translates assets into VCS filesystem trees with content generators.\n|===\n\n=== Detail Overlay\nClicking an asset card opens a full detail overlay with:\n\n* LCARS frame with hue-based color coding (blue for standard, green for FDA)\n* Floating Command Column with INSTALL and CLOSE pills\n* Specifications, usage commands, dependencies, changelog, related assets\n\nSee `docs/lcars.adoc` for the Floating Command Module visual pattern.",
    "modularization.adoc": "= LCARS Framework Modularization Plan\n:toc:\n:icons: font\n\n== Overview\nThe goal of this initiative is to transition the ARGUS prototype from a monolithic, tightly-coupled application to a modular, reusable **LCARS Framework**. This framework will provide components and services that can be easily dropped into other medical imaging or federated learning projects.\n\n== Core Philosophy\n1. **Separation of Concerns**: Decouple simulation logic (data generation) from rendering logic (DOM manipulation).\n2. **Dependency Injection**: Components should receive their data and configuration (IDs, labels, state) rather than reaching out to global stores.\n3. **Registry Pattern**: Services should allow dynamic registration of data sources and views.\n4. **Framework Agnostic**: The core logic should remain Vanilla TypeScript, making it compatible with any future environment.\n\n== Target Components\n\n=== 1. Telemetry System\nRefactor the current hardcoded telemetry into a generic service.\n\n* **Status**: In Progress (Refactoring ARGUS-native telemetry)\n* **Architecture**:\n** `TelemetryGenerator`: Interface for data providers (e.g., CPU, Network, Stage-specific metrics).\n** `TelemetryRenderer`: Interface for UI views (e.g., Tables, Scrolling Logs, Status Boxes).\n** `TelemetryService`: Orchestrates the `tick` loop and maps generators to renderers.\n\n=== 2. Intelligent Terminal\nRefactor `LCARSTerminal` to be a standalone component.\n\n* **Status**: Planned\n* **Architecture**:\n** Configurable prompts and styling.\n** Command registry for custom application logic.\n** Plug-and-play AI backends (e.g., LCARSLM Engine).\n\n=== 3. Procedural Frame System\nSolidify `LCARSFrame.ts` into a stable library component.\n\n* **Status**: Partially Complete\n* **Architecture**:\n** Configurable panel stacks and curves.\n** Standardized color palettes (LCARS_HUES).\n\n== Roadmap\n\n=== Phase 1: Telemetry Decoupling [COMPLETE]\n- [x] Create `src/lcars-framework/` directory structure.\n- [x] Extract \"Simulators\" from `src/telemetry/system.ts` into pure `TelemetryGenerator` classes.\n- [x] Implement generic `TelemetryRenderer` for common LCARS layouts.\n- [x] Update `TelemetryManager` to use the new service pattern.\n\n=== Phase 2: Terminal Refactor [COMPLETE]\n- [x] Remove ARGUS-specific commands from the core Terminal component.\n- [x] Implement a clean registration API for new terminal commands.\n- [x] Decouple the prompt and response handling from the application state.\n\n=== Phase 3: Layout & Navigation [COMPLETE]\n- [x] Refactor SeaGaP stations into a configurable `WorkflowTracker` component.\n- [x] Standardize event-based communication between components using the `EventBus`.\n\n== Final Framework Structure\nThe resulting framework resides in `src/lcars-framework/` and provides:\n* **Telemetry**: Data-agnostic simulators and LCARS renderers.\n* **Terminal**: A flexible, command-driven console.\n* **Workflow**: Procedural station tracker for linear pipelines.\n\n== Implementation Notes\n* All new framework code should reside in `src/lcars-framework/`.\n* Avoid importing from `src/core/` or `src/argus.ts` inside the framework.\n* Use interfaces to define contracts between the framework and the application.",
    "onboarding.adoc": "= ARGUS Developer Onboarding Guide\n:author: ATLAS Project Team\n:revdate: 2026-01-30\n:toc:\n:sectnums:\n\n== Welcome to ARGUS\n\nARGUS (ATLAS Resource Graphical User System) is the UI layer for the ATLAS federated medical imaging platform. It is a **Vanilla TypeScript** application that implements the SeaGaP-MP workflow (Search, Gather, Process, Monitor, Post).\n\n**The Golden Rule:** There is no framework (React, Vue, Svelte). We use raw DOM manipulation, orchestrated by a custom Pub/Sub Store and strict architectural patterns.\n\n== The Mental Model\n\nTo work on ARGUS, you need to understand three core concepts:\n\n=== The Store is Truth\n\nEverything that changes (current stage, selected datasets, training status) lives in `src/core/state/store.ts`.\n\n*   **Don't** mutate state directly.\n*   **Do** call Store actions (e.g., `store.dataset_select(id)`).\n*   **Do** listen for events (e.g., `events.on(Events.STATE_CHANGED, ...)`).\n\n=== The Virtual Computer (VCS)\n\nARGUS isn't just a website; it simulates a computer.\n\n*   It has a filesystem (`src/vfs/`).\n*   It has a shell (`src/vfs/Shell.ts`) with environment variables (`$HOME`, `$PWD`).\n*   It has a terminal.\n\n**Key Concept:** \"Providers\" bridge the gap. When you select a dataset in the UI, the `DatasetProvider` effectively \"mounts\" that data into the virtual filesystem at `~/data/cohort/`.\n\n=== The Stage Lifecycle\n\nThe app moves through stages (Search -> Process -> Monitor).\n\n*   **Entry Point:** `src/argus.ts` is the orchestrator.\n*   **Lifecycle:** Each stage module (e.g., `src/core/stages/process.ts`) exports `stage_enter()` and `stage_exit()` hooks.\n*   **Control Flow:** The orchestrator calls `currentStage.stage_exit()` -> `nextStage.stage_enter()`.\n\n== Codebase Tour\n\n[cols=\"1,3\"]\n|===\n| Path | What's Inside\n\n| `src/argus.ts`\n| **The Orchestrator.** Initializes the app, sets up the VCS, and handles high-level events. Keep this file clean.\n\n| `src/lcars-framework/`\n| **The UI Library.** Reusable LCARS components (Terminal, WorkflowTracker) that know *nothing* about ARGUS business logic.\n\n| `src/core/state/`\n| **The Brain.** `store.ts` (state) and `events.ts` (pub/sub bus).\n\n| `src/core/logic/`\n| **The Logic Layer.** Specialized services like `commands.ts` (routing), `WindowBindings.ts` (DOM glue), and `Lifecycle.ts`.\n\n| `src/core/stages/`\n| **The Scenes.** One file per stage (search, gather, process...). Logic for that specific screen lives here.\n\n| `src/vfs/`\n| **The Computer.** The virtual filesystem, shell, and content generators.\n\n| `src/lcarslm/`\n| **The AI.** Service for communicating with Gemini/OpenAI (RAG logic).\n|===\n\n== Rules of the Road\n\n=== Naming: RPN (Reverse Polish Notation)\n\nWe use `object_method` naming to group related functionality.\n\n*   ✅ `project_load()`, `dataset_select()`, `terminal_toggle()`\n*   ❌ `loadProject()`, `selectDataset()`, `toggleTerminal()`\n\n=== The Slot Pattern\n\nWe avoid rewriting `innerHTML` for complex overlays.\n\n*   The `#asset-detail-overlay` has empty \"slots\" (`#overlay-content-slot`).\n*   When you open a Project Detail, you simply **show** the slot and **render** into it.\n*   When you close it, you **clear** the slot.\n*   *Never* touch the original Marketplace DOM that shares the overlay.\n\n=== Window Bindings\n\nHTML `onclick=\"myFunc()\"` requires `myFunc` to be on `window`.\n\n*   **Don't** just say `(window as any).myFunc = ...`\n*   **Do** register it in `src/core/logic/WindowBindings.ts`.\n\n== \"Hello World\": Adding a Command\n\nWant to add a new command called `hello` to the terminal?\n\n1.  **Edit `src/core/logic/commands.ts`**:\n    Add your logic to the `workflow_dispatch` function.\n\n[source,typescript]\n----\nif (cmd === 'hello') {\n    globals.terminal.println('Hello, World!');\n    return true; // Command handled\n}\n----\n\nThat's it. The `CommandRouter` automatically intercepts it before checking the AI engine.\n\n== \"Hello World\": Adding a Stage\n\n1.  **Create `src/core/stages/mystage.ts`**:\n    Implement `stage_enter()` and `stage_exit()`.\n\n2.  **Register in `src/argus.ts`**:\n    Import it and add it to `STAGE_HANDLERS`.\n\n3.  **Update Navigation**:\n    Add it to `STAGE_ORDER` in `src/core/logic/navigation.ts`.\n\n== Further Reading\n\n*   **`docs/framework.adoc`**: Detailed guide to the patterns mentioned above.\n*   **`docs/vcs.adoc`**: Deep dive into how the Virtual Filesystem works.\n*   **`docs/architecture.adoc`**: High-level system design.",
    "oracle.adoc": "= ORACLE: Reflexive Verification Through Agentic Self-Testing\n:author: ATLAS Project Team\n:revdate: 2026-02-04\n:revnumber: 1.1.0\n:toc: macro\n:toclevels: 3\n:sectnums:\n:icons: font\n\n[.lead]\n_A methodology for integration testing of AI-driven systems using the system's own conversational interface as both test driver and verification oracle._\n\ntoc::[]\n\n== Abstract\n\nModern web applications increasingly incorporate AI-driven interfaces that mediate between user intent and system functionality. Traditional testing approaches — unit tests, end-to-end browser automation, snapshot testing — struggle to verify these systems because the integration seams between AI interpretation, state management, and UI rendering are numerous, asynchronous, and often non-deterministic at the surface level.\n\nThis document introduces **ORACLE** (Observational Reflexive Agentic Confirmation of Logical Execution), a testing methodology in which the system's own AI interface serves as the test driver, and internal system state serves as the verification oracle. Rather than testing _around_ the AI layer or mocking it away, ORACLE tests _through_ the AI layer, verifying that natural language commands produce correct deterministic state transformations.\n\nWe describe the theoretical foundations, architectural requirements, implementation specifics for the ARGUS system, and a formal test script specification.\n\n== Introduction\n\n=== The Problem: Integration Testing of AI-Mediated Systems\n\nContemporary applications increasingly feature conversational or agentic interfaces where an AI layer interprets user intent and dispatches to underlying system functions. This architecture introduces a testing challenge:\n\n[cols=\"1,2,2\"]\n|===\n| Testing Approach | Limitation | Consequence\n\n| **Unit Tests**\n| Test functions in isolation\n| Cannot verify that AI correctly routes intent to function\n\n| **E2E Browser Automation**\n| Brittle selectors, visual assertions\n| Breaks on CSS changes; cannot assert semantic state\n\n| **Snapshot Testing**\n| Compares rendered output\n| High false-positive rate; conflates presentation with logic\n\n| **Mocking the AI Layer**\n| Removes non-determinism\n| Does not test the actual user-facing behavior\n|===\n\nThe core issue: the **integration seams** — where AI interpretation meets state mutation meets UI rendering — are precisely where bugs occur, yet they are the hardest to test.\n\n=== Observation: Bounded Non-Determinism\n\nIn systems like ARGUS, the AI layer (Calypso) does not perform arbitrary computation. It serves as a **natural language router** to deterministic functions:\n\n[source]\n----\nUser Input (fuzzy)          AI Interpretation           Deterministic Execution\n─────────────────────────────────────────────────────────────────────────────────\n\"add the BCH histology\"  →  INTENT: gather_dataset   →  dataset_gather('BCH-HISTO')\n\"include BCH set\"        →  INTENT: gather_dataset   →  dataset_gather('BCH-HISTO')\n\"gather BCH-HISTO-2024\"  →  INTENT: gather_dataset   →  dataset_gather('BCH-HISTO')\n----\n\nThe non-determinism is **bounded to intent classification**. Once intent is resolved, execution is pure. This means:\n\n1. Multiple surface forms map to the same intent\n2. The same intent always produces the same state transformation\n3. State is verifiable regardless of which surface form was used\n\n=== The ORACLE Insight\n\nIf the AI interface can successfully drive a workflow to completion, and the resulting system state is correct, then:\n\n- Intent classification worked\n- State management worked\n- All intermediate integrations worked\n\n**The system can test itself through its own user-facing interface.**\n\n== Background and Related Work\n\n=== Agentic AI Testing\n\nThe field of AI-driven test automation has evolved rapidly. Contemporary approaches include:\n\n**External Agent Testing**: Tools like Magnitude, TestZeus Hercules, and SmolAgents use external LLMs to interpret test specifications and drive applications through browser automation <<magnitude>> <<testzeus>>. The AI is a _test tool_, separate from the system under test.\n\n**Agent Simulation**: Platforms like LangWatch simulate multi-agent interactions to verify agent behavior under various scenarios <<langwatch>>. Focus is on testing the AI itself, not the system it controls.\n\n**Visual AI Testing**: Tools like Applitools use computer vision to detect UI regressions <<applitools>>. Assertions are visual, not semantic.\n\n=== Self-Testing Systems\n\nThe concept of systems that verify their own behavior has roots in:\n\n**Design by Contract** (Meyer, 1986): Preconditions, postconditions, and invariants embedded in code <<meyer>>.\n\n**Metamorphic Testing** (Chen et al., 1998): Verifying that related inputs produce related outputs according to known relations <<metamorphic>>.\n\n**Autonomous Self-Healing Systems**: Systems that detect and correct their own failures at runtime <<selfhealing>>.\n\n=== Gap in Existing Approaches\n\nNo existing methodology addresses the specific case where:\n\n1. An AI interface is the _primary_ user interaction mode\n2. The AI routes to deterministic backend functions\n3. System state (not UI appearance) is the source of truth\n4. The same interface used for production is used for testing\n\nORACLE fills this gap.\n\n== The ORACLE Methodology\n\n=== Core Principles\n\n[horizontal]\nReflexivity:: The test driver is the system's own AI interface, not an external tool.\nState Verification:: Assertions target internal state (VFS, Store), not rendered output.\nSemantic Equivalence:: Multiple natural language forms that resolve to the same intent are interchangeable in tests.\nProduction Parity:: Tests execute through the exact code path users traverse.\n\n=== Architectural Requirements\n\nFor ORACLE to apply, a system must exhibit:\n\n1. **Conversational Interface**: An AI layer that accepts natural language and dispatches to functions.\n2. **Deterministic Core**: Backend functions that produce predictable state given the same inputs.\n3. **Inspectable State**: Internal state that can be serialized and compared (e.g., filesystem tree, store snapshot).\n4. **Programmatic Access**: An API to send commands and retrieve state without browser automation.\n\n=== The Testing Model\n\n[source]\n----\n                    ┌─────────────────────────────────────────────┐\n                    │              TEST HARNESS                   │\n                    │  ┌─────────────────────────────────────┐    │\n                    │  │  Test Script (.oracle file)         │    │\n                    │  │  - Natural language commands        │    │\n                    │  │  - State assertions                 │    │\n                    │  └──────────────┬──────────────────────┘    │\n                    │                 │                           │\n                    │                 ▼                           │\n                    │  ┌─────────────────────────────────────┐    │\n                    │  │  Oracle Test Runner                 │    │\n                    │  │  - Parses script                    │    │\n                    │  │  - Sends commands via API           │    │\n                    │  │  - Retrieves state snapshots        │    │\n                    │  │  - Evaluates assertions             │    │\n                    │  └──────────────┬──────────────────────┘    │\n                    └─────────────────┼───────────────────────────┘\n                                      │ HTTP/WebSocket\n                                      ▼\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                           SYSTEM UNDER TEST                                 │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                         AI Layer (Calypso)                          │   │\n│  │   Natural Language Input → Intent Classification → Function Call    │   │\n│  └──────────────────────────────────┬──────────────────────────────────┘   │\n│                                     │                                       │\n│                    NON-DETERMINISTIC BOUNDARY                               │\n│  ═══════════════════════════════════╪═══════════════════════════════════   │\n│                    DETERMINISTIC EXECUTION                                  │\n│                                     │                                       │\n│                                     ▼                                       │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                    Core Functions                                   │   │\n│  │   dataset_gather() → store.dataset_select() → cohortTree_build()   │   │\n│  └──────────────────────────────────┬──────────────────────────────────┘   │\n│                                     │                                       │\n│                                     ▼                                       │\n│  ┌─────────────────────────────────────────────────────────────────────┐   │\n│  │                    System State                                     │   │\n│  │   VirtualFileSystem    Store    EventBus                           │   │\n│  │   (inspectable)        (inspectable)                               │   │\n│  └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n----\n\n=== Assertion Types\n\nORACLE supports three categories of assertions:\n\n[cols=\"1,2,2\"]\n|===\n| Category | Example | Verification Method\n\n| **State Existence**\n| `vfs_exists: \"~/projects/DRAFT/data/BCH-HISTO/\"`\n| Check node exists in VFS tree\n\n| **State Content**\n| `vfs_contains: { path: \"~/config.yaml\", content: \"model: unet\" }`\n| Read node content, substring/regex match\n\n| **State Snapshot**\n| `vfs_snapshot_matches: \"snapshots/gather-complete.json\"`\n| Serialize VFS subtree, deep compare to saved snapshot\n\n| **Store State**\n| `store.currentStage: \"process\"`\n| Read Store property, compare value\n\n| **Output Contains**\n| `output_contains: \"Dataset gathered\"`\n| Check Calypso's response text (weak assertion, use sparingly)\n|===\n\n== ARGUS Implementation\n\n=== System Context\n\nARGUS is a Vanilla TypeScript application implementing the SeaGaP-MP workflow (Search, Gather, Process, Monitor, Post) for federated medical imaging. Its AI layer, **Calypso**, interprets natural language commands and dispatches to deterministic functions that manipulate:\n\n- **VirtualFileSystem (VFS)**: In-memory POSIX-like filesystem\n- **Store**: Centralized application state with EventBus\n- **Providers**: Domain-to-filesystem translators (DatasetProvider, ProjectProvider, MarketplaceProvider)\n\nSee `docs/vcs.adoc`, `docs/architecture.adoc`, and `docs/calypso.adoc` for detailed specifications.\n\n=== Architectural Fit\n\nARGUS satisfies all ORACLE requirements:\n\n[cols=\"1,2\"]\n|===\n| Requirement | ARGUS Implementation\n\n| Conversational Interface\n| CalypsoCore accepts natural language, classifies intent, dispatches to functions\n\n| Deterministic Core\n| RPN-named functions (`dataset_gather()`, `project_scaffold()`) with typed inputs/outputs\n\n| Inspectable State\n| VFS exposes `tree_snapshot()`, Store exposes `state_snapshot()`\n\n| Programmatic Access\n| Calypso Server exposes HTTP API; CLI client for interactive use\n|===\n\n=== The CalypsoCore Abstraction\n\nThe key architectural decision enabling ORACLE is the **CalypsoCore** — a DOM-free orchestrator that can run in Node.js without a browser. See `docs/calypso.adoc` for the full specification.\n\n[source]\n----\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                         CALYPSO CORE (DOM-FREE)                             │\n│                                                                             │\n│   ┌─────────────────────────────────────────────────────────────────────┐   │\n│   │  CalypsoCore.command_execute(input: string): CalypsoResponse        │   │\n│   │                                                                     │   │\n│   │  1. Shell builtins    → shell.command_execute()                     │   │\n│   │  2. Workflow commands → workflow_dispatch()                         │   │\n│   │  3. LLM fallback      → engine.query() → intent_dispatch()          │   │\n│   └─────────────────────────────────────────────────────────────────────┘   │\n│                                    │                                        │\n│                                    ▼                                        │\n│   ┌─────────────────────────────────────────────────────────────────────┐   │\n│   │  CalypsoResponse                                                    │   │\n│   │  {                                                                  │   │\n│   │    message: \"● DATASET GATHERED.\",                                  │   │\n│   │    actions: [{ type: 'dataset_select', id: 'ds-012' }],             │   │\n│   │    state: { vfs: <snapshot>, store: <snapshot> }                    │   │\n│   │  }                                                                  │   │\n│   └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│   Depends on (all DOM-free):                                                │\n│   ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │\n│   │     VFS      │  │    Store     │  │    Shell     │  │ LCARSEngine  │   │\n│   └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n----\n\nThis design means:\n- **State mutations happen in CalypsoCore** (deterministic)\n- **UI rendering is delegated to adapters** (environment-specific)\n- **Tests can bypass UI entirely** and assert directly on state\n\n=== Component Architecture\n\n[source]\n----\nsrc/\n├── lcarslm/\n│   ├── CalypsoCore.ts           # DOM-free orchestrator\n│   ├── engine.ts                # LLM client (already DOM-free)\n│   ├── types.ts                 # CalypsoResponse, CalypsoAction, Intent\n│   └── adapters/\n│       ├── BrowserAdapter.ts    # DOM rendering for web app\n│       ├── CLIAdapter.ts        # stdout/stdin for CLI\n│       └── NodeAdapter.ts       # Test harness integration\n│\n├── cli/\n│   ├── calypso-server.ts        # Headless server entry point\n│   └── calypso-cli.ts           # Interactive REPL client\n│\n├── test/\n│   └── oracle/\n│       ├── OracleTestRunner.ts  # Parses .oracle files, drives tests\n│       ├── OracleClient.ts      # HTTP client for Calypso Server\n│       ├── assertions/\n│       │   ├── VfsAssertions.ts\n│       │   ├── StoreAssertions.ts\n│       │   └── OutputAssertions.ts\n│       └── snapshots/           # Saved state snapshots\n│\n├── vfs/\n│   └── VirtualFileSystem.ts     # tree_snapshot() method\n│\n└── core/\n    └── state/\n        └── store.ts             # state_snapshot() method\n----\n\n=== Calypso Server API\n\nThe Calypso Server (`make calypso`) exposes a REST API for programmatic interaction:\n\n[cols=\"1,2,2\"]\n|===\n| Endpoint | Method | Description\n\n| `/calypso/command`\n| POST\n| Send a command to CalypsoCore. Body: `{ \"command\": \"search histology\" }`. Returns: `CalypsoResponse`\n\n| `/calypso/vfs/snapshot`\n| GET\n| Returns serialized VFS tree. Query params: `path` (optional subtree root)\n\n| `/calypso/vfs/exists`\n| GET\n| Check if path exists. Query params: `path`. Returns: `{ \"exists\": true/false }`\n\n| `/calypso/vfs/read`\n| GET\n| Read file content. Query params: `path`. Returns: `{ \"content\": \"...\" }`\n\n| `/calypso/store/state`\n| GET\n| Returns serialized Store state\n\n| `/calypso/store/get`\n| GET\n| Get specific store property. Query params: `property`. Returns: `{ \"value\": ... }`\n\n| `/calypso/reset`\n| POST\n| Reset VFS and Store to clean state for next test\n\n| `/calypso/login`\n| POST\n| Login with username. Body: `{ \"username\": \"rudolph\" }`. Reinitializes VFS with user home.\n\n| `/calypso/prompt`\n| GET\n| Returns current shell prompt string (e.g., `rudolph@CALYPSO:[~/projects]> `)\n\n| `/calypso/version`\n| GET\n| Returns Calypso version string\n|===\n\n=== Calypso CLI\n\nThe `calypso-cli` tool provides interactive access to a running Calypso instance (headless or browser).\n\n[source,bash]\n----\n# Start headless server\n$ make calypso &\n\n# Connect CLI\n$ make calypso-cli\n----\n\n**CLI Commands:**\n\n[cols=\"1,3\"]\n|===\n| Command | Description\n\n| `<natural language>`\n| Sent to CalypsoCore for processing\n\n| `/snapshot [path]`\n| Display VFS snapshot as JSON\n\n| `/state`\n| Display Store state as JSON\n\n| `/reset`\n| Reset to clean state\n\n| `/help`\n| Show available commands\n\n| `quit` / `exit`\n| Disconnect and exit\n|===\n\n**Example Session:**\n\n[source]\n----\nuser@CALYPSO:[~]> search histology datasets\n● AFFIRMATIVE. SCAN COMPLETE.\n○ IDENTIFIED 3 DATASET(S) MATCHING QUERY PARAMETERS.\n  [ds-012] BCH-HISTO-2024 (Histology/Classification)\n  [ds-045] MGH-PATH-SLIDES (Histology/Segmentation)\n  [ds-078] BIDMC-TISSUE-BANK (Histology/Detection)\n\nuser@CALYPSO:[~]> add ds-012\n● DATASET GATHERED. MOUNTED TO ~/data/cohort/BCH-HISTO-2024/\n\nuser@CALYPSO:[~]> tree ~/data/cohort/\n~/data/cohort/\n└── BCH-HISTO-2024/\n    ├── images/\n    │   ├── slide_0001.svs\n    │   ├── slide_0002.svs\n    │   └── slide_0003.svs\n    └── manifest.json\n\nuser@CALYPSO:[~]> /snapshot ~/data/cohort/\n{\n  \"name\": \"cohort\",\n  \"type\": \"folder\",\n  \"path\": \"/home/user/data/cohort\",\n  \"children\": [\n    {\n      \"name\": \"BCH-HISTO-2024\",\n      \"type\": \"folder\",\n      \"children\": [...]\n    }\n  ]\n}\n\nuser@CALYPSO:[~]> quit\nGoodbye.\n----\n\nThis CLI is useful for:\n- Interactive debugging during development\n- Manual verification of workflows\n- Scripted automation (pipe commands via stdin)\n- Connecting to a running browser session for inspection\n\n=== VFS Snapshot Method\n\nAdd to `src/vfs/VirtualFileSystem.ts`:\n\n[source,typescript]\n----\n/**\n * Serialize a subtree of the VFS for snapshot comparison.\n *\n * Returns a deterministic JSON-serializable representation of the tree\n * structure and file metadata. Content is optionally included.\n *\n * @param rootPath - The subtree root (default: '/')\n * @param includeContent - Whether to include file content (default: false)\n * @returns Serializable tree snapshot\n */\npublic tree_snapshot(\n    rootPath: string = '/',\n    includeContent: boolean = false\n): VfsSnapshot {\n    const node: FileNode | null = this.node_get(rootPath);\n    if (!node) {\n        throw new Error(`Snapshot root not found: ${rootPath}`);\n    }\n    return this.node_serialize(node, includeContent);\n}\n\nprivate node_serialize(node: FileNode, includeContent: boolean): VfsSnapshotNode {\n    const serialized: VfsSnapshotNode = {\n        name: node.name,\n        type: node.type,\n        path: node.path,\n    };\n\n    if (node.type === 'file') {\n        serialized.size = node.size;\n        if (includeContent && node.content !== null) {\n            serialized.content = node.content;\n        }\n        if (node.contentGenerator) {\n            serialized.hasGenerator = true;\n        }\n    }\n\n    if (node.type === 'folder' && node.children) {\n        serialized.children = node.children\n            .map((child: FileNode): VfsSnapshotNode => this.node_serialize(child, includeContent))\n            .sort((a: VfsSnapshotNode, b: VfsSnapshotNode): number => a.name.localeCompare(b.name));\n    }\n\n    return serialized;\n}\n----\n\n=== Store Snapshot Method\n\nAdd to `src/core/state/store.ts`:\n\n[source,typescript]\n----\n/**\n * Serialize current store state for snapshot comparison.\n *\n * Excludes non-serializable globals (terminal, vcs, shell instances).\n * Returns only the serializable ExtendedState.\n *\n * @returns JSON-serializable state object\n */\npublic state_snapshot(): ExtendedState {\n    return JSON.parse(JSON.stringify(this._state));\n}\n----\n\n== Test Script Specification\n\n=== File Format\n\nOracle test scripts use YAML with the `.oracle` extension. The format is designed for readability and version control friendliness.\n\n=== Schema\n\n[source,yaml]\n----\n# Test metadata\nname: string                    # Human-readable test name\ndescription: string             # What this test verifies\ntags: string[]                  # Categorization (smoke, regression, workflow)\n\n# Initial conditions\nsetup:\n  persona: string               # Persona to activate (fedml, annotator, etc.)\n  stage: string                 # Starting stage (search, process, etc.)\n  reset: boolean                # Whether to reset state before test (default: true)\n\n# Test steps (executed sequentially)\nsteps:\n  - send: string                # Natural language command to Calypso\n    wait: number                # Optional delay in ms after command\n    assert:                     # Assertions to verify after this step\n      - vfs_exists: string                    # Path must exist\n      - vfs_not_exists: string                # Path must not exist\n      - vfs_contains:                         # File must contain text\n          path: string\n          content: string                     # Substring match\n          pattern: string                     # Regex match (alternative)\n      - vfs_snapshot_matches: string          # Path to snapshot file\n      - store.<property>: any                 # Store property must equal value\n      - output_contains: string               # Response contains text (weak)\n      - output_not_contains: string           # Response must not contain\n\n# Final state verification (after all steps)\nfinal_assertions:\n  - vfs_snapshot_matches: string\n  - store.currentStage: string\n\n# Optional: save snapshot for future comparison\nsave_snapshot:\n  path: string                  # VFS path to snapshot\n  file: string                  # Output file in snapshots/\n----\n\n=== Example Test Scripts\n\n==== Smoke Test: Basic Navigation\n\n[source,yaml]\n----\nname: \"Smoke: Stage Navigation\"\ndescription: \"Verify basic stage transitions work\"\ntags: [smoke, navigation]\n\nsetup:\n  persona: fedml\n  stage: search\n\nsteps:\n  - send: \"proceed to process\"\n    assert:\n      - store.currentStage: \"process\"\n      - vfs_exists: \"~/src/project/\"\n\n  - send: \"go back to search\"\n    assert:\n      - store.currentStage: \"search\"\n----\n\n==== Integration Test: Gather Workflow\n\n[source,yaml]\n----\nname: \"Integration: Dataset Gathering\"\ndescription: \"Verify dataset search, selection, and VFS mounting\"\ntags: [integration, gather, vfs]\n\nsetup:\n  persona: fedml\n  stage: search\n  reset: true\n\nsteps:\n  - send: \"search for histology datasets\"\n    wait: 500\n    assert:\n      - output_contains: \"BCH-HISTO\"\n\n  - send: \"add BCH-HISTO-2024 to my project\"\n    assert:\n      - store.gatheredDatasets:\n          includes: \"BCH-HISTO-2024\"\n\n  - send: \"create new project called TEST-HISTO\"\n    assert:\n      - vfs_exists: \"~/projects/TEST-HISTO/\"\n      - store.activeProject.name: \"TEST-HISTO\"\n\n  - send: \"open project TEST-HISTO\"\n    assert:\n      - store.currentStage: \"process\"\n      - vfs_exists: \"~/projects/TEST-HISTO/data/BCH-HISTO-2024/\"\n      - vfs_exists: \"~/projects/TEST-HISTO/src/train.py\"\n\nfinal_assertions:\n  - vfs_snapshot_matches: \"snapshots/gather-workflow-complete.json\"\n\nsave_snapshot:\n  path: \"~/projects/TEST-HISTO/\"\n  file: \"gather-workflow-complete.json\"\n----\n\n==== Regression Test: Overlay Lifecycle\n\n[source,yaml]\n----\nname: \"Regression: Overlay Slot Cleanup\"\ndescription: \"Verify overlay slots are properly cleared on close (prevents DOM corruption)\"\ntags: [regression, overlay, slots]\n\nsetup:\n  persona: fedml\n  stage: search\n  reset: true\n\nsteps:\n  # Open dataset detail\n  - send: \"show details for BCH-HISTO-2024\"\n    assert:\n      - store.overlayMode: \"dataset\"\n\n  # Close it\n  - send: \"close\"\n    assert:\n      - store.overlayMode: \"none\"\n\n  # Open marketplace\n  - send: \"open marketplace\"\n    assert:\n      - store.marketplaceOpen: true\n\n  # Open an asset detail\n  - send: \"show details for pl-dcm2niix\"\n    assert:\n      - store.overlayMode: \"marketplace\"\n\n  # Close and verify no DOM corruption (overlay returns to correct state)\n  - send: \"close\"\n    assert:\n      - store.overlayMode: \"none\"\n      - store.marketplaceOpen: true\n----\n\n==== End-to-End Test: Full Workflow\n\n[source,yaml]\n----\nname: \"E2E: Federated ML Developer Workflow\"\ndescription: \"Complete workflow from search through federation\"\ntags: [e2e, workflow, fedml]\n\nsetup:\n  persona: fedml\n  stage: search\n  reset: true\n\nsteps:\n  # Discovery\n  - send: \"find brain MRI datasets with segmentation masks\"\n    wait: 1000\n\n  - send: \"add MGH-BRAIN-SEG to project\"\n\n  - send: \"also add BCH-BRAIN-2024\"\n\n  # Project setup\n  - send: \"create project BRAIN-SEG-STUDY\"\n    assert:\n      - vfs_exists: \"~/projects/BRAIN-SEG-STUDY/\"\n\n  - send: \"open project\"\n    assert:\n      - store.currentStage: \"process\"\n      - vfs_exists: \"~/projects/BRAIN-SEG-STUDY/src/train.py\"\n      - vfs_exists: \"~/projects/BRAIN-SEG-STUDY/data/MGH-BRAIN-SEG/\"\n      - vfs_exists: \"~/projects/BRAIN-SEG-STUDY/data/BCH-BRAIN-2024/\"\n\n  # Development\n  - send: \"cat train.py\"\n    assert:\n      - output_contains: \"torch\"\n      - output_contains: \"FederatedTrainer\"\n\n  - send: \"analyze cohort\"\n    assert:\n      - output_contains: \"MODALITY CHECK\"\n\n  # Simulation\n  - send: \"simulate federation\"\n    wait: 2000\n    assert:\n      - output_contains: \"SIMULATION COMPLETE\"\n      - store.simulationPassed: true\n\n  # Federalization\n  - send: \"federate and launch\"\n    wait: 3000\n    assert:\n      - store.currentStage: \"monitor\"\n\nfinal_assertions:\n  - store.activeJob.status: \"running\"\n  - vfs_exists: \"~/projects/BRAIN-SEG-STUDY/output/\"\n----\n\n== Test Execution\n\n=== Makefile Targets\n\n[source,makefile]\n----\n# Start headless Calypso server (port 8081)\ncalypso:\n\tnpx ts-node src/cli/calypso-server.ts\n\n# Start interactive CLI client\ncalypso-cli:\n\tnpx ts-node src/cli/calypso-cli.ts\n\n# Run ORACLE tests (starts server, runs tests, stops server)\ntest-oracle:\n\tnpm run test:oracle\n\n# Run ORACLE tests with verbose output\ntest-oracle-verbose:\n\tnpm run test:oracle -- --verbose\n----\n\n=== Running Tests\n\n[source,bash]\n----\n# Run all ORACLE tests\nmake test-oracle\n\n# Run specific test file\nnpm run test:oracle -- tests/oracle/gather-workflow.oracle\n\n# Run tests by tag\nnpm run test:oracle -- --tag=smoke\nnpm run test:oracle -- --tag=regression\n\n# Run with verbose output\nmake test-oracle-verbose\n\n# Generate new snapshots (for baseline)\nnpm run test:oracle -- --update-snapshots\n----\n\n=== Manual Testing with CLI\n\nFor interactive debugging, use the CLI alongside the test:\n\n[source,bash]\n----\n# Terminal 1: Start Calypso server\n$ make calypso\n\n# Terminal 2: Run CLI for manual exploration\n$ make calypso-cli\nuser@CALYPSO:[~]> search histology\nuser@CALYPSO:[~]> add ds-012\nuser@CALYPSO:[~]> /snapshot ~/data/cohort/\n\n# Terminal 3: Run specific test against same server\n$ npm run test:oracle -- tests/oracle/gather-workflow.oracle\n----\n\n=== CI Integration\n\nOracle tests integrate with existing CI pipelines:\n\n[source,yaml]\n----\n# .github/workflows/test.yml\njobs:\n  oracle-tests:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Build\n        run: npm run build\n\n      - name: Start server\n        run: npm run serve &\n\n      - name: Wait for server\n        run: npx wait-on http://localhost:8080\n\n      - name: Run Oracle tests\n        run: npm run test:oracle\n\n      - name: Upload failure artifacts\n        if: failure()\n        uses: actions/upload-artifact@v4\n        with:\n          name: oracle-failures\n          path: tests/oracle/failures/\n----\n\n== Limitations and Considerations\n\n=== When ORACLE Is Appropriate\n\n- Systems with AI/conversational interfaces as primary interaction mode\n- Applications where internal state is the source of truth\n- Workflows that span multiple stages/components\n- Regression testing of integration seams\n\n=== When ORACLE Is Not Appropriate\n\n- Pure unit testing of isolated functions (use standard unit tests)\n- Visual regression testing (use screenshot comparison tools)\n- Performance/load testing (use dedicated profiling tools)\n- Testing the AI model itself (use LLM evaluation frameworks)\n\n=== AI Reliability\n\nORACLE assumes the AI layer has sufficient reliability to consistently classify intents. If the AI frequently misclassifies:\n\n1. Tests will fail on assertions (correct behavior — the system is broken)\n2. High test flakiness may indicate AI training issues\n3. Consider adding retry logic with backoff for known-flaky classifications\n\n=== Snapshot Maintenance\n\nState snapshots require maintenance as the system evolves:\n\n- Run `--update-snapshots` when intentional changes occur\n- Review snapshot diffs in code review\n- Consider snapshot granularity (full tree vs. subtree)\n\n== Future Work\n\n=== Planned Enhancements\n\n1. **Parallel Test Execution**: Run independent tests concurrently with isolated VFS instances\n2. **Fuzzing Mode**: Generate random valid command sequences to discover edge cases\n3. **Coverage Mapping**: Track which deterministic functions are exercised by which tests\n4. **Visual Assertions**: Optional DOM state assertions for UI-critical tests\n5. **Time Travel Debugging**: Record full state history for failed tests\n\n=== Research Directions\n\n1. **Adversarial Testing**: Intentionally ambiguous commands to verify graceful degradation\n2. **Multi-User Simulation**: Test concurrent sessions and state isolation\n3. **LLM-Generated Tests**: Use a second LLM to generate test scenarios from documentation\n\n== Conclusion\n\nORACLE represents a paradigm shift in testing AI-mediated systems. By embracing the AI interface as the test driver rather than testing around it, we achieve:\n\n- **Production parity**: Tests traverse the exact code path users do\n- **Integration coverage**: The most bug-prone seams are directly exercised\n- **Self-documentation**: Test scripts serve as executable workflow documentation\n- **Regression detection**: State-based assertions catch integration failures that unit tests miss\n\nThe reflexive nature of ORACLE — using the system to test itself — is not a limitation but a feature. If Calypso cannot successfully drive a workflow, neither can a user. The test failure surface equals the user failure surface.\n\n[bibliography]\n== References\n\n- [[[magnitude]]] Sharma, S. \"A Review of Open-Source AI-Driven UI Test Automation Frameworks (2025).\" Medium, 2025. https://medium.com/@ss-tech/a-review-of-open-source-ai-driven-ui-test-automation-frameworks-2025-4b957cdf822d\n\n- [[[testzeus]]] TestZeus. \"Hercules: AI-Driven Test Automation.\" 2025. https://github.com/test-zeus-ai/testzeus-hercules\n\n- [[[langwatch]]] LangWatch. \"Agent Testing with Simulations.\" 2025. https://langwatch.ai/blog/the-4-best-llm-evaluation-platforms-in-2025-why-langwatch-eedefines-the-category-with-agent-testing-(with-simulations)\n\n- [[[applitools]]] Applitools. \"Visual AI Testing Platform.\" https://applitools.com\n\n- [[[meyer]]] Meyer, B. \"Design by Contract.\" IEEE Computer, 1992. https://doi.org/10.1109/2.161279\n\n- [[[metamorphic]]] Chen, T.Y., Cheung, S.C., Yiu, S.M. \"Metamorphic Testing: A New Approach for Generating Next Test Cases.\" Technical Report HKUST-CS98-01, 1998.\n\n- [[[selfhealing]]] Kephart, J.O., Chess, D.M. \"The Vision of Autonomic Computing.\" IEEE Computer, 2003. https://doi.org/10.1109/MC.2003.1160055\n\n- [[[qualizeal]]] QualiZeal. \"The Rise of Agentic AI: Transforming Software Testing in 2025 and Beyond.\" 2025. https://qualizeal.com/the-rise-of-agentic-ai-transforming-software-testing-in-2025-and-beyond/\n\n- [[[testgrid]]] TestGrid. \"Agentic AI Testing: The Future of Autonomous Software QA.\" 2025. https://testgrid.io/blog/agentic-ai-testing/\n\n---\n_Last updated: {revdate} (v{revnumber})_",
    "philosophy.adoc": "= ARGUS: Design Philosophy and Conceptual Framework\n:author: ATLAS Project Team\n:revdate: 2026-01-23\n:toc:\n:sectnums:\n\n== Introduction\n\nARGUS (ATLAS Resource Graphical User System) serves as the primary interface through which users interact with the ATLAS federated medical imaging platform. The name draws from Greek mythology, where Argus Panoptes was the hundred-eyed giant whose vigilance made him the perfect guardian. In the context of ATLAS, ARGUS provides comprehensive visibility into distributed resources across federated Trusted Domains, enabling users to search, curate, process, and monitor medical imaging workflows while maintaining the security and governance guarantees that ATLAS provides.\n\nThis document establishes the conceptual foundations that guide ARGUS development, ensuring that implementation decisions remain aligned with user needs and platform capabilities.\n\n== The SeaGaP-MP Workflow Framework\n\nAt the core of ARGUS lies a unifying interaction pattern called SeaGaP-MP, an acronym representing the five stages through which users accomplish their goals: Search, Gather, Process, Monitor, and Post. This framework emerged from analysis of how different user personas interact with federated medical imaging resources, revealing that despite significant differences in ultimate objectives, the underlying workflow structure remains remarkably consistent.\n\n=== Search\n\nThe Search stage represents the user's initial engagement with the ATLAS catalog. Users query metadata to discover resources relevant to their task, whether those resources are annotated training datasets, raw images requiring labels, pre-trained models, or processing applications. The search interface must accommodate both structured queries with specific filter criteria and exploratory browsing for users who may not yet know precisely what they need.\n\nCritical to the Search stage is transparency regarding resource characteristics that affect downstream decisions. Access costs, expected processing times, cohort sizes, data provenance, and quality metrics must be surfaced during search so that users can make informed selections before committing resources.\n\n=== Gather\n\nOnce users have identified relevant resources through search, the Gather stage assembles those resources into a working context. ARGUS presents gathered resources using a virtual filesystem metaphor, consistent with the MERIDIAN architecture's foundational principle that applications interact with data through standard filesystem interfaces rather than custom APIs.\n\nThis virtual filesystem abstraction serves multiple purposes. It provides a familiar mental model for users accustomed to working with files and directories. It aligns with the ChRIS platform's feed-based provenance model, where workflow state is represented as materialized filesystem trees. And it enables seamless transition to the Process stage, where development environments and applications expect filesystem-based data access.\n\nThe Gather stage also presents cost estimates for the assembled cohort, giving users an opportunity to refine their selection before committing to processing. Users should understand what they will pay before they proceed, and the platform must provide mechanisms to adjust the gathered set to meet budget constraints.\n\n=== Process\n\nThe Process stage encompasses the actual work users perform on gathered resources. The nature of this work varies significantly by persona. Developers write training code in integrated development environments, which ATLAS then transcodes into federated machine learning workflows distributed across contributing Trusted Domains. Annotators apply labels to images through specialized annotation interfaces. Users execute inference by running pre-trained models against their gathered image sets.\n\nDespite this variation, the Process stage shares common characteristics across personas. Work occurs within the security boundary of appropriate Trusted Domains, ensuring that raw data never leaves institutional control. The MERIDIAN architecture guarantees that processing applications conform to defined security levels, with most applications operating at Level 0 where no external network access is permitted.\n\nFor the Developer persona specifically, the Process stage contains significant complexity that the interface must make tractable. Users write standard training code as if working with local data, and ATLAS handles the transformation into federated learning workflows. This transcoding represents substantial value but also substantial machinery.\n\nTo bridge the gap between this \"local mental model\" and the \"global execution reality,\" ARGUS imposes a **Simulation Loop**. Before code can be deployed to partners, it must pass a local \"Phantom Federation\" check. This ensures that the developer's code can withstand the serialization, aggregation, and privacy noise injection inherent to federation, all within a safe local sandbox. The interface should provide appropriate visibility into this transformation, building user trust without overwhelming them with implementation details.\n\n=== Monitor\n\nAfter processing begins, users require visibility into execution progress. The Monitor stage provides this visibility through interfaces appropriate to the work being performed. Developers training models see epoch progression, loss curves, and per-node status across participating Trusted Domains. Users running inference see job completion percentages and estimated time remaining. Annotators see progress through their assigned image sets.\n\nThe Monitor stage must also surface cost accumulation during execution. Users who authorized a maximum expenditure need confidence that the platform respects that limit, with clear indication of current spend against budget. When costs approach limits, users must have the ability to abort execution. The platform guarantees that aborted jobs incur no charges for incomplete work, though partial results may be available depending on the nature of the processing.\n\n=== Post\n\nThe Post stage addresses what happens after processing completes. Results must be retrieved, reviewed, and potentially persisted back into the ATLAS ecosystem for others to discover and use.\n\nFor Developers, the Post stage involves publishing trained models to the marketplace. The training process produces weight files in the aggregator's output directory, with full provenance captured as nested filesystem directories showing the complete lineage from input data through processing steps to final output. Publishing makes these models available as MERIDIAN-compliant applications that other users can discover and execute.\n\nFor Annotators, the Post stage involves persisting annotations. These may either enrich the original data's metadata in the catalog, making the annotations discoverable alongside the source images, or they may be published as separate annotation products that reference the source data. The choice depends on licensing arrangements, institutional policies, and annotator preferences.\n\nFor Users running inference, the Post stage is typically simpler, involving export or download of results to external systems or persistence within the user's ATLAS workspace for future reference.\n\n== User Personas\n\nARGUS serves multiple distinct user personas, each with different goals, expertise levels, and interaction patterns. While all personas navigate the SeaGaP-MP workflow, the specific content and complexity at each stage varies significantly.\n\n=== Federated ML Developer\n\nThe Federated ML Developer persona represents researchers and engineers building new machine learning models using ATLAS resources. They possess technical sophistication and expect powerful tools, including integrated development environments comparable to VSCode or JupyterLab. Their workflow emphasizes iteration and experimentation, with frequent cycles through the SeaGaP-MP stages as they refine their approaches.\n\nThe defining characteristic of the Federated ML Developer experience in ATLAS is the platform's ability to transform standard training code into federated learning workflows automatically. They write code as if working with local data, and ATLAS handles distribution across Trusted Domains, aggregation of gradients, and production of final models. This capability represents the platform's core value proposition for this persona.\n\n=== Annotator\n\nThe Annotator persona represents individuals who apply labels to medical images, creating the annotated datasets that Developers require for training. Annotators may be clinical experts such as radiologists or pathologists whose domain knowledge gives their annotations particular authority, or they may be trained technicians working under clinical supervision.\n\nThe Annotator workflow emphasizes efficiency and ergonomics for repetitive tasks. The interface must minimize friction in moving through images while providing powerful annotation tools appropriate to the imaging modality. Progress tracking and quality metrics help annotators and their supervisors understand throughput and consistency.\n\n=== User\n\nThe User persona represents consumers of trained models who wish to run inference on their own images. Users may have limited technical sophistication and expect straightforward interfaces that hide platform complexity. Their primary concern is obtaining results, not understanding the machinery that produces them.\n\nThe User workflow is typically the simplest instantiation of SeaGaP-MP. Search focuses on finding appropriate models and uploading or selecting images for processing. Gather is often implicit in the search stage. Process involves execution with minimal configuration. Monitor shows progress toward completion. Post delivers results in usable formats.\n\n=== Data Provider\n\nThe Data Provider persona represents institutions contributing data to the ATLAS ecosystem. Unlike other personas who use ATLAS to accomplish external goals, Data Providers are primarily concerned with visibility into how their contributed resources are being used, what revenue those contributions generate, and what governance policies apply.\n\nThe Data Provider workflow inverts the typical consumption pattern. Search focuses on their own contributed data and its usage patterns. Gather assembles reports and analytics. Process involves policy management and pricing decisions. Monitor tracks access patterns and revenue accumulation. Post updates catalog listings and governance configurations.\n\n=== App Developer\n\nThe App Developer persona represents engineers building MERIDIAN-compliant applications beyond machine learning models. These may include image processing pipelines, quality control tools, format converters, or visualization applications. App Developers require access to platform APIs, testing infrastructure, and publication workflows.\n\n=== Administrator\n\nThe Administrator persona represents individuals responsible for platform governance, user management, and compliance. Administrators require visibility into system health, audit logs, access patterns, and policy enforcement. Their workflow centers on oversight and control rather than resource consumption.\n\n== Cost Model Principles\n\nARGUS implements a cost model designed to give users confidence and control over their expenditures. Three principles guide this implementation.\n\nFirst, users see cost estimates before committing to processing. The Gather stage presents projected costs based on the assembled resource set and intended processing. Users can adjust their selections to meet budget constraints before any charges accrue.\n\nSecond, users see cost accumulation during processing. The Monitor stage displays running totals against authorized budgets, ensuring that users always understand their current expenditure.\n\nThird, users can abort processing without penalty for incomplete work. If a user cancels a job before completion, they receive no results but incur no charges. This guarantee gives users confidence to experiment without fear of runaway costs.\n\n== Provenance and Output Model\n\nATLAS captures complete provenance for all processing through its filesystem-based workflow model. Each processing step materializes its inputs and outputs as filesystem directories, creating an explicit record of data flow through the workflow graph. This approach, inherited from the ChRIS platform's feed architecture, ensures that users can trace any result back through its complete derivation history.\n\nFor machine learning workflows specifically, the aggregator process running on the central hub produces final outputs in its designated output directory. Weight files, training logs, and associated metadata persist with full provenance linking them to the training data, code, and configuration that produced them.\n\nThis filesystem-centric approach aligns with the MERIDIAN architecture's core principle: by standardizing on filesystem interfaces rather than custom APIs, the platform achieves integration scalability while maintaining the auditability and reproducibility that regulated medical applications require.\n\n== Conclusion\n\nARGUS provides the window through which users see and interact with the ATLAS platform. The SeaGaP-MP framework ensures consistent workflow structure across diverse personas, while persona-specific adaptations address the varying needs of Developers, Annotators, Users, Data Providers, App Developers, and Administrators. Cost transparency, abort guarantees, and comprehensive provenance build the trust necessary for users to commit valuable resources to federated processing. These philosophical foundations guide implementation decisions as ARGUS development proceeds.",
    "seagap-workflow.adoc": "= ARGUS: SeaGaP Workflow UX Specification\n:author: ATLAS Project Team\n:revdate: 2026-01-30\n:toc:\n:sectnums:\n\n== Overview\n\nSeaGaP-MP (Search, Gather, Process, Monitor, Post) defines the five-stage workflow for federated medical imaging in ARGUS. This document describes the **user experience** at each stage -- what the user sees, what actions are available, and how data flows between stages.\n\nAs of v4.4.0, the Search and Gather stages are **fused** into a single interactive flow. The user discovers datasets, browses their contents at file-level granularity, selects specific files and directories, and accumulates gathered data across multiple datasets -- all without leaving the Search stage. The traditional Gather stage (a separate review screen) is superseded by this inline gathering model.\n\n== The Three Modes of Search\n\nThe Search stage supports three distinct user intents, all served by the same UI:\n\n[cols=\"1,3,2\"]\n|===\n| Mode | Intent | Entry Point\n\n| **Work on existing project**\n| Open a previously-saved project and enter the workspace IDE\n| Click a project chip in the project strip, then click again to open detail, then OPEN\n\n| **Search for new data**\n| Discover and browse datasets for a new project\n| Type a query in the AI Core, browse dataset tiles\n\n| **Add data to existing project**\n| Gather additional datasets into an existing project's data tree\n| Click a project chip to set it as the gather target (highlighted), then search and gather datasets. If no project is selected, clicking ADD automatically creates a new Draft Project.\n|===\n\n== Draft Projects & Local Uploads (v4.6.0)\n\nTo support a more flexible \"Filesystem First\" workflow, ARGUS now supports **Draft Projects** that start as clean, empty directories without the rigid Federated Learning boilerplate.\n\n### The \"Just a Folder\" Model\n\n1.  **Immediate Creation**: Clicking **`+ NEW`** in the project strip immediately creates a new workspace at `~/projects/DRAFT-XXXX/`. It does *not* pre-populate `src/` or `train.py`.\n2.  **Context Switching**: The terminal automatically `cd`s to the new project root.\n3.  **Local Data**: Users can type `upload` in the terminal to ingest local files (PDFs, images, CSVs) directly into the project root.\n4.  **Rich Preview**: The Project Detail view detects the flat structure and shows a single **\"FILES\"** tab. It supports inline preview of uploaded PDFs and images.\n5.  **Progressive Structure**: When you `ADD` a dataset from the catalog, it appears as a `data/` folder alongside your uploads. Only when you decide to write code does the `src/` structure become necessary.\n\n### Implicit Creation (The \"Gather First\" Flow)\n\nIf the user adds a dataset (via the \"ADD\" button or \"DONE\" in detail view) while *no project is active* (no chip selected), the system **automatically creates a new Draft Project** to house the gathered data.\n\n*   **VFS**: A new draft directory is created (e.g., `~/projects/DRAFT-5678/`).\n*   **Notification**: The Intelligence Console confirms: \"NO ACTIVE PROJECT DETECTED. INITIATING NEW DRAFT WORKSPACE [DRAFT-5678]. COHORT MOUNTED.\"\n*   **State**: The new draft becomes the active gather target.\n\n### Project Renaming\n\nDraft projects can be renamed at any time via the **RENAME** pill in the Project Detail overlay. This moves the underlying VFS directory and updates all references, preserving your gathered data and uploads.\n\n== The Project Strip\n\nA persistent horizontal strip at the top of the Search stage displays all user projects as compact **project chips**. This strip never disappears during search or dataset browsing.\n\n=== Visual Design\n\nThe strip is a scrollable flex row with a \"PROJECTS\" header label followed by one chip per project:\n\n----\nPROJECTS  [PNEUMONIA-STUDY-V1  2DS]  [BRAIN-TUMOR-SEG  1DS]  [+ NEW]\n----\n\n* **Default state**: honey-colored border and text on dark background.\n* **Active state** (gather target): solid honey background with black text and glow. Indicates that gathered data will merge into this project.\n* **\"+ NEW\" chip**: dashed border, harvestgold color. Clears the active target -- gathered data will create a new project.\n\n=== Interaction\n\n* **First click** on a project chip sets it as the **gather target** (highlighted). Terminal confirms: \"GATHER TARGET: [PROJECT NAME]\".\n* **Second click** (chip already active) opens the project detail overlay (same as before -- FileBrowser with SOURCE/DATA tabs, OPEN button for workspace).\n* Clicking a different chip switches the gather target.\n* Clicking \"+ NEW\" clears the gather target.\n\n== Dataset Discovery\n\nWhen the user enters a search query (via AI Core or legacy filters), dataset tiles appear below the project strip. Each dataset is rendered as an `AssetCard` with:\n\n* **Badge**: Modality and annotation type (e.g., \"XRAY - CLASSIFICATION\")\n* **Meta**: Provider, image count, size\n* **Cost**: Per-dataset cost in the badge area\n* **Action pill**: \"BROWSE\" (default) or \"GATHERED\" (after selection)\n\nClicking a dataset tile opens the **Dataset Detail Overlay**.\n\n== Dataset Detail: The Gather Interface\n\nThe dataset detail overlay reuses the shared `#asset-detail-overlay` DOM element (same as Marketplace and Project detail views), but populated for gathering:\n\n=== Layout\n\n* **LCARS Frame**: Hue 200 (sky blue, the dataset color family)\n* **Sidebar**: Single \"DATA\" tab (datasets have no source code)\n* **Content**: A `FileBrowser` in **selectable mode** showing the dataset's file tree\n* **Cost strip**: Real-time tally of selected files and estimated cost\n* **Command column**: Three pills -- DONE, ADDITIONAL DATA, CANCEL\n\n=== Selectable FileBrowser\n\nThe FileBrowser component operates in selectable mode (`selectable: true`). Interactions:\n\n[cols=\"1,3\"]\n|===\n| Action | Effect\n\n| **Short click** on a file\n| Opens file preview in the preview pane (standard behavior)\n\n| **Long press** (500ms+) on a file\n| Toggles file selection. Selected files show a canary checkmark and left-border highlight.\n\n| **Long press** on a folder\n| Toggles selection of the folder and **all descendant files**. If all are selected, deselects all. If some or none are selected, selects all.\n|===\n\nSelected items receive the `.selected-for-gather` CSS class, which adds:\n* A canary-colored left border (3px solid)\n* A subtle background tint\n* A checkmark (✓) prefix on file names\n\n=== Cost Model\n\nCost per file is calculated as:\n\n----\ncostPerFile = dataset.cost / totalFileCount\nselectionCost = selectedFileCount * costPerFile\n----\n\nThe cost strip updates live as selections change:\n\n----\nSELECTED: 45 / 293 FILES  |  ESTIMATED COST: $6.92\n----\n\n== The Gather Cycle\n\n=== Committing a Selection\n\n**DONE pill**: Commits the current selection and closes the overlay.\n\n1. The selected file paths are extracted from the FileBrowser.\n2. A **pruned subtree** is built: the directory skeleton is preserved, but only selected files are kept.\n3. The subtree is stored in the `gatheredDatasets` map, keyed by dataset ID.\n4. If a gather target project is active, the subtree is mounted into the project's VFS `/data` tree.\n5. The dataset tile in the grid receives the `.gathered` class (visual tint + \"GATHERED\" badge).\n6. Terminal confirms the gather with file count.\n\n**ADDITIONAL DATA pill**: Same as DONE, but signals the user's intent to continue gathering from other datasets. The overlay closes, the gathered tile is marked, and the user returns to the search grid.\n\n**CANCEL pill**: Closes the overlay without committing any selection.\n\n=== Accumulation\n\nMultiple datasets can be gathered in sequence. Each DONE or ADDITIONAL DATA action adds to the `gatheredDatasets` map. The accumulated data merges additively into the target project's `/data` tree -- each dataset contributes its own subdirectory.\n\n=== Visual Feedback\n\nGathered dataset tiles in the search grid show:\n\n* Reduced opacity (0.85)\n* Harvestgold border color and subtle glow\n* A \"GATHERED\" badge in the top-right corner\n* The action pill text changes to \"GATHERED\" (inactive state)\n\n== Data Flow: Search to Process\n\nOnce the user has gathered data from one or more datasets:\n\n1. If a project chip is the gather target, the project's VFS `/data` tree now contains the gathered subtrees.\n2. The user clicks the active project chip again to open the project detail.\n3. From the project detail, clicking OPEN enters the workspace (terminal + FileBrowser split-pane).\n4. The FileBrowser's DATA tab shows the merged gathered data.\n5. The terminal is mounted at the project root with access to both `/src` and `/data`.\n6. The user proceeds to write code, configure training, and federalize.\n7. **Simulation**: Before federalizing, the user runs `simulate federation` to validate the code against a local \"Phantom Federation\" of data shards. This unlocks the \"FEDERALIZE\" action.\n\nIf no project was the gather target (\"+ NEW\" mode), the gathered data is stashed and can be associated with a new project when one is created.\n\n== Stage Summary\n\n[cols=\"1,2,3\"]\n|===\n| Stage | Status | Notes\n\n| **Search**\n| Active — fused with Gather\n| Project strip, dataset discovery, inline file-level gathering\n\n| **Gather**\n| Superseded\n| Legacy stage still exists in code but the inline gather model replaces its UX role\n\n| **Process**\n| Active\n| Workspace IDE with terminal + FileBrowser split-pane, FEDERALIZE AND LAUNCH\n\n| **Monitor**\n| Active\n| Real-time training telemetry, loss charts, node status\n\n| **Post**\n| Active\n| Model publication to Marketplace\n|===\n\n---\n_Last updated: 2026-01-30 (v4.4.0)_",
    "vcs.adoc": "= ARGUS Virtual Computer System (VCS) Specification\n:author: ATLAS Project Team\n:revdate: 2026-01-29\n:toc:\n:toclevels: 3\n:sectnums:\n\n== Overview\n\nThe Virtual Computer System (VCS) is the stateful runtime environment underlying the ARGUS Intelligence Terminal. It provides a POSIX-like in-memory filesystem with file content, a shell interpreter with environment variables, and a provider system that populates the filesystem from application context (datasets, projects, marketplace installs).\n\n=== Purpose\n\nThe VCS replaces the current `VirtualFileSystem` class (`src/core/logic/vfs.ts`), which provides directory navigation but no file content, no shell abstraction, and no integration with the application lifecycle. The current implementation has the following deficiencies:\n\n[cols=\"1,2\"]\n|===\n| Deficiency | Impact\n\n| `FileNode` has no `content` field\n| `cat` cannot work. IDE content is hardcoded HTML in `process.ts`.\n\n| Prompt is set by string literals\n| Terminal prompt and VFS CWD are out of sync after stage transitions.\n\n| No `cat`, `rm`, `cp`, `mv`\n| Users cannot read, delete, copy, or move files.\n\n| Stage transitions don't call `cd`\n| Process stage claims `~/src/project` but CWD remains `/home/user`.\n\n| Marketplace installs create name-only nodes\n| `vfs.touch('/home/user/bin/x')` creates an entry with no content or metadata.\n\n| Filesystem rebuilt from scratch each Gather\n| No persistence across the session. No accumulation of artifacts.\n|===\n\nThe VCS resolves all of these by providing a complete, stateful mini-computer that the terminal interacts with as a real shell environment.\n\n=== Design Principles\n\n1. **Single Source of Truth.** The VCS owns the current working directory, the filesystem tree, and all file content. The terminal prompt reads from the VCS. Stage transitions issue real `cd` commands through the Shell. The IDE reads file content from the VCS.\n\n2. **POSIX Familiarity.** Users who know Unix will feel at home. `ls`, `cd`, `cat`, `pwd`, `mkdir`, `touch`, `rm`, `cp`, `mv`, `echo`, `env` work as expected. Paths are `/`-separated. `~` expands to `$HOME`.\n\n3. **Content-Aware Files.** Every file in the VCS can have content — a string (for text files) or a metadata descriptor (for binary stubs like images). The content is generated on demand by Providers and cached in the filesystem.\n\n4. **Provider Architecture.** The VCS does not know about datasets, projects, or marketplace assets. Providers are responsible for translating application domain objects into filesystem trees with content. This keeps the VCS pure and the domain logic encapsulated.\n\n5. **Event-Driven Integration.** The VCS emits events on mutation (`VFS_CHANGED`, `CWD_CHANGED`). The Store, terminal, and UI components subscribe to these events. The VCS never reaches into the DOM.\n\n== Architecture\n\n=== Component Diagram\n\n----\n┌──────────────────────────────────────────────────────────┐\n│                     Terminal (UI)                        │\n│              Sends keystrokes, renders output            │\n└──────────────────────┬───────────────────────────────────┘\n                       │\n                       ▼\n┌──────────────────────────────────────────────────────────┐\n│                      Shell                               │\n│  Command parsing, builtin dispatch, env vars, prompt     │\n│  $HOME, $USER, $PWD, $PATH, exit codes, history          │\n└──────────────────────┬───────────────────────────────────┘\n                       │\n                       ▼\n┌──────────────────────────────────────────────────────────┐\n│                 VirtualFileSystem                        │\n│  Tree storage, content storage, path resolution          │\n│  read(), write(), rm(), cp(), mv(), stat(), ls(), cd()   │\n│  mount(), unmount(), event emission                      │\n└───────────┬──────────────────────────┬───────────────────┘\n            │                          │\n            ▼                          ▼\n┌───────────────────┐     ┌────────────────────────────────┐\n│  ContentRegistry  │     │          Providers             │\n│  Templates &      │     │  DatasetProvider               │\n│  generators for   │◄────│  ProjectProvider               │\n│  file bodies      │     │  MarketplaceProvider           │\n└───────────────────┘     └────────────────────────────────┘\n----\n\n=== Data Flow\n\n1. **User types `cat train.py`** in the terminal.\n2. **Terminal** sends the raw input string to the **Shell**.\n3. **Shell** parses the command (`cat`) and argument (`train.py`), resolves the path relative to `$PWD`.\n4. **Shell** calls `vfs.read('/home/user/src/project/train.py')`.\n5. **VirtualFileSystem** looks up the node. If `content` is `null`, it calls the **ContentRegistry** to generate content on demand.\n6. **ContentRegistry** finds the registered template for `train.py`, invokes it with the current project context, and returns the content string.\n7. **VirtualFileSystem** caches the content on the node and returns it.\n8. **Shell** wraps the content in a `ShellResult` (`{ stdout, stderr, exitCode }`).\n9. **Terminal** renders `stdout` to the screen.\n\n== Filesystem Layout\n\n=== Root Structure\n\n----\n/\n├── home/\n│   └── <username>/          # $HOME — one per authenticated user (default: 'user')\n│       ├── data/\n│       │   ├── cohort/      # Current gathered datasets (populated by DatasetProvider)\n│       │   └── cache/       # Intermediate processing artifacts\n│       ├── src/\n│       │   └── project/     # Active project workspace (populated by ProjectProvider)\n│       ├── models/          # Training outputs + installed models\n│       ├── results/         # Post-stage published artifacts\n│       ├── bin/             # User-local scripts and tools\n│       └── .config/\n│           └── argus.yaml   # User preferences, API keys\n│\n├── bin/                     # System-wide executables (marketplace plugin installs)\n├── data/\n│   ├── catalog/             # Read-only ATLAS catalog mirror\n│   │   ├── datasets.json\n│   │   └── models.json\n│   ├── sets/                # Marketplace dataset installs\n│   └── annotations/         # Marketplace annotation tool installs\n│\n└── etc/\n    └── atlas/\n        ├── nodes.json       # Trusted Domain registry\n        └── federation.yaml  # Default federation parameters\n----\n\n=== Well-Known Paths Under `$HOME`\n\nThese paths are scaffolded at login by the `ProjectProvider`. They are conventions, not enforced — the user can remove or rename them. Stage transitions `cd` to the relevant path but do not require it to exist.\n\n[cols=\"1,2\"]\n|===\n| Path | Purpose\n\n| `~/data/cohort/`\n| Gathered datasets for the current session. Populated by `DatasetProvider` during the Gather stage. Contains one subdirectory per contributing institution (e.g., `BCH/`, `MGH/`), each with `images/`, `masks/`, and annotation files.\n\n| `~/data/cache/`\n| Intermediate artifacts from processing. Cleared between sessions.\n\n| `~/src/project/`\n| Active project workspace. Contains `train.py`, `config.yaml`, `requirements.txt`, `README.md`, and a `.meridian/` directory for federation manifests.\n\n| `~/models/`\n| Training outputs (weights, metrics) and marketplace model installs.\n\n| `~/results/`\n| Post-stage published artifacts. Populated after `model_publish()`.\n\n| `~/bin/`\n| User-local scripts and tools. Distinct from `/bin/` (system-wide).\n\n| `~/.config/argus.yaml`\n| User preferences, stored API keys, shell configuration.\n\n| `~/.history`\n| Shell command history. Persisted across sessions (localStorage-backed).\n|===\n\n=== System Paths\n\nThese paths are managed by the VCS and Providers. They are writable only through Provider APIs, not directly by the user.\n\n[cols=\"1,2\"]\n|===\n| Path | Purpose\n\n| `/bin/`\n| Marketplace plugin installs. Each plugin is an executable stub with metadata content (name, version, description, usage).\n\n| `/data/catalog/`\n| Read-only mirror of the ATLAS catalog. Contains `datasets.json` and `models.json` generated from `core/data/datasets.ts` and `core/data/marketplace.ts`.\n\n| `/data/sets/`\n| Marketplace dataset installs. Each dataset is a directory with a `manifest.json`.\n\n| `/data/annotations/`\n| Marketplace annotation tool installs. Each tool is a directory with a `manifest.json`.\n\n| `/etc/atlas/nodes.json`\n| Trusted Domain registry. Generated from `core/data/nodes.ts`.\n\n| `/etc/atlas/federation.yaml`\n| Default federation parameters.\n|===\n\n== Persona System\n\n=== `$HOME` Per User\n\n`$HOME` is always `/home/<username>`. The username is determined at login. In the current prototype, the username matches the persona name (`developer`, `annotator`, etc.). In a production system, this would be the authenticated user's ID.\n\n=== Landing Directory Per Persona\n\nAfter login, the Shell `cd`s to the persona's landing directory. This is where the user's session begins — analogous to a desktop environment opening a specific folder.\n\n[cols=\"1,1,2\"]\n|===\n| Persona | Landing Directory | Rationale\n\n| Developer\n| `~/src/project`\n| Ready to code. Project files immediately visible.\n\n| Annotator\n| `~/workspace`\n| Ready to label. Annotation queue visible.\n\n| Clinician\n| `~/cases`\n| Ready to review. Patient cases visible.\n\n| Scientist\n| `~/experiments`\n| Ready to analyze. Experiment notebooks visible.\n\n| Provider\n| `~/data`\n| Ready to manage contributed data.\n\n| Admin\n| `~/system`\n| Ready to manage users and nodes.\n\n| FDA / Regulatory\n| `~/audits`\n| Ready to review compliance artifacts.\n|===\n\n=== Home Directory Scaffolding\n\nAt login, the `ProjectProvider` scaffolds the well-known subdirectory structure under `$HOME`. The scaffolding is additive — it creates directories that don't exist but never overwrites existing content. This preserves any user modifications from a previous session (if session persistence is implemented).\n\n== VirtualFileSystem API\n\n=== FileNode Interface\n\n[source,typescript]\n----\ninterface FileNode {\n    name: string;\n    type: 'file' | 'folder';\n    path: string;                          // Absolute path\n    size: string;                          // Human-readable (e.g., '4.2 KB')\n    content: string | null;                // Text content, null if not yet generated\n    contentGenerator: string | null;       // ContentRegistry key for lazy generation\n    permissions: 'rw' | 'ro';             // Read-write or read-only\n    modified: Date;                        // Last modification timestamp\n    children: FileNode[] | null;           // null for files, array for folders\n    metadata: Record<string, string>;      // Arbitrary key-value pairs (DICOM headers, etc.)\n}\n----\n\n=== Core Methods\n\nAll methods follow the project RPN naming convention: `<subject>_<verb>`.\n\n[cols=\"2,2,3\"]\n|===\n| Method | Signature | Behavior\n\n| `node_read`\n| `(path: string): string \\| null`\n| Returns file content. If `content` is null and `contentGenerator` is set, invokes the ContentRegistry to generate content on demand. Returns null for folders. Throws if path does not exist.\n\n| `node_write`\n| `(path: string, content: string): void`\n| Writes content to a file. Creates the file if it does not exist (parent must exist). Updates `modified` timestamp and `size`. Emits `VFS_CHANGED`.\n\n| `node_remove`\n| `(path: string): void`\n| Removes a file or empty folder. Throws if folder is not empty (unless `recursive: true`). Emits `VFS_CHANGED`.\n\n| `node_copy`\n| `(src: string, dest: string): void`\n| Copies a file or folder tree. Deep copy — new nodes, same content. Emits `VFS_CHANGED`.\n\n| `node_move`\n| `(src: string, dest: string): void`\n| Moves a file or folder. Reparents the node in the tree. Updates `path` recursively. Emits `VFS_CHANGED`.\n\n| `node_stat`\n| `(path: string): FileNode \\| null`\n| Returns the FileNode at the given path without reading content. Returns null if not found.\n\n| `dir_list`\n| `(path: string): FileNode[]`\n| Returns the children of a directory. Throws if path is not a folder.\n\n| `dir_create`\n| `(path: string): void`\n| Creates a directory. Creates intermediate directories if needed (like `mkdir -p`). Emits `VFS_CHANGED`.\n\n| `file_create`\n| `(path: string, content?: string): void`\n| Creates an empty file (like `touch`). Optionally with initial content. Emits `VFS_CHANGED`.\n\n| `path_resolve`\n| `(input: string): string`\n| Resolves a relative path against `$PWD`. Expands `~` to `$HOME`. Normalizes `.` and `..`.\n\n| `cwd_get`\n| `(): string`\n| Returns the current working directory as an absolute path.\n\n| `cwd_set`\n| `(path: string): void`\n| Changes the current working directory. Throws if path does not exist or is not a folder. Emits `CWD_CHANGED`.\n\n| `tree_mount`\n| `(path: string, root: FileNode): void`\n| Mounts a subtree at the given path. Used by Providers to attach generated trees. Emits `VFS_CHANGED`.\n\n| `tree_unmount`\n| `(path: string): void`\n| Removes a previously mounted subtree. Emits `VFS_CHANGED`.\n|===\n\n=== Events\n\n[cols=\"1,2,2\"]\n|===\n| Event | Payload | Emitted By\n\n| `VFS_CHANGED`\n| `{ path: string, operation: string }`\n| Any mutation method (`node_write`, `node_remove`, `dir_create`, etc.)\n\n| `CWD_CHANGED`\n| `{ oldPath: string, newPath: string }`\n| `cwd_set()`\n|===\n\n== Shell\n\nThe Shell is the command interpreter layer between the Terminal UI and the VirtualFileSystem. It is the \"computer\" the user talks to. The Terminal becomes a dumb I/O surface: it sends keystrokes to the Shell and renders whatever the Shell returns.\n\n=== ShellResult Interface\n\n[source,typescript]\n----\ninterface ShellResult {\n    stdout: string;      // Standard output (rendered by terminal)\n    stderr: string;      // Standard error (rendered in red by terminal)\n    exitCode: number;    // 0 = success, non-zero = error\n}\n----\n\n=== Environment Variables\n\n[cols=\"1,1,2\"]\n|===\n| Variable | Default | Description\n\n| `$HOME`\n| `/home/user`\n| User's home directory. Set at login.\n\n| `$USER`\n| `user`\n| Current username. Set at login.\n\n| `$PWD`\n| `$HOME`\n| Current working directory. Updated by `cd`. Synonym for `vfs.cwd_get()`.\n\n| `$PATH`\n| `/bin:~/bin`\n| Executable search path. Used by Shell to resolve commands.\n\n| `$PERSONA`\n| `fedml`\n| Current persona context.\n\n| `$STAGE`\n| `search`\n| Current SeaGaP stage. Updated on stage transitions.\n\n| `$PS1`\n| `$USER@argus:$PWD $`\n| Prompt format string. Evaluated by Shell for each prompt render.\n|===\n\n=== Builtin Commands\n\n[cols=\"1,2,2\"]\n|===\n| Command | Usage | Behavior\n\n| `cd`\n| `cd [path]`\n| Change directory. No args = `cd $HOME`. Calls `vfs.cwd_set()`.\n\n| `pwd`\n| `pwd`\n| Print working directory. Reads `$PWD`.\n\n| `ls`\n| `ls [path]`\n| List directory contents. Defaults to `$PWD`. Colorized output (folders in blue, executables in green).\n\n| `cat`\n| `cat <file>`\n| Print file content. Calls `vfs.node_read()`.\n\n| `mkdir`\n| `mkdir [-p] <path>`\n| Create directory. `-p` creates intermediate directories.\n\n| `touch`\n| `touch <file>`\n| Create empty file or update timestamp.\n\n| `rm`\n| `rm [-r] <path>`\n| Remove file or directory. `-r` for recursive.\n\n| `cp`\n| `cp <src> <dest>`\n| Copy file or directory.\n\n| `mv`\n| `mv <src> <dest>`\n| Move or rename file or directory.\n\n| `echo`\n| `echo [text...]`\n| Print text to stdout. Supports `$VARIABLE` expansion.\n\n| `env`\n| `env`\n| Print all environment variables.\n\n| `export`\n| `export KEY=VALUE`\n| Set an environment variable.\n\n| `whoami`\n| `whoami`\n| Print `$USER`.\n\n| `date`\n| `date`\n| Print current date and time.\n\n| `clear`\n| `clear`\n| Clear terminal output buffer.\n\n| `help`\n| `help`\n| List available commands with descriptions.\n\n| `history`\n| `history`\n| Show command history.\n|===\n\n=== Prompt Generation\n\nThe Shell owns prompt generation. The prompt is computed by evaluating the `$PS1` format string against the current environment. This replaces all hardcoded `terminal.setPrompt()` calls throughout the codebase.\n\n[source,typescript]\n----\n// $PS1 = '$USER@argus:$PWD $ '\n// After cd /home/user/src/project:\n// Rendered: 'user@argus:~/src/project $ '\n----\n\nThe `~` substitution is cosmetic: if `$PWD` starts with `$HOME`, the Shell replaces that prefix with `~` in the rendered prompt.\n\n=== Stage Transitions\n\nWhen the application transitions between SeaGaP stages, the Shell receives a `stage_enter` call:\n\n[source,typescript]\n----\nshell.stage_enter('process');\n// 1. Sets $STAGE = 'process'\n// 2. cd to the persona's landing directory for that stage\n// 3. Prompt auto-updates via $PS1 evaluation\n----\n\nThis replaces the current pattern of hardcoded `terminal.setPrompt()` and `consoleEl.classList.add('open')` in the stage-change listener.\n\n== Content System\n\n=== ContentRegistry\n\nThe ContentRegistry maps file paths (or path patterns) to content generators. When the VFS needs to read a file whose `content` is null, it consults the ContentRegistry.\n\n[source,typescript]\n----\ninterface ContentGenerator {\n    pattern: string | RegExp;        // Path match (e.g., '~/src/project/train.py')\n    generate: (context: ContentContext) => string;\n}\n\ninterface ContentContext {\n    filePath: string;\n    persona: string;\n    selectedDatasets: Dataset[];\n    activeProject: Project | null;\n    installedAssets: string[];\n}\n----\n\n=== Templates\n\nTemplates are pure functions that generate file content strings. They live in `src/vfs/content/templates/`.\n\n[cols=\"1,2\"]\n|===\n| Template | Generates\n\n| `train.ts`\n| `train.py` — Python federated training script. Adapts to selected datasets (imports, data paths, model architecture).\n\n| `readme.ts`\n| `README.md` — Project documentation. Lists datasets, topology, privacy settings.\n\n| `config.ts`\n| `config.yaml` — Training configuration. Epochs, learning rate, aggregation strategy.\n\n| `requirements.ts`\n| `requirements.txt` — Python dependencies.\n\n| `manifest.ts`\n| `.meridian/manifest.json` — MERIDIAN federation manifest with node assignments.\n\n| `catalog.ts`\n| `/data/catalog/datasets.json` and `models.json` — Serialized catalog from `core/data/`.\n\n| `nodeRegistry.ts`\n| `/etc/atlas/nodes.json` — Serialized Trusted Domain registry from `core/data/nodes.ts`.\n|===\n\n=== Lazy Content Generation\n\nContent is generated lazily on first `node_read()`. This avoids generating content for files the user never opens. Once generated, content is cached on the `FileNode.content` field and served directly on subsequent reads.\n\nIf the application state changes (e.g., a new dataset is selected), Providers can call `node_invalidate(path)` to clear cached content, forcing regeneration on the next read.\n\n== Providers\n\nProviders are responsible for translating application domain objects into filesystem trees. They are the bridge between the ARGUS application state and the VCS filesystem.\n\n=== DatasetProvider\n\nPopulates `~/data/cohort/` from the selected datasets.\n\n**Triggered by:** `DATASET_SELECTION_CHANGED` event (during Gather stage).\n\n**Behavior:**\n\n1. Unmounts the existing `~/data/cohort/` tree (if any).\n2. For each selected dataset, creates:\n+\n----\n~/data/cohort/\n└── <institution>/           # e.g., BCH, MGH, BIDMC\n    ├── images/\n    │   ├── img_0001.dcm\n    │   ├── img_0002.dcm\n    │   └── ...\n    ├── masks/\n    │   ├── mask_0001.png\n    │   └── ...\n    ├── annotations.json\n    └── manifest.json        # Dataset metadata (id, modality, cost, provenance)\n----\n3. Each file has a `contentGenerator` registered for on-demand content (e.g., DICOM header summaries for `.dcm` files, annotation schema for `.json` files).\n4. Mounts the tree at `~/data/cohort/`.\n5. Creates `~/data/cohort/manifest.json` with aggregated cohort metadata (total cost, dataset IDs, provenance chain).\n\n=== ProjectProvider\n\nPopulates `~/src/project/` and scaffolds the home directory structure.\n\n**Triggered by:** Login (scaffolding) and stage transitions (project population).\n\n**Behavior at login:**\n\n1. Creates `$HOME` and all well-known subdirectories.\n2. Creates `~/.config/argus.yaml` with default preferences.\n3. Calls `shell.cwd_set()` to the persona's landing directory.\n\n**Behavior at Process stage entry:**\n\n1. Populates `~/src/project/` with:\n+\n----\n~/src/project/\n├── train.py              # contentGenerator: train template\n├── config.yaml           # contentGenerator: config template\n├── requirements.txt      # contentGenerator: requirements template\n├── README.md             # contentGenerator: readme template\n└── .meridian/\n    └── manifest.json     # contentGenerator: meridian manifest template\n----\n2. All files use lazy content generation via the ContentRegistry.\n\n=== MarketplaceProvider\n\nInstalls marketplace assets into the appropriate system paths.\n\n**Triggered by:** `store.asset_install(assetId)`.\n\n**Behavior by asset type:**\n\n[cols=\"1,2,2\"]\n|===\n| Asset Type | Install Path | Content\n\n| Plugin\n| `/bin/<plugin-name>`\n| Executable stub with name, version, description, usage instructions, dependencies.\n\n| Dataset\n| `/data/sets/<dataset-name>/manifest.json`\n| Dataset metadata, sample count, modality, license.\n\n| Model\n| `~/models/<model-name>/README.md`\n| Model card with architecture, training data, metrics, usage.\n\n| Annotation Tool\n| `/data/annotations/<tool-name>/manifest.json`\n| Tool metadata, supported formats, label schema.\n\n| FDA Tool\n| `/bin/<tool-name>` + `/data/annotations/<tool-name>/`\n| Both executable and data components.\n|===\n\n== Integration Points\n\n=== VCS ↔ Store\n\nThe VCS is stored as a global singleton on `store.globals.vcs` (replacing the current `store.globals.vfs`). The Store does not reach into the VCS; it emits events that Providers listen to.\n\n[cols=\"1,2\"]\n|===\n| Store Event | VCS Response\n\n| `STAGE_CHANGED`\n| Shell calls `stage_enter()` — updates `$STAGE`, `cd`s to landing directory.\n\n| `DATASET_SELECTION_CHANGED`\n| DatasetProvider rebuilds `~/data/cohort/`.\n\n| `PROJECT_LOADED`\n| ProjectProvider scaffolds `~/src/project/`.\n\n| `STATE_CHANGED` (marketplace install)\n| MarketplaceProvider installs asset to appropriate path.\n|===\n\n=== VCS ↔ Terminal\n\nThe Terminal sends raw input strings to `shell.command_execute(line)` and receives `ShellResult` objects. The Terminal is responsible only for:\n\n- Rendering `stdout` (default color) and `stderr` (error color)\n- Displaying the prompt (from `shell.prompt_render()`)\n- Managing input focus, history navigation (arrow keys), and tab completion\n\nThe Terminal no longer registers individual commands. All command registration moves to the Shell.\n\n=== VCS ↔ IDE (Process Stage)\n\nThe IDE code viewer calls `vfs.node_read(path)` to display file content. When the user selects a file in the project explorer, the IDE reads its content from the VFS — not from a hardcoded template.\n\nThe project explorer tree is built by calling `vfs.dir_list('~/src/project/')` recursively.\n\n=== VCS ↔ Marketplace\n\n`assetDetail_install()` in `marketplace/view.ts` calls `store.asset_install(id)`. The Store emits `STATE_CHANGED`. The `MarketplaceProvider` listens and writes the asset into the VFS at the appropriate system path.\n\n== Source Structure\n\n----\nsrc/\n└── vfs/\n    ├── VirtualFileSystem.ts      # Core: tree + content + CWD + events\n    ├── Shell.ts                  # Command interpreter + env vars + prompt\n    ├── types.ts                  # FileNode, ShellResult, ContentContext, etc.\n    │\n    ├── content/\n    │   ├── ContentRegistry.ts    # Path → generator mapping + lazy evaluation\n    │   └── templates/\n    │       ├── train.ts          # train.py generator\n    │       ├── readme.ts         # README.md generator\n    │       ├── config.ts         # config.yaml generator\n    │       ├── requirements.ts   # requirements.txt generator\n    │       ├── manifest.ts       # .meridian/manifest.json generator\n    │       ├── catalog.ts        # /data/catalog/*.json generators\n    │       └── nodeRegistry.ts   # /etc/atlas/nodes.json generator\n    │\n    └── providers/\n        ├── DatasetProvider.ts    # Builds ~/data/cohort/ from selected datasets\n        ├── ProjectProvider.ts    # Scaffolds $HOME + populates ~/src/project/\n        └── MarketplaceProvider.ts # Installs assets to /bin, /data/sets, etc.\n----\n\n== Migration Path\n\n=== Files to Retire\n\n[cols=\"1,2\"]\n|===\n| Current File | Replaced By\n\n| `src/core/logic/vfs.ts`\n| `src/vfs/VirtualFileSystem.ts` — complete rewrite with content support.\n\n| `src/core/logic/filesystem.ts`\n| `src/vfs/providers/DatasetProvider.ts` — the `filesystem_create()` function moves into the provider.\n\n| Hardcoded `train.py` HTML in `src/core/stages/process.ts:117-141`\n| `src/vfs/content/templates/train.ts` — generates plain text, not HTML.\n\n| Hardcoded `README.md` HTML in `src/core/stages/process.ts:143-155`\n| `src/vfs/content/templates/readme.ts`.\n\n| `terminal.setPrompt()` calls in `src/argus.ts:497-514`\n| `shell.stage_enter()` + `$PS1` evaluation.\n\n| Command registration in `src/ui/components/Terminal.ts:36-117`\n| `src/vfs/Shell.ts` — all builtins move to the Shell.\n\n| `store.globals.vfs`\n| `store.globals.vcs` — rename to reflect the expanded scope.\n|===\n\n=== Files to Modify\n\n[cols=\"1,2\"]\n|===\n| File | Changes\n\n| `src/core/state/store.ts`\n| Replace `globals.vfs` with `globals.vcs`. Add `VFS_CHANGED` and `CWD_CHANGED` events.\n\n| `src/core/state/events.ts`\n| Add new event types for VFS and CWD changes.\n\n| `src/argus.ts`\n| Initialize VCS instead of VFS. Wire Shell to Terminal. Remove hardcoded prompt/stage logic.\n\n| `src/ui/components/Terminal.ts`\n| Simplify to I/O surface. Remove command registration. Delegate to Shell.\n\n| `src/lcars-framework/ui/Terminal.ts`\n| Remove command map. Add `shell` integration point.\n\n| `src/core/stages/gather.ts`\n| Replace `filesystem_build()` with DatasetProvider call.\n\n| `src/core/stages/process.ts`\n| Replace `populate_ide()` with VFS reads. Remove hardcoded file content.\n\n| `src/marketplace/view.ts`\n| Replace `store.asset_install()` inline VFS touch with MarketplaceProvider call.\n|===\n\n== Implementation Status\n\nThis section is a living checklist. Update it with each implementation iteration.\n\n=== Phase 1: Core VFS (Complete)\n\n[cols=\"1,1,2\"]\n|===\n| Item | Status | Notes\n\n| `src/vfs/types.ts`\n| [x] Done\n| FileNode with content, ShellResult, ContentContext, VfsChangeEvent, CwdChangeEvent.\n\n| `src/vfs/VirtualFileSystem.ts`\n| [x] Done\n| Full rewrite. Tree, content, CWD, path resolution (~, .., relative), lazy content generation, events via EventBus. `legacyNode_normalize()` bridge removed in Phase 4.\n\n| VCS events in EventBus\n| [x] Done\n| Added `VFS_CHANGED` and `CWD_CHANGED` to `src/core/state/events.ts`.\n\n| Unit tests for VFS\n| [x] Done\n| 64 tests covering path resolution, CWD, dir/file CRUD, node read/write/copy/move/remove, mount/unmount, lazy content generation, invalidation, and event emission.\n\n| Retire `src/core/logic/vfs.ts`\n| [x] Done\n| Old VFS class deleted. All consumers migrated to new API: `store.ts`, `Terminal.ts`, `search.ts`, `gather.ts`, `process.ts`, `argus.ts`. Legacy FileNode trees bridge via `legacyNode_normalize()`.\n|===\n\n=== Phase 2: Shell (Complete)\n\n[cols=\"1,1,2\"]\n|===\n| Item | Status | Notes\n\n| `src/vfs/Shell.ts`\n| [x] Done\n| 15 builtins (cd, pwd, ls, cat, mkdir, touch, rm, cp, mv, echo, env, export, whoami, date, history, help), env vars ($HOME, $USER, $PWD, $PATH, $PERSONA, $STAGE, $PS1), prompt generation with ~ substitution, stage transitions with landing directories, external handler delegation.\n\n| Wire Shell to Terminal\n| [x] Done\n| Terminal delegates all input to Shell via `onUnhandledCommand`. Shell exit code 127 falls through to async fallback handler (AI/workflow commands). `shell_connect()` + `fallback_set()` APIs. Shell created in `argus.ts`, stored in `globals.shell`.\n\n| Remove command registration from Terminal.ts\n| [x] Done\n| All filesystem commands moved to Shell builtins. Terminal only registers `clear` (DOM access) and overrides base `help` to delegate to Shell. AI/workflow commands (search, add, review, mount, simulate, LLM fallback) handled via fallback handler.\n\n| Unit tests for Shell\n| [x] Done\n| 51 tests covering env vars, prompt generation, command parsing, all 15 builtins, stage transitions, external handler delegation. 124 total tests passing.\n\n| Stage-change listener updated\n| [x] Done\n| `argus.ts` stage listener calls `shell.stage_enter()` for CWD/env updates. Process/default stages use Shell $PS1 via `prompt_sync()`. Search/gather retain command-console prompts.\n|===\n\n=== Phase 3: Content System (Complete)\n\n[cols=\"1,1,2\"]\n|===\n| Item | Status | Notes\n\n| `src/vfs/content/ContentRegistry.ts`\n| [x] Done\n| Path-to-generator mapping with lazy evaluation. `generator_register()`, `generators_registerAll()`, `vfs_connect()`, `content_resolve()`. Builds `ContentContext` from live application state.\n\n| `src/vfs/content/templates/*.ts`\n| [x] Done\n| 8 generators: train (Python script adapts to datasets/modality), readme (Markdown with topology), config (YAML training config), requirements (pip deps), manifest (MERIDIAN JSON), catalog-datasets (serialized DATASETS), catalog-models (model architectures), node-registry (Trusted Domain nodes).\n\n| IDE integration\n| [x] Done\n| `ide_openFile()` in process.ts now reads from VFS via `node_read()`, triggering lazy content generation. Added `syntax_highlight()` for .py, .yaml, .json, .md, .txt with semantic CSS classes. Removed all hardcoded HTML templates.\n\n| Unit tests\n| [x] Done\n| 16 tests covering registration, resolution, VFS integration (lazy gen + caching), and all 8 template generators. 140 total tests passing.\n\n| Wiring\n| [x] Done\n| `ContentRegistry` created in `argus.ts`, all generators registered via `ALL_GENERATORS`, connected to VFS before Shell init.\n|===\n\n=== Phase 4: Providers (Complete)\n\n[cols=\"1,1,2\"]\n|===\n| Item | Status | Notes\n\n| `src/vfs/providers/ProjectProvider.ts`\n| [x] Done\n| `homeDir_scaffold()` creates ~/bin, ~/data, ~/src, /etc/atlas, /bin, /tmp, config files with content generators. `projectDir_populate()` creates ~/src/project/ with train, config, requirements, readme, manifest generators.\n\n| `src/vfs/providers/DatasetProvider.ts`\n| [x] Done\n| `cohortTree_build()` replaces `filesystem_create()`. Builds VCS FileNode trees directly with proper provider codes, image/mask nodes, validation dirs. Helper functions: `datasetDir_build()`, `imageNodes_build()`, `maskNodes_build()`, `validationDir_build()`, `node_file()`.\n\n| `src/vfs/providers/MarketplaceProvider.ts`\n| [x] Done\n| `asset_install()` dispatches to type-specific installers (plugin, dataset, model, annotation, fda, workflow). Each creates dirs, files, metadata, and content generator keys. 6 new asset manifest generators added.\n\n| Retire `src/core/logic/filesystem.ts`\n| [x] Done\n| Deleted `filesystem.ts` and `filesystem.test.ts`. Removed `legacyNode_normalize()` from `VirtualFileSystem.ts`. All consumers migrated to providers.\n\n| Template expansion\n| [x] Done\n| 6 new generators: `argus-config`, `plugin-executable`, `dataset-manifest`, `model-readme`, `annotation-manifest`, `workflow-manifest`, `cohort-manifest`. Total: 14 generators registered.\n\n| Store + Stage wiring\n| [x] Done\n| `store.asset_install()` calls `asset_install()` via MarketplaceProvider. `gather.ts` and `search.ts` use `cohortTree_build()`. `argus.ts` calls `homeDir_scaffold()` at init and `projectDir_populate()` on process stage entry.\n|===\n\n=== Phase 5: Integration (Complete)\n\n[cols=\"1,1,2\"]\n|===\n| Item | Status | Notes\n\n| Store migration (`vfs` → `vcs`)\n| [x] Done\n| Renamed `globals.vfs` → `globals.vcs` in store definition and all 7 consumer files. Property key in Store.globals renamed.\n\n| Stage transition integration\n| [x] Done\n| `shell.stage_enter()` already wired in Phase 2. Unified all stages to use `prompt_sync()` after stage_enter. Removed redundant `updatePrompt()` call from navigation.ts (method didn't exist on Terminal).\n\n| Marketplace integration\n| [x] Done\n| `store.asset_install()` delegates to `asset_install()` via MarketplaceProvider (wired in Phase 4). Marketplace view (`view.ts`) has no inline VFS calls — clean separation.\n\n| Remove all hardcoded `setPrompt()` calls\n| [x] Done\n| Removed `terminal.setPrompt('ARGUS: SEARCH >')` and `terminal.setPrompt('ARGUS: COHORT >')` from argus.ts stage-change listener. All stages now use `terminal.prompt_sync()` which reads Shell's `$PS1`. Shell is sole prompt authority.\n|===\n\n== Changelog\n\n[cols=\"1,1,3\"]\n|===\n| Date | Version | Changes\n\n| 2026-01-28\n| 0.1.0\n| Initial specification. Defines architecture, filesystem layout, APIs, providers, migration path, and implementation phases.\n\n| 2026-01-28\n| 0.2.0\n| Phase 1 complete: `types.ts`, `VirtualFileSystem.ts`, VCS events in EventBus, 64 unit tests, old VFS retired. All consumers migrated. Legacy bridge `legacyNode_normalize()` added for filesystem.ts compatibility.\n\n| 2026-01-28\n| 0.3.0\n| Phase 2 complete: `Shell.ts` with 15 builtins, env vars, $PS1 prompt generation, stage transitions, external handler delegation. Terminal rewritten as dumb I/O surface with Shell → fallback handler chain. 51 Shell tests (124 total). Shell wired into `argus.ts` via `globals.shell`. Stage listener updated to use `shell.stage_enter()`.\n\n| 2026-01-28\n| 0.4.0\n| Phase 3 complete: `ContentRegistry.ts` with lazy evaluation and VFS integration. 8 template generators (train, readme, config, requirements, manifest, catalog-datasets, catalog-models, node-registry). IDE reads from VFS with `syntax_highlight()` for .py/.yaml/.json/.md/.txt. Hardcoded HTML templates removed from process.ts. 16 content tests (140 total).\n\n| 2026-01-29\n| 0.5.0\n| Phase 4 complete: Three providers created — `DatasetProvider.ts` (`cohortTree_build()`), `ProjectProvider.ts` (`homeDir_scaffold()`, `projectDir_populate()`), `MarketplaceProvider.ts` (`asset_install()` with 6 type-specific installers). 6 new asset manifest generators + `argusConfig` generator (14 total). Store, gather, search, argus.ts migrated to providers. Legacy `filesystem.ts` and `filesystem.test.ts` deleted. `legacyNode_normalize()` removed from VirtualFileSystem.ts. 134 tests.\n\n| 2026-01-29\n| 0.6.0\n| Phase 5 complete: `globals.vfs` renamed to `globals.vcs` across store and all 7 consumers. Hardcoded `setPrompt()` calls removed from search/gather stages — Shell `$PS1` via `prompt_sync()` is sole prompt authority. Dead `updatePrompt()` call removed from navigation.ts. Marketplace integration verified clean (no inline VFS calls). All 5 phases complete. 134 tests.\n\n| 2026-01-29\n| 0.7.0\n| Style guide compliance sweep. All VCS/Provider/Store code now uses RPN naming (e.g., `store.asset_install()`, `detailHeader_populate()`), explicit type annotations on all consts/lambdas, JSDoc on all public/private functions, `catch (e: unknown)` with `instanceof Error` narrowing, and typed `declare global { interface Window }` extensions replacing `(window as any)` casts. Typed filter lambda parameters throughout VirtualFileSystem.ts and Shell.ts. 134 tests passing.\n|===",
    "visual_language.adoc": "= ARGUS: Visual Language Specification\n:author: ATLAS Project Team\n:revdate: 2026-01-30\n:toc:\n:sectnums:\n\n== Introduction\n\nARGUS draws its visual identity from Star Trek's LCARS (Library Computer Access/Retrieval System), designed by Michael Okuda for The Next Generation. Where LCARS was created for television cameras, ARGUS adapts its design language for responsive, interactive web use. This document codifies the motion and layout patterns that give ARGUS its cinematic, mechanical feel.\n\nThe visual language is built on a central metaphor: ARGUS is a physical console. Frames are structural members that separate and rejoin. Content panels are equipment trays that slide into exposed bays. Nothing simply appears or disappears -- everything moves with deliberate, mechanical purpose.\n\n== Core Structural Elements\n\n=== The LCARS Frame\n\nBar panels form the structural skeleton of the interface. The primary frame consists of two horizontal bar rows (bars 1-5 at top, bars 6-10 at bottom) connected by a vertical left sidebar. These bars are not decorative chrome -- they are load-bearing members that define content regions and, critically, can separate to expose functional surfaces beneath them.\n\nThe frame uses rounded \"elbows\" at connection points between horizontal and vertical members, achieved through a combination of `border-radius` and pseudo-element geometry. These curves are the most recognizable LCARS signature and must be preserved at all viewport sizes.\n\n=== The Content Region\n\nThe area enclosed by bars and sidebar is the active workspace. Content within this region changes based on the current SeaGaP-MP stage. The region scrolls vertically but never horizontally.\n\n=== The Slot\n\nWhen bars separate, the space between them becomes a slot -- a bay into which content panels can be inserted. The Intelligence Console occupies the primary slot between the lower bar panel and the main content area. The slot concept is generalizable: any region where frame members can part to accept a content panel is a slot.\n\n== Animation Patterns\n\nARGUS uses three distinct animation patterns, each appropriate to different interaction contexts. All animations use the same easing curve (`cubic-bezier(0.4, 0, 0.2, 1)`) for visual consistency.\n\n=== Pattern 1: Frame Separation\n\nFrame members move apart to create space. This is a vertical height transition where a collapsed region expands to a target height.\n\n[cols=\"1,3\"]\n|===\n| Duration | 600ms (`--frame-transition-duration`)\n| Easing | `cubic-bezier(0.4, 0, 0.2, 1)` (`--lcars-easing`)\n| CSS mechanism | `transition: height` on the slot container\n| Trigger | Class toggle (`.open`)\n| Used by | Intelligence Console frame, terminal drawer\n|===\n\nFrame Separation alone does not introduce content. It exposes empty space -- a bay waiting to receive a panel. When used in isolation, the frame region would contain static content already present in the DOM that is revealed by the expansion.\n\n=== Pattern 2: Slide-In Overlay\n\nA full-surface overlay enters from the right edge of the viewport and covers the content region entirely. This is used for modal or near-modal experiences that temporarily replace the active workspace.\n\n[cols=\"1,3\"]\n|===\n| Duration | 400ms (`--slide-transition-duration`)\n| Easing | `cubic-bezier(0.4, 0, 0.2, 1)` (`--lcars-easing`)\n| CSS mechanism | `@keyframes` with `translateX(100%)` to `translateX(0)`\n| Trigger | State change via Store (`marketplaceOpen`)\n| Close | Reverse animation via `.closing` class, then `display: none` on `animationend`\n| Used by | Marketplace overlay, Asset detail overlay\n|===\n\nThe slide-in overlay implies a separate system or context. The marketplace is not part of the SeaGaP workflow -- it is an adjacent resource. The rightward origin reinforces this: it arrives from outside the console's workspace.\n\n=== Pattern 3: Frame-then-Slide (The Double Whammy)\n\nThis is the signature ARGUS interaction pattern, combining Frame Separation with a content slide-in to create a two-phase mechanical animation:\n\n==== Opening Sequence\n\n. **Phase 1 -- Frame Separation** (600ms): The slot container expands vertically. Bar panels move apart. The bay is now exposed but empty.\n. **Phase 2 -- Content Slide-In** (400ms): After the frame finishes expanding, the content panel slides in from the right edge of the slot, filling the bay.\n\nTotal opening time: ~1000ms. The sequential phasing is intentional for the opening -- the user should perceive two distinct mechanical actions: \"bay opens\" then \"equipment slides in.\"\n\n==== Closing Sequence\n\n. **Simultaneous**: The content panel begins sliding out to the right AND the frame begins collapsing at the same time. Both animations run in parallel.\n\nTotal closing time: ~600ms. The overlapped closing is intentional -- closing should feel snappier than opening. The visual effect is the content being retracted as the bay shuts, like a drawer closing with its tray still retracting.\n\n==== Timing Constants\n\n[cols=\"2,1,1\"]\n|===\n| Constant | Value | CSS Variable\n| Frame transition duration | 600ms | `--frame-transition-duration`\n| Slide transition duration | 400ms | `--slide-transition-duration`\n| Easing curve | cubic-bezier(0.4, 0, 0.2, 1) | `--lcars-easing`\n|===\n\n==== Used By\n\n* Intelligence Console (terminal)\n* Future: any panel that occupies a frame slot (diagnostics, settings, inline help)\n\n== The Frame Slot System\n\nThe Frame-then-Slide pattern is implemented as a composable system with two components:\n\n=== SlidePanel\n\nA reusable primitive that manages the slide-in and slide-out animation of a single DOM element. The SlidePanel knows nothing about frames or slots -- it only knows how to move its content element horizontally using CSS transitions.\n\nThe SlidePanel applies the `.frame-slot-panel` CSS class to its managed element. This class sets the initial state (`translateX(100%)`, `opacity: 0`) and defines the transition properties. The `.active` class triggers the slide-in; the `.exiting` class triggers the slide-out.\n\nCSS transitions are used rather than `@keyframes` animations because transitions can be interrupted and reversed mid-animation. This is essential for the draggable access strip, which allows users to manually resize the terminal bay.\n\n=== FrameSlot\n\nAn orchestrator that coordinates the two-phase sequence by combining a frame element (the expandable container) with a SlidePanel (the sliding content). The FrameSlot manages the timing between phases and provides guards against rapid-fire toggling that could leave the animation in a broken state.\n\nThe FrameSlot is the integration point. To add a new pluggable panel to a frame slot in the future, one creates a new SlidePanel instance and registers it with the FrameSlot. The frame expansion logic remains unchanged -- only the content that slides in differs.\n\n== Design Rationale\n\n=== Why Two Phases on Open?\n\nA single combined animation (frame expands while content slides) would be faster but would read as a single event. Two distinct phases create a narrative: something mechanical happened (the bay opened), and then something was delivered (the panel arrived). This maps to the physical console metaphor and gives the user's attention two anchor points rather than one.\n\n=== Why Overlap on Close?\n\nOpening is a reveal -- it deserves ceremony. Closing is a dismissal -- it should be efficient. Users who close a panel want it gone; making them wait through a sequential reverse animation creates frustration. The overlapped close respects the user's intent to dismiss while still maintaining visual coherence.\n\n=== Why Slide from the Right?\n\nThe left edge of the ARGUS interface is occupied by the LCARS sidebar -- a fixed structural member. Content entering from the right implies arrival from outside the current context, which is semantically correct for both the marketplace (an external registry) and the terminal (a system-level tool that exists below the application surface). The rightward origin also follows natural left-to-right reading flow: the workspace is read first, then the arriving panel draws attention as it enters the visual field.\n\n== Pattern Selection Guide\n\n[cols=\"2,3,2\"]\n|===\n| Scenario | Pattern | Rationale\n\n\n| System tool appearing within the console frame\n| Frame-then-Slide\n| Mechanical feel; tool is \"inserted\" into the console\n\n| External resource browser or modal overlay\n| Slide-In Overlay\n| Full takeover; content is from outside the workflow\n\n| Revealing static content within the layout\n| Frame Separation only\n| No new content arrives; existing content is exposed\n\n| Future: swapping one tool for another in an open bay\n| Slide-out then Slide-in (no frame animation)\n| Bay is already open; only the content changes\n|===\n\n== Visual Convergence: Asset Tiles and Project Tiles\n\nTo maintain a consistent visual language across the platform, ARGUS uses a unified tile-based metaphor for all addressable resources, whether they are external (Marketplace Assets) or internal (User Projects).\n\n=== The Asset Card Pattern\n\nThe `AssetCard` component codifies the established LCARS \"tile\" aesthetic. It features:\n* **The Header Badge**: Top-left identification of the resource type (e.g., \"PLUGIN\", \"PROJECT\").\n* **The Semantic Color Code**: Orange for algorithms/scripts, Honey for data/projects, Sky for core systems.\n* **Metadata Alignment**: Primary stats (stars, dataset counts) on the right, authorship/origin on the bottom-left.\n* **The Mechanical Action**: A primary action button (INSTALL, SELECT) integrated into the card's baseline.\n\n=== Interaction Parity: Preview Before Commitment\n\nConsistent with the Marketplace interaction model, User Projects now feature a **Detail Preview** phase. Clicking a project tile no longer triggers an immediate workspace load (commitment); instead, it opens a detail overlay providing a read-only preview of the project's source code and data cohort.\n\n=== The Workspace Layout\n\nAs of v4.3.0, opening a project from the detail preview activates a **workspace layout** that transforms the right-frame into a vertical stack of two independently-sized panels: the Intelligence Console (terminal) on top and a FileBrowser below.\n\nEach panel owns its own bottom-edge **resize handle** — an LCARS-styled 6px orange grip bar. Dragging a handle resizes only its associated panel. The panels are fully decoupled; the page scrolls to accommodate their combined height. This \"independent sizing\" model replaces the traditional split-pane approach (where resizing one panel shrinks the other) and aligns with the LCARS philosophy of modular, self-contained instrument panels.\n\nThe file browser tabs (SOURCE/DATA) and the terminal working directory maintain bidirectional sync: clicking a tab changes the terminal's cwd, and typing `cd` in the terminal switches the active tab."
};
