= Federation Workflow: Plugin-Materialized Phase Execution
:author: ATLAS Project Team
:revdate: 2026-02-20
:revnumber: 10.3.0
:toc: macro
:toclevels: 4
:sectnums:

toc::[]

== Abstract

This document specifies federation behavior after the backend purification passes
in the late v10 line. Federation is no longer represented by a backend
orchestrator, hidden handshake controller, or dedicated in-memory federation state.
It is represented by manifest topology plus stage-local plugin compute, with
progress derived from artifacts and DAG position resolution.

The practical consequence is a stronger Host/Guest contract. Federation sequencing
remains explicit and auditable, while backend layers remain workflow-agnostic and
ready for storage substrate changes.

== Historical Catalyst

Earlier implementations retained internalized federation coordination in runtime
code. That transitional design was useful during migration, but it violated the
declared v10 architecture because orchestration semantics existed in two places:
partly in manifests/plugins and partly in backend logic. The duplication created
drift risk and made it difficult to claim that plugin boundaries were fully real.

The hardening objective was to remove this duality before v11 contract lock. If a
federation phase existed, it needed to exist as a plugin module selected by a
manifest handler, not as a backend branch.

== Federation Spine Figure

[source,text]
----
┌──────────────────────────┐
│ FEDERATE BRIEF           │
└────────────┬─────────────┘
             ▼
┌──────────────────────────┐
│ FEDERATE TRANSCOMPILE    │
└────────────┬─────────────┘
             ▼
┌──────────────────────────┐
│ FEDERATE CONTAINERIZE    │
└────────────┬─────────────┘
             ▼
┌──────────────────────────┐
│ FEDERATE PUBLISH CONFIG  │
└────────────┬─────────────┘
             ▼
┌──────────────────────────┐
│ FEDERATE PUBLISH EXEC    │
└────────────┬─────────────┘
             ▼
┌──────────────────────────┐
│ FEDERATE DISPATCH        │
└────────────┬─────────────┘
             ▼
┌──────────────────────────┐
│ FEDERATE EXECUTE         │
└────────────┬─────────────┘
             ▼
┌──────────────────────────┐
│ FEDERATE MODEL PUBLISH   │
└──────────────────────────┘
----

== Stage Pipeline as Declared Compute

The active FedML lineage now materializes federation as eight stage handlers:
`federate-brief`, `federate-transcompile`, `federate-containerize`,
`federate-publish-config`, `federate-publish-execute`, `federate-dispatch`,
`federate-execute`, and `federate-model-publish`. Each stage is implemented as a
single plugin file in `src/plugins/` and loaded through standard host handler
resolution. Shared helper logic exists in `src/plugins/federationShared.ts`,
without reintroducing backend orchestration ownership.

Because each phase is now regular stage compute, federation behavior is governed by
the same contracts used by all other workflow stages: typed context input,
status-coded plugin result, and host-controlled Merkle materialization.

== Persistence and State Semantics

Federation progress is reconstructed from artifacts and workflow position.
Dedicated store-level `federationState` has been removed. Publication configuration
persists in project scope via `.federation-config.json`, making it portable with
the project and inspectable under normal filesystem tooling.

This model avoids controller-side shadow state and ensures compatibility with
future host backends where project data may live on real filesystems instead of
in-memory simulation.

== Command Contract

Legacy shortcut surfaces that encoded implicit approvals, such as
`federate --yes`, are no longer part of the federation contract. Advancement is
expressed through explicit stage commands declared in manifest context and resolved
through normal workflow dispatch. Structured scripts follow the same policy:
federation automation uses explicit command steps, not backend translation tables.

== Architectural Outcome

Federation is now an instance of the general ARGUS runtime model, not an exception
to it. Manifests declare the sequence, plugins execute compute, and the host
anchors results. This closes a key transitional debt surface and aligns federation
execution with the production-pure backend doctrine established in v10.2 and v10.3.

---
_Last updated: 2026-02-20 (v10.3.0)_
