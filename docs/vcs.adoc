= Virtual Computer System (VCS): The Substrate of Deterministic Truth
:author: ATLAS Project Team
:revdate: 2026-02-17
:revnumber: 10.0.0
:toc: macro
:toclevels: 4
:sectnums:

toc::[]

== Abstract

The Virtual Computer System (VCS) is the foundational state substrate of the ARGUS environment. It provides a high-fidelity, in-memory simulation of a POSIX-compliant computer system within the web browser or a headless Node.js process. This document serves as the formal specification for the VCS, detailing the architectural design of the Virtual File System (VFS), the Shell execution environment, and the Content Registry. By providing a deterministic "Ground Truth" that is independent of AI-mediated assertions, the VCS functions as the primary mechanism for agentic safety and procedural verification in federated medical research.

== Introduction: The Case for a virtualized Substrate

=== The "Truth Gap" in Agentic Systems
The development of the VCS was a direct response to the "Truth Gap"—the structural disconnect between an AI's conversational claims and the actual state of the system it purports to control. In legacy iterations of ARGUS (v9.0 and below), project state was managed through high-level TypeScript objects. This approach proved fragile when subjected to the non-deterministic output of LLMs. An agent could "believe" it had successfully performed a complex data mutation simply because it generated the correct descriptive text, even if the underlying API call failed or the system state drifted.

=== The Resolution: POSIX-Compliant Grounding
We learned that for an AI agent to operate safely in a high-stakes environment like medical imaging, it must be embedded in an environment that behaves according to known, immutable rules. The resolution was the implementation of a full-stack virtualized computer system. The VCS provides a "Physical Grounding" for every action. If a plugin claims to have harmonized a cohort, that success is only recognized if a physical `.harmonized` marker is materialized on the virtual disk. This shift from "Assertion-Based State" to "Materialized-File State" is the fundamental engineering move that enables ARGUS to achieve v10.0 integrity levels.

== The Virtual File System (VFS): The Ledger of State

The `VirtualFileSystem` class is the primary ledger of the ARGUS system. It implements a tree-based node model that strictly enforces POSIX-like semantics for all data-state transformations.

=== The Node Model and Metadata Integrity
The VFS is composed of a recursive tree of `FileNode` objects. Unlike a simple key-value store, each node in the VFS tracks metadata essential for procedural verification:
*   **Node Identity:** Each node has a unique `name`, a `type` (file, folder, or link), and a parent reference.
*   **POSIX Metadata:** Every node maintains `mode` (permissions), `mtime` (modification time), `atime` (access time), and `owner/group` identifiers. 
*   **Security Isolation:** The `mode` property is utilized to enforce access controls between different research personas. For example, a "clinician" persona may have read-only access to `/input/`, while the "developer" persona has full write access to `~/src/`.

=== Advanced Path Resolution and Symlinking
The VFS implements a sophisticated path resolution engine that supports absolute, relative, and homedir (`~/`) paths.
*   **CWD Mapping:** Each shell process maintains its own Current Working Directory (CWD). Path resolution is always performed relative to this CWD, ensuring that command execution (e.g., `ls ./data`) behaves identically to a physical Linux terminal.
*   **Virtual Mounting:** The system supports the dynamic mounting of external subtrees into the VFS. This is a critical feature for the `Gather` stage, where data from disparate federated sites is "mounted" into a unified project-scoped view (`/input/training/site-a/`) without actual data duplication.

=== Atomic VFS Operations
The `VirtualFileSystem` class exports over 30 atomic operations, including `node_write`, `node_read`, `node_move`, and `node_cloneDeep`. Every operation is a synchronous, deterministic mutation of the in-memory tree. Crucially, these operations emit `VFS_CHANGED` events, allowing UI components and the `MerkleEngine` to react in real-time to the system's evolving state.

== The Shell: The Contextual Execution Environment

The `Shell` class provides the process-level context and command interpretation layer for the VCS. It is the primary interface through which the Calypso Host and human operators interact with the filesystem.

=== Environment Variable Isolation
The Shell maintains a persistent environment bag ($USER, $HOME, $PWD, $PROJECT). This context is vital for multi-phase scientific workflows.
*   **Project Context:** The `$PROJECT` variable anchors all commands to a specific research workspace. This allows the same "Harmonize" plugin to be run across different projects without the risk of cross-project data contamination.
*   **Variable Interpolation:** The Shell supports recursive variable expansion (e.g., `cd /home/$USER/projects/$PROJECT`), providing a high-fidelity simulation of a developer's local environment.

=== The Builtin Library and Script Execution
The Shell contains a robust library of over 20 POSIX-simulating builtins.
*   **Standard Utilities:** Includes `cd`, `ls`, `mkdir`, `cp`, `mv`, `rm`, `cat`, and `echo`. Each builtin is implemented as a pure function that takes the current Shell context and returns a `ShellResult` (stdout, stderr, exitCode).
*   **The Python Simulator:** A specialized builtin designed to mimic a Python interpreter. When the user runs `python train.py`, the Shell does not invoke a real Python process. Instead, it parses the `train.py` file from the VFS, simulates the training logic, and materializes the expected validation artifacts (e.g., `.local_pass`). This allows for the "Phantom Federation" verification cycle required by the SeaGaP-MP workflow.

=== Redirection and Piping
The v10.0 Shell supports basic I/O redirection (e.g., `cat data.txt > log.txt`). This feature is utilized by plugins to capture execution logs into the project tree, ensuring that the "Evidence of Work" is preserved as a physical artifact for later audit.

== The Content Registry: Lazy Materialization

To support national-scale catalogs containing millions of virtual files, the VCS utilizes a **Content Provider** model managed by the `ContentRegistry`.

=== The Logic of Lazy Loading
Storing the full content of every virtual file (scaffolds, participants lists, Dockerfiles) in memory would be prohibitively expensive. Instead, the VCS stores a `contentGenerator` string—a unique identifier for a generator function.
*   **Materialization on Read:** When `node_read()` is invoked, the VFS checks if the file has a generator. If so, it invokes the registry to synthesize the content in real-time.
*   **Context-Aware Templates:** Generators are not static. They are "Smart Templates" that receive the current system context as input. For example, the `participants.json` generator queries the `Store` for the currently selected datasets and builds the JSON list dynamically.

=== Performance and Integrity
This approach ensures that the "Disk" always reflects the current application logic without consuming excessive RAM. Once a file is written to (mutated), the generator is detached, and the file becomes a static "snapshot," preserving the integrity of that specific version for the Merkle provenance chain.

== Conclusion

The VCS is the architectural bedrock of ARGUS. By virtualizing the entire execution environment—from the node-level file metadata to the process-level shell context—it provides the "Substrate of Truth" required for high-integrity federated research. The VCS ensures that "Truth" is never a conversational assertion, but a physical property of the virtualized environment. This grounding is what allows ARGUS to scale from a simple assistant to a verifiable, POSIX-compliant operating system for the ATLAS platform.

---
_Last updated: 2026-02-17 (v10.0.0)_
