= Manifest-Driven DAG Engine: Topology as Execution Truth
:author: ATLAS Project Team
:revdate: 2026-02-20
:revnumber: 10.3.0
:toc: macro
:toclevels: 4
:sectnums:

toc::[]

== Abstract

The DAG engine is the workflow conscience of ARGUS. It transforms declarative
manifest topology into deterministic execution constraints and resolves current
position from materialized evidence rather than conversational state. In this
model, progression is granted only when prerequisite artifacts exist and lineage
integrity remains valid under Merkle parentage.

This specification reflects the post-hardening state in which optional-parent JOIN
resolution is materialized as data evidence and command vocabulary is bound to
active manifest declarations.

== Historical Context

Early workflow logic used linear state progression and implicit controller rules.
That approach failed once workflows required branching, re-execution, and
multi-parent convergence. The immediate symptom was state drift, where runtime
position and filesystem evidence diverged. The deeper issue was representational:
control decisions were not encoded as artifacts.

The DAG transition corrected topology representation, and later hardening work
closed remaining semantic gaps by converting JOIN control into materialized
resolution evidence.

== Topology Figure

[source,text]
----
Main topology with optional JOIN:

┌────────────┐     ┌────────────┐
│ SEARCH     │───▶│ GATHER     │──────────────┐
└────────────┘     └────────────┘              │
                                               ▼
                                        ┌────────────┐
                                        │ JOIN GATE  │───▶┌────────────┐───▶┌────────────┐
                                        │ parents ok │    │ HARMONIZE  │    │ PROCEED    │
                                        └─────┬──────┘    └────────────┘    └────────────┘
                                              │
                             optional path    │
                                              ▼
                                        ┌────────────┐
                                        │ RENAME opt │
                                        └────────────┘

Re-execution pressure:

┌────────────┐
│ SEARCH     │ (new fingerprint)
└─────┬──────┘
      │
      └──────────────▶ downstream descendants marked [STALE]
----

== Manifest as Runtime Contract

Workflows are declared in YAML manifests under `src/dag/manifests/`. Stage
declarations define parentage, command vocabulary, and produced artifacts. At
runtime, the adapter compiles manifest data into graph nodes and treats that graph
as the only valid orchestration surface for command dispatch and position
resolution.

Because command ownership is now manifest-derived, parser acceptance and dispatch
routing are constrained to active workflow verbs. This prevents backend vocabulary
drift from introducing persona-specific hidden behavior.

== Position Resolution

Current stage is resolved through artifact inventory and topological readiness
evaluation. The engine inspects materialized stage evidence, verifies parent
availability and lineage validity, and identifies the first unresolved stage in
topological order that is eligible for execution.

This method keeps runtime position reconstructible from filesystem state at any
time. No controller-local pointer can claim advancement without corresponding
artifact evidence.

== Merkle-Coupled Staleness

Stage artifacts are fingerprinted with parent lineage context, which means upstream
re-materialization changes descendant validity even when descendant files still
exist. The DAG engine therefore marks downstream stages stale when parent
fingerprints diverge from recorded lineage. Staleness is not a user-interface
warning; it is a topological validity condition that blocks unsafe continuation.

== JOIN Semantics: Control Materialized as Data

Multi-parent stages represent convergence points where control choices must be
resolved before execution. Prior implementations used alias-style completion
semantics that treated optional parents as implicitly satisfied. This removed
explicit evidence of the decision and created dispatch ambiguity under later
commands.

The corrected model treats JOIN resolution as data-state. Required parents must
materialize standard evidence. Optional parents must also resolve, either through
executed artifacts or explicit decline artifacts. Only after all parent statuses are
materialized does execution enter the target stage.

The current runtime writes optional-decline evidence as skip artifacts in normal
stage paths. This keeps resolver behavior uniform because completion checks consume
the same artifact contract regardless of whether the parent was executed or
declined.

[source,text]
----
Advance while optional parent is unresolved:

┌────────────────────────────────────┐
│ command("harmonize")               │
└───────────────┬────────────────────┘
                ▼
┌────────────────────────────────────┐
│ transition check: pending rename   │
└───────────────┬────────────────────┘
                ▼
┌────────────────────────────────────┐
│ auto-decline policy resolves true  │
└───────────────┬────────────────────┘
                ▼
┌────────────────────────────────────┐
│ materialize skip evidence: rename  │
└───────────────┬────────────────────┘
                ▼
┌────────────────────────────────────┐
│ re-sync topological position       │
└───────────────┬────────────────────┘
                ▼
┌────────────────────────────────────┐
│ dispatch harmonize                 │
└────────────────────────────────────┘
----

== Auto-Decline and Phase Progression

When a user advances to a downstream stage while optional parents remain unresolved,
transition logic evaluates whether the unresolved set is auto-declinable under
manifest policy. If so, decline artifacts are materialized and the resolver
re-synchronizes position before dispatching the requested stage. Mandatory-parent
gaps remain blocking and cannot be auto-declined.

This behavior removed recursive loop surfaces previously triggered by strict-lock
rejection followed by conversational fallthrough, because workflow intents now
remain inside workflow dispatch semantics even when the command targets a different
stage than the current pointer.

== Pointer Integrity and Session Realignment

Hardening also addressed stale-pointer behavior by ensuring fast verification paths
detect self-completed stages and force slow-path advancement. Session-path updates
after project renames are propagated through all consumers so status providers and
resolver scans continue to inspect the active lineage root.

These corrections preserve a single invariant: stage position is always derived from
current artifact truth in the active session context.

== Architectural Outcome

The DAG engine now expresses orchestration as a fully materialized graph contract.
Manifests declare topology and verbs, adapter logic enforces parent-state validity,
and Merkle lineage anchors temporal consistency. JOIN decisions are no longer
controller folklore. They are filesystem evidence subject to the same verification
discipline as compute outputs.

---
_Last updated: 2026-02-20 (v10.3.0)_
