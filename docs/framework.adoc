= ARGUS Framework Patterns: The Architecture of Deterministic UI
:author: ATLAS Project Team
:revdate: 2026-02-17
:revnumber: 10.0.0
:toc: macro
:toclevels: 3
:sectnums:

toc::[]

== Abstract

The ARGUS Framework is a specialized UI architecture built on Vanilla TypeScript, designed to manage the high complexity of federated medical imaging workflows without the overhead of third-party frontend frameworks. By enforcing strict patterns for reactivity, component lifecycle, and DOM ownership, ARGUS ensures a consistent, high-fidelity user experience across both web and CLI surfaces. This document codifies the core framework patterns—specifically the "Slot Pattern" and "RPN Naming"—that maintain architectural integrity within the decoupled Host/Guest system of v10.0.

== Introduction: The Historical Context

The decision to build ARGUS without a traditional frontend framework (e.g., React, Vue, or Svelte) was a deliberate engineering choice to ensure architectural purity and environment-agnosticism. Early development efforts encountered significant challenges with "DOM Pollution" and "State Drift," where different UI components would interfere with each other's DOM subtrees, leading to fragile and non-deterministic behavior. We learned that for a system grounded in data-state truth, the UI must be a deterministic projection of that state, not a source of truth itself.

The resolution was the development of a suite of project-specific patterns designed to provide the same benefits as modern frameworks—isolation, reactivity, and modularity—but without the runtime overhead. Most notably, the **Slot Pattern** was introduced to solve visual isolation, and **RPN Naming** was mandated to provide functional clarity. These patterns ensure that the ARGUS LCARS interface remains scalable and verifiable through the ORACLE methodology, providing a robust interface for both human and AI operators.

== RPN Naming Convention: Functional Clarity

All functions and methods in the ARGUS codebase must follow **Reverse Polish Notation (RPN)**: `<subject>_<verb>`.

*   **Engineering Rationale:** Traditional imperative naming (e.g., `expandWorkspace`) often obscures the primary target of the action. By leading with the subject (e.g., `workspace_expand`), ARGUS ensures that related functions group naturally in alphabetical listings and that the intent of the code is immediately apparent.
*   **Implementation:** This convention applies to all layers of the system, from low-level VFS mutations (`node_write`) to high-level UI orchestrators (`projectStrip_render`). It is the "Grammar" of the ARGUS project, enabling both human and AI developers to navigate the codebase with high precision.

== The Slot Pattern: Visual Isolation

To handle the complexity of the LCARS multi-mode interface, ARGUS utilizes the **Slot Pattern**. This solves the problem of multiple consumers (e.g., Marketplace, Project Detail, Dataset Detail) needing to occupy the same physical DOM container.

=== The Problem: DOM Corruption
Naively overwriting `innerHTML` on component open and attempting to "restore" it on close is a known failure mode. If any component fails to perfectly restore the DOM, the subsequent component inherits a corrupted environment.

=== The Resolution: Logical Slots
Instead of mutating shared DOM, the container holds the **default consumer** as static HTML and provides empty **slot containers** for additional modes. Visibility is managed strictly through CSS attribute selectors (e.g., `[data-mode="project"]`).
*   **Host Responsibility:** The UI orchestrator sets the `data-mode` and writes the Guest content into the designated slots.
*   **Verification:** This pattern ensures that the default state is never lost and that UI bugs are physically contained within their own slots, preventing the "cascading DOM failure" common in legacy web applications.

== Stage Lifecycle Hooks: Predictable Transitions

Workflow progression in ARGUS is managed through **Stage Lifecycle Hooks**. Each SeaGaP stage (Search, Gather, Process, etc.) is a self-contained module that exports `stage_enter()` and `stage_exit()` functions.

*   **Decoupled Orchestration:** The main entry point (`argus.ts`) does not contain stage-specific logic. It simply dispatches to the appropriate hooks when the application state changes.
*   **Automated Cleanup:** The `stage_exit` hook is responsible for tearing down environment-specific state, such as active FileBrowser instances or terminal resize handles. This ensures that the system always starts from a clean slate when entering a new phase of the scientific process.

== The Provider Pattern: Domain-to-VFS Translation

Providers are the "Translators" of the ARGUS system. They are pure functions located in `src/vfs/providers/` that transform high-level domain objects (e.g., a `Project` model) into low-level VCS filesystem trees.

*   **Materialization Bridge:** This pattern is the primary mechanism for Data-State Grounding. When a project is loaded, the `ProjectProvider` generates the `src/`, `input/`, and `output/` skeleton and mounts it into the VFS.
*   **Lazy Content:** Providers use `contentGenerator` strings to enable lazy materialization. File content is only synthesized when a read operation occurs, allowing the VCS to support massive datasets without excessive memory usage.

== Conclusion

The ARGUS Framework patterns provide the structural discipline required to build a sophisticated, agent-mediated interface without the fragility of traditional state-heavy UI models. By grounding the UI in deterministic projections and isolating component state through slots and providers, we ensure that the ARGUS console remains a robust and reliable tool for federated medical research. These conventions are the foundation upon which the v10.0 architecture stands, enabling perfect synchronization between the visual interface and the materialized ground truth.

---
_Last updated: 2026-02-17 (v10.0.0)_
