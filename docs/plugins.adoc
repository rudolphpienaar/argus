= ARGUS Plugin System: Guest Compute Under Host Integrity
:author: ATLAS Project Team
:revdate: 2026-02-21
:revnumber: 10.3.1
:toc: macro
:toclevels: 4
:sectnums:

toc::[]

== Abstract

The plugin system is the compute layer of ARGUS. It isolates domain behavior from
kernel orchestration by executing workflow logic as stateless guest modules loaded
through manifest handlers. This architecture allows persona evolution without
kernel rewrites and keeps provenance control centralized in host runtime.

This specification captures the post-hardening state in which federation phases are
also plugin materialized, backend latency simulation is removed, and handler
ownership is resolved through dynamic convention rather than static backend tables.

== Historical Context

Before the plugin VM boundary stabilized, workflow logic lived in shared core
paths. That coupling made behavior difficult to reason about because stage-specific
changes could affect unrelated flows. It also weakened verification boundaries by
mixing compute decisions with orchestration control.

The v10 pivot moved logic into plugins, and the 10.2 to 10.3 hardening passes
removed remaining internalized surfaces so plugin ownership became real rather than
partial.

== Plugin Boundary Figure

[source,text]
----
                    ┌────────────────────────────────────┐
                    │           PLUGIN CONTEXT           │
                    │ vfs | shell | store | ui telemetry│
                    └─────────────────┬──────────────────┘
                                      │
                                      ▼
                             ┌────────────────┐
                             │ PLUGIN VM      │
                             │ src/plugins/*  │
                             └───────┬────────┘
                                     │ PluginResult
                                     ▼
                             ┌────────────────┐
                             │ CALYPSO HOST   │
                             └───────┬────────┘
                                     ▼
                             ┌────────────────┐
                             │ MERKLE ENGINE  │
                             └────────────────┘

forbidden import direction:
src/plugins/*  ─X─▶  src/core/stages/*, src/core/logic/*
----

== Host and Guest Contract

`PluginHost` loads handler modules dynamically according to manifest-declared
handler names and validates runtime exports before execution. The host constructs a
typed `PluginContext`, invokes `plugin_execute`, receives a typed `PluginResult`,
and then performs host-owned materialization through Merkle layers.

This lifecycle keeps guest modules transient and stateless from the kernel
perspective. Plugins do work. Hosts witness and record outcomes.

== Capability Surface

Guest code receives only bounded capabilities through `PluginContext`, including
project-scoped VFS and shell access, store interaction surfaces, and telemetry
primitives. Plugins do not import browser-stage modules or core orchestration
internals. Boundary enforcement is automated by dependency checks in the standard
build and test gates.

Telemetry follows the same separation doctrine. Plugins emit primitive progress and
message events; host/server layers transport those events; adapters render them in
surface-specific form. Narrative ownership remains with plugins, while geometry and
presentation remain adapter concerns.

[source,text]
----
┌──────────────────┐   ┌──────────────────┐   ┌──────────────────┐   ┌──────────────────┐
│ PLUGIN (guest)   │──▶│ TELEMETRY BUS    │──▶│ CALYPSO SERVER   │──▶│ SURFACE ADAPTERS │
│ ui.progress(...) │   │ host-local pipe  │   │ websocket frames │   │ tui / web render │
└──────────────────┘   └──────────────────┘   └──────────────────┘   └──────────────────┘
----

Operationally this means plugin code should emit monotonic progress percentages for
long loops and avoid UI-specific assumptions. The CLI adapter rewrites a single
active progress row using glyph bars (`█`/`░`) and the web adapter renders equivalent
state through its own view model. Plugins describe work; adapters choose geometry.

== Materialization and Provenance

Plugins return result payloads containing status and optional artifact data. They do
not self-certify completion by writing session ledger artifacts directly. Calypso
captures result payloads, applies lineage hashing, and writes materialized evidence
through the Merkle path. This preserves one authoritative provenance witness and
prevents guest code from bypassing integrity rules.

== Latency Ownership Policy

Compute realism delay, when desired, belongs to plugin implementations. Backend
runtime layers do not contain synthetic sleeps. Test and oracle runs enforce stable
throughput by setting `CALYPSO_FAST=true`, which disables plugin-local delay while
leaving command semantics unchanged.

== Architectural Outcome

The plugin system now expresses the intended Host/Guest architecture without major
exceptions. Manifest declarations select behavior, plugins execute compute, and host
layers preserve deterministic orchestration and provenance integrity. This division
is the foundation for v11 contract lock.

---
_Last updated: 2026-02-21 (v10.3.1)_
