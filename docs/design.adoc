= ARGUS Design Specification (v3.5.0)
:toc:
:toclevels: 3

== 1. The SeaGaP-MP Paradigm
ARGUS implements the **Search, Gather, Process, Monitor, Post** workflow, specifically tailored for the **ATLAS/MERIDIAN** federated learning ecosystem.

== 2. Architectural Structure (Pub/Sub)
To maintain a high-performance Vanilla TypeScript frontend while ensuring state synchronization, the application uses an **Event-Driven Observer Pattern**.

=== 2.1 Central Store (`src/core/state/store.ts`)
The `Store` class encapsulates the application state and provides discrete **Actions** for mutation. All Store methods follow the RPN naming convention (e.g., `stage_set()`, `dataset_toggle()`, `marketplace_toggle()`, `asset_install()`). It maintains references to global singletons including the `VirtualFileSystem`, `Shell`, `LCARSTerminal`, and `FrameSlot`.

=== 2.2 Event Bus (`src/core/state/events.ts`)
A lightweight, typed `EventEmitter` facilitates communication between decoupled modules.
*   **Decoupling:** `navigation.ts` doesn't need to know about `process.ts`. It simply dispatches `STAGE_CHANGED`.
*   **Reactivity:** Modules like `telemetry.ts` and `gather.ts` subscribe to events to update their respective UI components.
*   **Type Safety:** Each event maps to a specific payload type via `EventPayloads` interface.

== 3. The Federalization Model
The transition from local development (**Process**) to distributed execution (**Monitor**) is mediated by the **Federalization Sequence**.

=== 3.1 The Factory Concept
Raw code assets (`train.py`) are not executed locally. Instead, the `federate` command triggers a build process:
1.  **Ingestion:** Assets are sent to the ATLAS Hub.
2.  **Containerization:** The ATLAS Factory wraps the code into a MERIDIAN App.
3.  **Distribution:** Container images are dispatched to Trusted Domains (BCH, MGH, etc.).
4.  **Synchronization:** Training only begins once all nodes verify the payload.

The sequence is orchestrated by `federation_sequence()` in `process.ts`, decomposed into four phases: `federationOverlay_initialize()`, `federationBuild_run()`, `federationDistribution_run()`, and `federationHandshake_run()`.

=== 3.2 The Simulation Loop (Local Testbed)
Before federalization, code must pass a **Phantom Federation** check. This local simulation validates that:
1.  **Serialization**: Model weights can be serialized and deserialized.
2.  **Aggregation**: The aggregation algorithm converges on local data shards.
3.  **Privacy**: Differential privacy noise budgets are respected.

The `simulate` command shards the local VFS `input/` directory into ephemeral "Phantom Nodes" and runs the federation cycle in-memory. Only successful simulation unlocks the external federation capability.

== 4. Virtual Computer System (VCS)
A complete Virtual Computer System (`src/vfs/`) provides the stateful runtime environment underlying the ARGUS Intelligence Terminal. The VCS comprises:

*   **VirtualFileSystem** (`src/vfs/VirtualFileSystem.ts`): In-memory POSIX-like filesystem with content-aware files, path resolution, lazy content generation, and event emission.
*   **Shell** (`src/vfs/Shell.ts`): Command interpreter with 15 builtins, environment variables, `$PS1` prompt generation, and stage transitions.
*   **ContentRegistry** (`src/vfs/content/ContentRegistry.ts`): Maps file paths to content generators. 14 templates generate file bodies on demand.
*   **Providers**: Three providers translate application domain objects into filesystem trees:
    - `DatasetProvider` — builds `~/data/cohort/` from selected datasets
    - `ProjectProvider` — scaffolds `$HOME` and populates `~/src/project/`
    - `MarketplaceProvider` — installs assets to `/bin/`, `/data/sets/`, `~/models/`, etc.

This ensures that the **Terminal**, **IDE**, and **Marketplace** share a consistent, content-rich view of the project structure. See `docs/vcs.adoc` for the full specification.
