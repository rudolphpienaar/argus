= ARGUS System Architecture: A Formal Specification for State-Grounded Orchestration
:author: ATLAS Project Team
:revdate: 2026-02-18
:revnumber: 10.0.1
:toc: macro
:toclevels: 4
:sectnums:

toc::[]

== Abstract

The ARGUS (ATLAS Resource Guided User System) architecture is a specialized, high-integrity execution environment designed to facilitate federated medical imaging workflows. As a foundational component of the ATLAS platform, ARGUS must mediate between the inherent ambiguity of natural language intent and the absolute deterministic requirements of clinical data processing. To achieve this, the system implements a "State-First" architecture, wherein every cognitive operation is strictly decoupled from its physical execution. 

This specification details the v10.0 architecture, which defines the system as a Host Virtual Machine (Calypso) providing a standardized substrate for Guest Logic (Plugins). By grounding all workflow transitions in Merkle-proven artifact materialization, ARGUS effectively resolves the "Irreducible Hallucination" problem found in probabilistic agentic systems. This document serves as the authoritative reference for the system's structural design, its security model, and its deterministic state-management protocols.

== Introduction: The Evolutionary Pressure for v10.0

=== The History of Monolithic Drift
The transition to the v10.0 architecture was necessitated by the structural limitations observed in the v9.x series. In the legacy monolithic model, the AI Core (Calypso) functioned as a consolidated command-and-control center. It was responsible for both interpreting user intent and executing the resulting domain-specific mutations. This coupling led to the phenomenon of "Monolithic Drift"—a condition where the AI's internal representation of the project state would gradually diverge from the actual state of the filesystem. 

During long-running sessions, specifically in complex multi-site federation handshakes, the legacy system's reliance on in-memory counters and boolean flags proved insufficient. Small race conditions in state updates would propagate through the AI's context window, eventually causing the system to offer invalid guidance or, worse, skip critical data-harmonization steps. The fundamental lesson learned was that an AI, being a probabilistic engine, cannot be the "Source of Truth" for a scientific workflow.

=== The Problem: The Irreducible Hallucination of Agency
The core problem addressed by v10.0 is the "Irreducible Hallucination" inherent in autonomous agentic loops. When an LLM is given direct agency over system calls, the probability of failure increases exponentially with the number of steps in the workflow ($P_{total} = P_{step}^n$). In medical imaging, where data provenance is a regulatory requirement, a 60% reliability rate for a 10-step process is functionally identical to a total system failure.

=== The Resolution: The Operating System Metaphor
The v10.0 architecture resolves this by adopting an "Operating System Metaphor." The system is refactored into a high-integrity Kernel (the Host) and a set of unprivileged Applications (the Plugins). The AI's role is strictly limited to that of a "Compiler"—it translates user intent into a structured protocol, but it is never allowed to execute that protocol itself. The Host kernel performs all state mutations, enforces all workflow constraints, and materializes all artifacts. This separation ensures that the system's "Intelligence" and its "Integrity" are governed by two distinct, non-overlapping architectural layers.

== Architectural Overview (ASCII)

The following figure summarizes the major runtime components and data/control flow described in this specification.

[source,text]
----
                         user commands / responses
┌───────────────────────────────────────────────────────────────────┐
│ Surface Adapters                                                  │
│ - Browser (WUI)                                                   │
│ - TUI / CLI                                                       │
│ - ORACLE Runner (headless walk driver)                            │
└──────────────────────────────────────┬────────────────────────────┘
                                       │
                                       ▼
┌───────────────────────────────────────────────────────────────────┐
│ CALYPSO HOST (`src/lcarslm/CalypsoCore.ts`)                       │
│ Fast-path dispatch -> Intent compilation -> Gatekeeping -> Dispatch│
└──────────────────────────┬────────────────────────────────────────┘
                           │
                           ▼
┌───────────────────────────────────────────────────────────────────┐
│ WorkflowSession + WorkflowAdapter                                 │
│ - DAG prerequisite validation                                     │
│ - phase-jump confirmation                                         │
│ - stale/missing parent detection                                  │
└──────────────────────────┬────────────────────────────────────────┘
                           │
                           ▼
┌───────────────────────────────────────────────────────────────────┐
│ PluginHost (`src/lcarslm/PluginHost.ts`)                          │
│ - dynamic plugin load (`src/plugins/*.ts`)                        │
│ - typed PluginContext injection                                   │
└──────────────────────────┬────────────────────────────────────────┘
                           │ PluginContext
                           ▼
┌───────────────────────────────────────────────────────────────────┐
│ Deterministic Substrate                                            │
│ - Store (`src/core/state/store.ts`)                               │
│ - VFS (`src/vfs/VirtualFileSystem.ts`)                            │
│ - Shell (`src/vfs/Shell.ts`)                                      │
└──────────────────────────┬────────────────────────────────────────┘
                           │ artifactData
                           ▼
┌───────────────────────────────────────────────────────────────────┐
│ MerkleEngine (`src/lcarslm/MerkleEngine.ts`)                      │
│ - SHA-256 provenance fingerprinting                               │
│ - topological artifact materialization                             │
└──────────────────────────┬────────────────────────────────────────┘
                           │
                           ▼
┌───────────────────────────────────────────────────────────────────┐
│ Session Tree (materialized truth in VFS)                           │
│ `/sessions/<workflow>/<session>/<topology>/data/*.json`           │
└───────────────────────────────────────────────────────────────────┘

Fallback path:
Surface -> Calypso -> LLM conversational response only (no state mutation)
----

== Figure Roadmap (Recommended)

All figures in this architecture set should use ASCII box/line art only.

=== 1) Command Lifecycle Sequence (ASCII)

[source,text]
----
┌─────────┐   ┌─────────────┐   ┌──────────────┐   ┌────────────┐   ┌────────────┐
│ Surface │──▶│ CalypsoCore │──▶│ IntentParser │──▶│ Workflow   │──▶│ PluginHost │
└─────────┘   └─────────────┘   └──────────────┘   │ Adapter    │   └────────────┘
                                                   └────────────┘          │
                                                          │                │
                                                          ▼                ▼
                                                    ┌──────────┐      ┌────────────┐
                                                    │ Gatekeep │─────▶│ Plugin     │
                                                    └──────────┘      │ (execute)  │
                                                                      └────────────┘
                                                                              │
                                                                              ▼
                                                                       ┌───────────────┐
                                                                       │ MerkleEngine  │
                                                                       └───────┬───────┘
                                                                               │
                                                                               ▼
                                                                       ┌───────────────┐
                                                                       │ VFS Session   │
                                                                       │ Tree Artifact │
                                                                       └───────────────┘

result/status path:
┌───────────────┐        ┌─────────────┐        ┌─────────┐
│ MerkleEngine  │───────▶│ CalypsoCore │───────▶│ Surface │
└───────────────┘        └─────────────┘        └─────────┘
----

=== 2) SeaGaP State Machine (ASCII)

[source,text]
----
┌────────┐     ┌────────┐     ┌─────────┐     ┌─────────┐     ┌──────┐
│ SEARCH │────▶│ GATHER │────▶│ PROCESS │────▶│ MONITOR │────▶│ POST │
└────────┘     └────────┘     └─────────┘     └─────────┘     └──────┘
     │              │              │               │              │
     └──────────────┴──────────────┴───────────────┴──────────────┘
                    phase jump requires explicit confirmation

blocked paths:
  - missing parent artifact  -> BLOCKED_MISSING
  - stale upstream artifact  -> BLOCKED_STALE
----

=== 3) Plugin Boundary Diagram (ASCII)

[source,text]
----
                  allowed via PluginContext
         ┌──────────────────────────────────────┐
         │ vfs │ shell │ store │ federation(opt)│
         └──────────────────┬───────────────────┘
                            │
                            ▼
                     ┌─────────────┐
                     │ Plugin Code │
                     └─────────────┘
                            │
        ┌───────────────────┴───────────────────┐
        │                                       │
        ▼                                       ▼
  ┌─────────────┐                        ┌───────────────┐
  │ allowed:    │                        │ forbidden:    │
  │ src/plugins │                        │ src/core/*    │
  │ returns     │                        │ orchestration │
  │ PluginResult│                        │ stage modules │
  └─────────────┘                        └───────────────┘
----

=== 4) Provenance Topology (ASCII)

[source,text]
----
/sessions/fedml/session-001/
│
├── search/
│   ├── data/search.json
│   └── meta/fingerprint.json
│
├── search/gather/
│   ├── data/gather.json
│   └── meta/fingerprint.json
│
├── search/gather/harmonize/
│   ├── data/harmonize.json
│   └── meta/fingerprint.json
│
└── search/gather/harmonize/proceed/
    ├── data/proceed.json
    └── meta/fingerprint.json

re-run branch example:
search/gather@2026-02-18T16-00-00Z/
----

=== 5) Deployment View (ASCII)

[source,text]
----
          ┌───────────────────────────┐
          │ Shared Core Runtime       │
          │ Calypso + Store + VFS     │
          └─────────────┬─────────────┘
                        │
      ┌─────────────────┼───────────────────┐
      │                 │                   │
      ▼                 ▼                   ▼
┌───────────┐    ┌─────────────┐    ┌───────────────┐
│ Browser   │    │ TUI / CLI   │    │ ORACLE Runner │
│ Adapter   │    │ Adapter     │    │ (headless)    │
└───────────┘    └─────────────┘    └───────────────┘
----

=== 6) Cross-Surface Rendering Contract (ASCII)

[source,text]
----
                   ┌──────────────────┐
                   │ Shell stdout/err │
                   └─────────┬────────┘
                             │
                             ▼
                 ┌───────────────────────────┐
                 │ languageRegistry (shared) │
                 └─────────────┬─────────────┘
                               │
                 ┌─────────────┴─────────────┐
                 │                           │
                 ▼                           ▼
      ┌───────────────────────┐    ┌─────────────────────────┐
      │ WUI: HTML highlighter │    │ TUI: ANSI highlighter   │
      │ src/ui/syntax...      │    │ src/calypso/ui/tui/...  │
      └───────────────────────┘    └─────────────────────────┘
----

== The Host/Guest Architecture: The VM Formalism

The fundamental design of ARGUS v10.0 is a Host Virtual Machine that provides a sandboxed environment for the execution of scientific protocols. This bifurcation is implemented through the `CalypsoCore` and `PluginHost` classes.

=== The Calypso Host (The Kernel)
The `CalypsoCore` class functions as the authoritative system kernel. It maintains the global application state via the `Store` and manages the high-level orchestration of the SeaGaP-MP workflow. The Host is designed to be entirely domain-agnostic; it possesses no inherent knowledge of medical imaging modalities, training hyperparameters, or federation handshake details. Its primary responsibility is the enforcement of the "Standard Library" interface and the cryptographic anchoring of all Guest outputs. By isolating the Host from domain logic, ARGUS ensures that the core security and integrity mechanisms of the system are never compromised by idiosyncratic changes to a specific research workflow.

=== The Plugin Virtual Machine (`PluginHost`)
The `PluginHost` implements the dynamic execution runtime for Guest modules. Located in `src/lcarslm/PluginHost.ts`, this VM utilizes ECMAScript dynamic imports to load unprivileged code from `src/plugins/`.
*   **Dynamic Loading and Isolation:** Plugins are loaded on-demand based on the `handler` specified in the workflow manifest. This ensures that the system's memory footprint is optimized and that different research workflows remain strictly isolated from one another.
*   **The Execution Loop:** When a command is dispatched, the `PluginHost` instantiates the plugin, injects the `PluginContext`, and awaits the `PluginResult`. If a plugin attempts to access resources outside of the injected context (such as the global `window` object or the VFS session tree), the execution is terminated, preventing unauthorized state leakage.

=== The Standard Library: `PluginContext`
Every Guest plugin interacts with the system through a strictly-typed "Standard Library" called the `PluginContext`. This interface defines the totality of a plugin's agency within the system:
*   **`vfs` (Virtual File System):** A project-scoped instance of the `VirtualFileSystem` allowing for POSIX-compliant file mutations.
*   **`shell` (Environment Access):** Access to the `Shell` singleton for environment variable management and POSIX builtin execution.
*   **`store` (Application State):** Read-access to project metadata and write-access for specific allowed mutations (e.g., dataset selection).
*   **`federation` (Orchestrator Access):** A specialized interface to the multi-phase `FederationOrchestrator` for site-local handshake management.

This context-based approach ensures that plugins are stateless transformations. They do not "own" their data; they perform work upon the substrate provided by the Host and return the result for materialization.

=== SeaGaP Ownership Boundaries (Search vs Gather)
To keep the SeaGaP spine coherent, ARGUS enforces strict stage ownership:

*   **Search:** Discovery only. Query catalog data and materialize search evidence.
*   **Gather:** Assembly only. Select/mount cohort inputs and materialize gather evidence.
*   **Surface Adapters:** Render and interaction mechanics for browser/TUI clients.

This division is critical because Search and Gather are often triggered in the same user flow. Without explicit ownership, UI concerns leak into runtime plugins and mutation concerns leak into discovery logic.

[cols="1,2,2"]
|===
| Layer | Owns | Must Not Own

| `src/plugins/search.ts`
| Query parsing, dataset discovery, search snapshot payload.
| Gather mutations, overlay behavior, DOM-centric rendering.

| `src/plugins/gather.ts`
| Cohort selection/mount semantics, gather artifact payloads.
| Search query semantics, web-only presentation concerns.

| `src/core/stages/*`
| Surface projection (cards, overlays, stage transitions, event wiring).
| Merkle/session materialization policy, plugin-level business rules.
|===

For implementation constraints and enforcement, see link:plugins.adoc[Plugin System] and `npm run check:boundaries`.

== The Interpretation-First Pipeline: The Logic of Intent

ARGUS v10.0 replaces the legacy "Waterfall" regex matcher with a rigorous 4-stage pipeline that treats natural language interpretation as a compilation process. This pipeline is the primary defense against instructional decay and hallucination.

=== Stage 1: Fast-Path Kernel Dispatch
The pipeline begins at `CalypsoCore.shell_handle()`. Before any complex interpretation occurs, the system checks for high-priority "Kernel" commands. These include built-in system operations (prefixed with `/`) and common POSIX utilities. By intercepting these first, the Host ensures that core system controls—such as `/reset` or `/status`—are always deterministic and immune to LLM misinterpretation.

=== Stage 2: Intent Compilation (`IntentParser`)
If the command is not a fast-path operation, it is passed to the `IntentParser`. This component functions as a compiler that translates noisy natural language into a canonical `CalypsoIntent` object.
*   **Deterministic Verb Matching:** The parser maintains a registry of high-priority workflow verbs (e.g., `search`, `gather`, `harmonize`). If the user's input matches a known verb pattern, the intent is resolved instantly without LLM intervention.
*   **LLM Intent Synthesis:** If deterministic matching fails, the input is sent to the LLM with a strict JSON schema directive. The LLM is tasked with identifying the user's intent from the available command space. If the LLM returns an intent that does not exist in the manifest, the Host rejects it with an `UNKNOWN` status. This prevents the LLM from "inventing" system capabilities.

=== Stage 3: Verification and Gatekeeping
Once an intent is resolved to a canonical command, it is passed to the `WorkflowSession`. The `WorkflowAdapter` performs a topological walk of the active DAG manifest to determine if the command is valid given the current state of the VFS.
*   **Prerequisite Checking:** If the command requires a parent artifact that does not exist (e.g., attempting `train` without `harmonize.json`), the Host returns a `BLOCKED_MISSING` status.
*   **Phase Jump Detection:** If the command targets a non-adjacent future stage, the Host triggers a "Phase Jump" warning. This warning requires explicit confirmation from the user, ensuring that skips are intentional and documented.

=== Stage 4: Execution and Materialization
The final stage is the dispatch to the `PluginHost`. If the plugin executes successfully, it returns a `artifactData` payload. The Host then invokes the `MerkleEngine` to anchor this data into the session tree. This materialization is the only way for a stage to be marked as "Complete." The system never trusts a "success" message from a plugin; it only trusts the existence of the resulting artifact on the disk.

== Data-State Grounding: The Merkle Formalism

The architectural "Conscience" of ARGUS is the `MerkleEngine`. This component ensures that every state transition in a workflow is cryptographically anchored and physically verifiable.

=== The SHA-256 Provenance Chain
Every artifact envelope materialized by the `MerkleEngine` contains a `fingerprint`. This fingerprint is a recursive hash calculated as:
$$H_{node} = \text{SHA-256}(Data_{node} + \sum H_{parents})$$
This calculation ensures that an artifact's integrity is inextricably linked to the integrity of its ancestors in the DAG. If an upstream artifact is modified or re-executed, the fingerprints of all downstream artifacts immediately become invalid.

=== Topological Nesting and Branching
The session tree is structured as a physical mirror of the DAG's topology. Artifacts are written to paths that reflect their lineage (e.g., `/sessions/fedml/session-001/search/gather/harmonize/data/harmonize.json`). 
*   **Materialized Branching:** When a user re-executes a stage, the `MerkleEngine` creates a timestamped branch directory. This preserves the historical provenance while allowing for iterative experimentation.
*   **Staleness Detection:** The `WorkflowAdapter` uses this topological structure to perform real-time staleness detection. By comparing the parent fingerprints stored in an artifact's metadata with the current fingerprints of the parent nodes, the system can instantly flag a stage as `[STALE]` if the upstream data has drifted.

== The Virtual Computer System (VCS): The State Substrate

The VCS provides the deterministic "Hardware" upon which the ARGUS Host runs. It is implemented through a full-stack simulation of a POSIX environment.

=== Virtual File System (VFS) Node Model
The `VirtualFileSystem` class manages a recursive tree of `FileNode` objects. 
*   **Node Integrity:** Each node supports standard POSIX properties including permissions (`mode`), timestamps (`mtime`), and owner/group IDs. This allows ARGUS to enforce strict access controls within the virtual environment, preventing a "Radiology" plugin from accessing a "Pathology" project's input data.
*   **Mount Semantics:** The VFS supports the dynamic mounting and unmounting of subtrees. This is utilized by the `Gather` stage to map Site-Local institution data into a unified project-scoped view (`/input/training/`).

=== The Shell and Environment Isolation
The `Shell` class provides the process-level context for all execution. It maintains the environment variables ($USER, $PWD, $PROJECT) that define the "persona" of the current session. When a plugin is executed, it inherits the Shell's environment, ensuring that all VFS mutations occur within the correct project context. The Shell also provides the `python` simulator, which allows researchers to verify the behavior of their training scripts against "Phantom" data before committing to a real-world federation.

=== Cross-Surface Syntax Highlighting Contract

ARGUS enforces a strict separation between command execution and rendering:

*   **Shell (`src/vfs/Shell.ts`)**: Produces deterministic output streams only.
*   **Language Registry (`src/core/syntax/languageRegistry.ts`)**: Canonical language detection and alias/filename mapping.
*   **WUI Adapter Path**: `src/core/logic/commands.ts` + `src/ui/syntaxHighlight.ts` (HTML rendering).
*   **TUI Adapter Path**: `src/calypso/ui/tui/TuiRenderer.ts` + `src/calypso/ui/tui/SyntaxHighlight.ts` (ANSI rendering).

This design prevents drift where browser and TUI would otherwise disagree on how the same `cat` output or fenced code block should be interpreted.

For implementation details, see link:shell.adoc[VCS Shell] and link:plugins.adoc[Plugin System].

== Security and Integrity Analysis

The ARGUS architecture is designed to meet the rigorous security requirements of medical data handling.

=== Cross-Site Leak Prevention
By virtualizing the entire execution environment within the browser or a headless Node.js process, ARGUS ensures that no site-local data ever leaves its institutional boundary during the search or gather phases. The "Gather" process only mounts metadata and pointers within the VCS; actual data movement only occurs during the "Dispatch" phase, which is governed by separate ATLAS platform security protocols.

=== Procedural Compliance via Merkle Proofs
The combination of the DAG Engine and the Merkle Engine ensures that no user can bypass the scientific protocols defined in the workflow manifest. Because the system's logic is grounded in the existence of Merkle-proven artifacts, an "Action" cannot be considered valid unless its "State" matches the cryptographic proof of its parentage. This provides an immutable audit trail of the scientific process, a requirement for FDA and IRB compliance in federated research.

== Conclusion

The ARGUS v10.0 architecture represents a fundamental departure from conversational AI interfaces. By refactoring the system into a Host Virtual Machine and a deterministic Plugin Runtime, ARGUS effectively grounds the probabilistic "Intelligence" of the LLM in the "Ground Truth" of a persistent filesystem. The resulting system is not merely an assistant, but a robust Operating System for federated medical imaging. The architecture's commitment to state-first verification ensures that every scientific result produced by ARGUS is backed by a verifiable chain of evidence, providing the trust and security required for national-scale medical research.

---
_Last updated: 2026-02-18 (v10.0.1)_
