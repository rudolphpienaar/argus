= ARGUS Architecture
:toc:
:toclevels: 3
:sectnums:

== Core Philosophy: Robust Vanilla
ARGUS avoids heavy frontend frameworks (React, Vue) to maintain maximum performance and "snap." However, to avoid state desynchronization issues common in imperative Vanilla JS, we employ a **Pub/Sub (Observer) Pattern**.

== State Management (Pub/Sub)

The application state is centralized in a `Store` that acts as the single source of truth. Components do not mutate state directly; they dispatch **Actions**. The Store mutates the state and broadcasts **Events**. Components subscribe to these events to update the UI.

== Application Logic Layers

The application logic is decoupled into specialized providers and orchestrators.

=== Calypso AI Core (Orchestrator)
**`src/lcarslm/CalypsoCore.ts`**
*   **Role**: Primary command execution pipeline.
*   **Architecture**: Modular orchestrator that delegates to logic providers.
*   **Pipeline**: 11-stage waterfall (Script -> Special -> Control Plane -> Confirmation -> Harmonize -> Shell -> Workflow -> Guidance -> Action -> LLM).

=== Logic Providers (Capability Layer)
As of v9.0.0, heavy logic is isolated into specialized providers:
*   **`SearchProvider`**: Dataset discovery and anaphora resolution.
*   **`StatusProvider`**: System status and context generation.
*   **`LLMProvider`**: LLM orchestration and intent parsing.
*   **`CalypsoPresenter`**: Visual formatting and LCARS dialect markers.

=== The Intent Layer (Local IAS)
**`src/core/logic/ProjectManager.ts`**
*   **Role**: Bridges high-level intents ("Gather this dataset") to low-level system operations (VFS mounting, Store mutation).
*   **Architecture**: Implements the **Intent-Action Service (IAS)** pattern locally.

== Virtual Computer System (VCS)

The VCS (`src/vfs/`) is ARGUS's stateful runtime environment. It provides a POSIX-like in-memory filesystem with content-aware files, a Shell interpreter, and a Provider architecture.

=== Components

[cols="1,2"]
|===
| Component | Location

| VirtualFileSystem
| `src/vfs/VirtualFileSystem.ts` — Tree storage, content storage, path resolution, CWD, events.

| Shell
| `src/vfs/Shell.ts` — Command interpreter and environment manager.

| ShellBuiltins
| `src/vfs/ShellBuiltins.ts` — Implementation of 20+ POSIX builtins (ls, cd, python, upload, analyze, etc.).

| ContentRegistry
| `src/vfs/content/ContentRegistry.ts` — Maps file paths to content generators.

| DatasetProvider
| `src/vfs/providers/DatasetProvider.ts` — Builds `~/data/cohort/` from selected datasets.

| ProjectProvider
| `src/vfs/providers/ProjectProvider.ts` — Scaffolds `$HOME` + populates `~/src/project/`.
|===

=== Data Flow

1.  **User types `cat train.py`** in the terminal.
2.  **Terminal** sends raw input to the **Shell**.
3.  **Shell** expands variables and delegates to **ShellBuiltins**.
4.  **ShellBuiltins** calls `vfs.node_read()`.
5.  **VFS** resolves content via the **ContentRegistry**.
6.  **Shell** returns a `ShellResult` to the Terminal.

== Data-State Workflow Semantics

ARGUS's workflow tracking follows the same data-state DAG model used by ChRIS at the compute layer. Progress is proven by the existence of materialized artifacts in the session tree (`~/sessions/`), not by controller assertions.

=== Grounding the LLM

The data-state model prevents the LLM from drifting on workflow state via:
*   **Deterministic routing**: Pattern matchers intercept status/progress queries.
*   **Context injection**: `StatusProvider` builds stage summaries from live VFS.
*   **Artifact validation**: `WorkflowAdapter` resolves position from materialized envelopes.

See `docs/vcs.adoc` and `docs/calypso.adoc` for full specifications.
