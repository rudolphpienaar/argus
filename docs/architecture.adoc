= ARGUS System Architecture: A Formal Specification for State-Grounded Orchestration
:author: ARGUS Collaborative Development
:revdate: 2026-02-18
:revnumber: 10.2.0
:toc: macro
:toclevels: 4
:sectnums:

toc::[]

== Abstract

The ARGUS (Advanced Resource Guided User System) architecture is a specialized, high-integrity execution environment designed to facilitate complex federated imaging workflows. ARGUS mediates between the inherent ambiguity of natural language intent and the absolute deterministic requirements of scientific data processing. To achieve this, the system implements a "State-First" architecture, wherein every cognitive operation is strictly decoupled from its physical execution. This specification details the v10.2 architecture, which defines the system as a Streaming Unified Kernel (SUK) providing a standardized substrate for Guest Logic (Plugins). By grounding all workflow transitions in Merkle-proven artifact materialization and projecting live execution telemetry across a unified WebSocket protocol, ARGUS effectively resolves the "Irreducible Hallucination" problem found in probabilistic agentic systems.

== Introduction: Concept and Context

The ARGUS architecture emerges from a fundamental critique of the modern autonomous agent paradigm. In traditional agentic systems—such as AutoGPT or SWE-agent—the AI model is given direct agency over system calls, operating in an open-ended loop where it plans, executes, and observes. While this model is effective for low-stakes general-purpose assistance, it is mathematically brittle for scientific research. In an ungrounded loop, the cumulative probability of failure increases exponentially with every step ($P_{total} = P_{step}^n$), leading to "Instructional Decay" where the agent eventually loses track of the physical state of the environment. In medical imaging, where provenance and reproducibility are non-negotiable, a probabilistic approach to workflow management is functionally identical to a system failure.

To address these risks, ARGUS is positioned as a **State-Grounded Orchestrator**, a category of system that utilizes AI as a linguistic interface (a "Compiler") but relies on a deterministic kernel (the "Operating System") for all state mutations. Unlike "AI-as-a-Sidebar" implementations found in generic IDEs or chat platforms, where the AI is a supplementary tool, ARGUS treats the conversational terminal as the primary control surface. However, this surface is backed by a Virtual Computer System (VCS) that enforces POSIX-compliant rules and Merkle-proven state verification. This ensures that the AI cannot "hallucinate" progress; it can only report on the physical materialization of artifacts within the filesystem.

The core differentiator of the ARGUS model is the **Intent-Action-State (IAS)** separation. In this framework, the AI is restricted to the "Intent" phase, translating noisy human language into a strictly-typed protocol. The "Action" phase is owned by unprivileged Guest plugins, and the "State" phase is managed by the high-integrity Host kernel. By isolating the probabilistic "Intelligence" of the AI from the deterministic "Integrity" of the execution substrate, ARGUS provides a high-fidelity environment where researchers can drive complex multi-site protocols through natural language without compromising the scientific truth of the results.

This architecture is critically needed in federated environments where researchers must coordinate data-intensive tasks across distributed sites. Traditional UIs for these tasks are often rigid and complex, while raw CLI interfaces are opaque to non-technical users. ARGUS bridges this gap by providing a "Human-Friendly but Machine-Strict" environment. It provides the fluid user experience of a conversational agent with the rigorous auditability of a blockchain-anchored ledger. By grounding every interaction in a topological session tree, ARGUS transforms the "Hallucinating Agent" into a high-fidelity instrument of scientific discovery, ensuring that every decision is backed by cryptographically-anchored evidence.

== The Streaming Unified Kernel (SUK) Architecture

The following figure illustrates the relationship between the user, the distributed computation hub (Calypso Server), and the specialized observation surfaces (TUI and WUI), highlighting the bidirectional flow of the SUK protocol and the final rendering update path.

[source,text]
----
                                  [ USER ]                                      
                                     │                                          
             ┌───────────────────────┴───────────────────────┐                  
             │                                               │                  
             ▼ (CLI / SSH)                                   ▼ (Browser / HTTP) 
    ┌───────────────────────────┐               ┌───────────────────────────┐   
    │       TUI TERMINAL        │               │       WEB TERMINAL        │   
    │  ┌─────────────────────┐  │               │  ┌─────────────────────┐  │   
    │  │ [ ASCII RENDERER ]  │◀─┼──────┐ ┌──────┼─▶│ [ DOM/CSS ENGINE ]  │  │   
    │  └─────────────────────┘  │      │ │      │  └─────────────────────┘  │   
    │             │             │      │ │      │             │             │   
    │      (Dumb Client)        │      │ │      │    (Intelligent Surface)  │   
    └──────┬──────┴─────────────┘      │ │      └──────┬──────┴─────────────┘   
           │      ▲                    │ │             │      ▲                 
           ▼      │            [ UI WEBSOCKET PIPE ]   ▼      │                 
           │      │         (Commands ▼ | Telemetry ▲) │      │                 
           └──────┼───────────────────┬─┴─┬────────────┘      │                 
                  └───────────────────┼───┼───────────────────┘                 
                                      │   │                                     
    ┌─────────────────────────────────┴───┴─────────────────────────────────┐   
    │ CALYPSO SERVER (The System CNS / WebSocket Orchestrator)              │   
    │                                                                       │   
    │  ┌─────────────────────────────────────────────────────────────────┐  │   
    │  │ CALYPSO HOST (The System Kernel)                                │  │   
    │  │                                                                 │  │   
    │  │  ┌───────────────────────────────────────────────────────────┐  │  │   
    │  │  │ PLUGIN VM (The Guest Execution Sandbox)                   │  │  │   
    │  │  │  ┌─────────────────────────────────────────────────────┐  │  │  │   
    │  │  │  │ GUEST PLUGIN (Compute Logic & Narrative Source)     │  │  │  │   
    │  │  │  │                                                     │  │  │  │   
    │  │  │  │  ● Compute Loop  ──▶ [ TELEMETRY BUS ]  ────────────┼──┼──┐│  │   
    │  │  │  │  ● Lore Source   ──▶ (Internal Pipe)                │  │  ││  │   
    │  │  │  └────────▲────────────────────────────────────────────┘  │  ││  │   
    │  │  └───────────┼───────────────────────────────────────────────┘  ││  │   
    │  └──────────────┼──────────────────────────────────────────────────┘│  │   
    │                 │ (Commands)        │ (Telemetry Stream)            │  │   
    │          [ COMMAND ROUTER ] ◄───────┘                               │  │   
    │                 │                                                   │  │   
    └─────────────────┼───────────────────────────────────────────────────┘   
                      │                                                         
                      ▼                                                         
            [ FEDERATION NETWORK ]                                              
            (Secure Multi-Site Transport)                                       
----

Argus v10.2 establishes the **Streaming Unified Kernel (SUK)** model, marking the final transition of ARGUS from a monolithic application into a **Distributed Orchestration System**. In this paradigm, the core logic—housed in atomic Guest plugins—is strictly isolated within a high-integrity Host (Calypso), which functions as a headless computation engine. This engine exposes its entire operational state, including live execution telemetry, through a **Unified Protocol Surface**. This ensures that the "Truth" of the scientific process is never trapped within a single UI component or local memory stack, but is instead a global broadcast available to any authorized observer, whether that observer is a human researcher or an automated validation suite.

The interaction is governed by a tiered **Dual-Socket Topology** that clearly separates human-centric telemetry from machine-centric data movement. The first layer, the **UI WebSocket Pipe**, handles the bidirectional flow of commands (from client to server) and live telemetry frames (from server to client). The second layer, the **Federation WebSocket**, connects the Calypso Server to the actual web—the external site-local network. These are distinct sockets with specialized security profiles: the UI pipe optimizes for low-latency streaming of "Lore," while the Federation pipe manages high-integrity clinical data handshakes between distributed sites. This ensures that the internal telemetry broadcast is never throttled by heavy data transfers, maintaining a responsive user experience during complex federated jobs.

Within this system, the **Calypso Host** acts as the Hardware Abstraction Layer for the **Plugin Virtual Machine**. When a Guest plugin executes a compute loop (e.g., cohort scanning or local validation), it emits raw primitives—such as logs, progress updates, or animation requests—onto an internal **Telemetry Bus**. This bus functions as a local, high-integrity interface for the plugin (comparable to the `tqdm` pattern in Python), shielding the Guest from the technical complexities of network transport and serialization. The Host kernel intercepts these local events and serializes them into protocol-compliant frames for broadcast via the WebSocket Orchestrator. This design ensures that the plugin logic remains 100% portable and surface-agnostic; the Guest never "talks to the web" or the DOM directly, but simply reports its progress to the Host.

The rationale for this move is the enforcement of absolute **Visual and Logical Parity** across all ARGUS surfaces. Because both the TUI and the WUI consume the exact same telemetry stream from the server, they are guaranteed to present a synchronized view of the workflow. When a plugin signals a progress update, the TUI terminal triggers its ASCII renderer to draw a box, while the Web Terminal performs a real-time update of its DOM/CSS state to reflect the same progress. This eliminates "Telepathic Coupling," a failure mode where the UI previously attempted to guess the backend's state by eavesdropping on strings. Argus v10.2 ensures that every researcher, regardless of their preferred interface, is making decisions based on the same Merkle-proven evidence, grounded in the real-time state of the virtual machine.

== The Interpretation-First Pipeline: The Logic of Intent

The following figure illustrates the sequence of natural language resolution into deterministic execution.

[source,text]
----
┌─────────┐   ┌─────────────┐   ┌──────────────┐   ┌────────────┐   ┌────────────┐
│ Surface │──▶│ CalypsoHost │──▶│ IntentParser │──▶│ Workflow   │──▶│ PluginHost │
└─────────┘   └─────────────┘   └──────────────┘   │ Adapter    │   └────────────┘
                                                   └────────────┘          │
                                                          │                │
                                                          ▼                ▼
                                                    ┌──────────┐      ┌────────────┐
                                                    │ Gatekeep │─────▶│ Plugin     │
                                                    └──────────┘      │ (execute)  │
                                                                      └────────────┘
                                                                              │
                                                                              ▼
                                                                       ┌───────────────┐
                                                                       │ MerkleEngine  │
                                                                       └───────┬───────┘
                                                                               │
                                                                               ▼
                                                                       ┌───────────────┐
                                                                       │ VFS Session   │
                                                                       │ Tree Artifact │
                                                                       └───────────────┘
----

The ARGUS pipeline treats natural language as a noisy input source that must be compiled into a deterministic protocol before execution. This "Interpretation-First" strategy ensures that the probabilistic nature of LLMs is never allowed to leak into the system's state-management layer. The sequence begins at the Surface Adapter, where user utterances are captured and forwarded to the Calypso Host. This approach acknowledges that while human communication is fluid and conversational, scientific computation must remain absolute and verifiable.

Once an intent is received, the `IntentParser` performs a two-pass resolution. First, it checks for exact matches against a registry of high-priority workflow verbs (e.g., `search`, `harmonize`). If no deterministic match is found, the LLM is invoked as a semantic compiler, tasked with mapping the user's natural language to a strictly-typed JSON protocol. This process isolates the "Intelligence" of the AI to the translation layer only, ensuring that the AI has no direct power to mutate system state without a corresponding protocol definition.

Following successful compilation, the resolved protocol is subjected to a rigorous Gatekeeping phase by the `WorkflowAdapter`. The system performs a topological walk of the active manifest to verify that all prerequisites for the target stage have been materialized in the session tree. If a parent artifact is missing or stale, the execution is blocked, preventing the agent from proceeding based on invalid premises. This gatekeeping is the primary mechanism for preventing "Instructional Decay" during complex multi-step protocols.

The final stage is the dispatch to the `PluginHost`, which executes the logic and returns a result payload. This payload is then cryptographically anchored by the `MerkleEngine` and materialized as a physical artifact in the VFS. This closed-loop design ensures that "Truth" is measured in files on disk, not words in a chat window, providing the absolute integrity required for scientific workflows. By the time the result returns to the user, it is no longer an assertion but a materialized fact, proven by the presence of a Merkle-hashed artifact in the session tree.

== The SeaGaP State Machine

The following figure illustrates the procedural spine of the ARGUS research lifecycle.

[source,text]
----
┌────────┐     ┌────────┐     ┌─────────┐     ┌─────────┐     ┌──────┐
│ SEARCH │────▶│ GATHER │────▶│ PROCESS │────▶│ MONITOR │────▶│ POST │
└────────┘     └────────┘     └─────────┘     └─────────┘     └──────┘
     │              │              │               │              │
     └──────────────┴──────────────┴───────────────┴──────────────┘
----

The SeaGaP-MP framework defines the foundational structural spine of the ARGUS system, imposing a strict temporal order on the research process. It was designed to manage the inherent complexity of distributed imaging by organizing diverse tasks into a coherent, repeatable sequence of Search, Gather, Process, Monitor, and Post. Without this standard lifecycle, research goals remain ill-defined, making it impossible to coordinate complex operations across multiple sites. The framework provides a common procedural language that bridges the gap between diverse research personas.

Each stage in the SeaGaP sequence functions as a logical gate that must be satisfied before the next can commence. The **Search** stage focuses on discovery, while the **Gather** stage commits selected datasets into a project workspace. This distinction is critical for provenance; search records the criteria used to find data, while gather records the explicit intent to include that data in a specific scientific study. By separating discovery from commitment, ARGUS ensures that the provenance of the final model can be traced back to the initial search parameters.

The **Process** stage is where domain-specific compute occurs, governed by the Plugin VM and the DAG engine. Transitions between these high-level phases are monitored by the `WorkflowAdapter`, which enforces the "State-First" mandate. If a user attempts to skip a required stage, the system issues educational warnings, requiring explicit confirmation before allowing the workflow to deviate from the standard protocol. This "Soft Enforcement" model acknowledges the expertise of the human researcher while ensuring that deviations are intentional and documented.

Ultimately, the SeaGaP state machine ensures that progress is a matter of evidence rather than opinion. By grounding each stage in the materialization of physical VFS artifacts, ARGUS provides a transparent and auditable trail of the scientific process. This framework ensures that every result—from initial search to final model publication—is backed by a verifiable chain of custody, ensuring compliance with clinical research standards. The state machine serves as the "Guardian of Process," preventing the accidental omission of critical steps in the research lifecycle.

== Plugin Isolation and Boundaries

The following figure illustrates the sandboxed environment provided to Guest logic.

[source,text]
----
                  allowed via PluginContext
         ┌──────────────────────────────────────┐
         │ vfs │ shell │ store │ federation(opt)│
         └──────────────────┬───────────────────┘
                            │
                            ▼
                     ┌─────────────┐
                     │ Plugin Code │
                     └─────────────┘
                            │
        ┌───────────────────┴───────────────────┐
        │                                       │
        ▼                                       ▼
  ┌─────────────┐                        ┌───────────────┐
  │ allowed:    │                        │ forbidden:    │
  │ src/plugins │                        │ src/core/*    │
  │ returns     │                        │ orchestration │
  │ PluginResult│                        │ stage modules │
  └─────────────┘                        └───────────────┘
----

The ARGUS architecture enforces strict isolation of Guest logic to ensure that idiosyncratic changes to a specific workflow cannot compromise the stability of the system kernel. This is implemented through a "Plugin VM" model, where every plugin is a stateless transformation that executes within a restricted sandbox. Plugins are dynamically loaded on-demand, minimizing the system's memory footprint and allowing for the hot-swapping of research protocols. This design ensures that the core security and integrity mechanisms of the system are never exposed to unprivileged code.

Access to the system is mediated through the `PluginContext`, a strictly-defined "Standard Library" that represents the totality of a plugin's agency. Guest code is provided with project-scoped VFS access, environment management via the Shell, and restricted read/write access to the application Store. This context-based approach ensures that plugins remain modular and decoupled from the Host's internal state-management mechanisms. A plugin can mutate the project tree, but it has no power to touch the underlying system configuration or the session ledger.

A fundamental rule of the ARGUS architecture is the **Plugin Boundary**, which forbids any Guest code from importing modules from the core orchestration layer. This ensures that the system's "Intelligence" (the plugins) and its "Integrity" (the host) remain non-overlapping. By preventing these dependencies, Argus ensures that runtime logic remains UI-surface agnostic, allowing the same plugin to execute identically in a web browser or a headless CLI. This isolation is strictly enforced via automated boundary checks during the build process.

The result of a plugin execution is always a `PluginResult` payload, which contains the evidence required for the Host to advance the workflow. This contract ensures that plugins do not "mark" stages as complete; they simply return the data that the high-integrity Kernel will then anchor into the provenance chain. This separation of "Doing the Work" from "Recording the Result" is the key to maintaining a mathematically verifiable audit trail. The Host acts as the authoritative witness to the Guest's execution, cryptographically signing the outcome before it is recorded in the session tree.

== Merkle Provenance Topology

The following figure illustrates the physical mapping of the DAG into the session tree.

[source,text]
----
/sessions/fedml/session-001/
│
├── search/
│   ├── data/search.json
│   └── meta/fingerprint.json
│
├── search/gather/
│   ├── data/gather.json
│   └── meta/fingerprint.json
│
├── search/gather/harmonize/
│   ├── data/harmonize.json
│   └── meta/fingerprint.json
│
└── search/gather/harmonize/proceed/
    ├── data/proceed.json
    └── meta/fingerprint.json
----

The architectural "Conscience" of ARGUS is the Merkle session tree, which provides a physical ledger of the scientific process. The tree is structured as a direct mirror of the DAG manifest's topology, with each stage owning a specific directory in the VFS. This organization ensures that the provenance of every result is encoded in its filesystem path, making the lineage of any artifact immediately human-interpretable. This topological mapping transforms the abstract graph of the research protocol into a concrete physical reality on the virtual disk.

Every artifact materialized within this tree is wrapped in a Merkle envelope containing a SHA-256 fingerprint. This fingerprint is a recursive hash that incorporates both the artifact's own data and the fingerprints of its parent nodes in the DAG. This cryptographic anchoring ensures that the integrity of an artifact is inextricably linked to its entire historical context, providing a mathematical guarantee of consistency across long-running sessions. If any upstream data is tampered with, the fingerprints of all subsequent descendants will immediately fail verification.

The Merkle Engine utilizes this topological structure to perform real-time staleness detection. By comparing the parent fingerprints recorded in an artifact's metadata with the current state of the parent nodes, the system can instantly identify if upstream data has been modified. If a researcher re-runs an early stage, the system automatically flags all downstream descendants as `[STALE]`, forcing a re-verification of the scientific results. This ensures that the system's "Ground Truth" is always current and that no decisions are made based on outdated evidence.

Furthermore, the session tree supports historical branching through timestamped re-execution paths. This ensures that while the system maintains a "Main" branch of current truth, previous experimental attempts are preserved for forensic audit. This combination of topological nesting and cryptographic fingerprinting transforms the filesystem into a high-integrity ledger, providing the absolute provenance required for regulated research. The session tree is not just a storage location; it is the immutable record of the entire scientific journey performed within the ARGUS environment.

== Conclusion

The ARGUS v10.2 architecture represents a fundamental departure from conversational AI interfaces. By refactoring the system into a high-integrity Streaming Unified Kernel and a deterministic Plugin Virtual Machine, ARGUS effectively grounds the probabilistic "Intelligence" of the LLM in the "Ground Truth" of a persistent filesystem and a live telemetry ledger. The resulting system is not merely an assistant, but a robust Operating System for federated medical research. The architecture's commitment to state-first verification ensures that every scientific result produced by ARGUS is backed by a verifiable chain of evidence, providing the trust and security required for high-stakes scientific investigation.

---
_Last updated: 2026-02-18 (v10.2.0)_
